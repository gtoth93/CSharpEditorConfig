root = true

[*]

# Universal formatting options
charset = utf-8                                                                                     # latin1, utf-8, utf-16be, utf-16le, utf-8-bom
trim_trailing_whitespace = true                                                                     # remove whitespace at the end of the line
insert_final_newline = true                                                                         # add a newline at the end of the file
# tab_width = 4                                                                                     # number of characters in a tab character, defaults to indent_size if not set

# Universal formatting options recognized by CSharpier
# end_of_line = crlf                                                                                # lf, crlf, cr, don't set it for auto
indent_style = space                                                                                # tab or space
indent_size = 4                                                                                     # number of characters in an indent
max_line_length = 120                                                                               # number of characters in a line, ignored by dotnet-format

# noinspection EditorConfigKeyCorrectness
[*.cs]

#### Common formatting options ####

# New-line options
csharp_new_line_before_open_brace = all                                                             # Allman or K&R (all, none or comma separated list: accessors, anonymous_methods, anonymous_types, control_blocks, events, indexers, lambdas, local_functions, methods, object_collection_array_initializers, properties, types)
csharp_new_line_before_else = true                                                                  # start else block in a new line after the if block
csharp_new_line_before_catch = true                                                                 # start catch block in a new line after the try block
csharp_new_line_before_finally = true                                                               # start finally block in a new line after the try or catch block
csharp_new_line_before_members_in_object_initializers = true                                        # force members in object initializers to be on separate lines (only if multiline
csharp_new_line_between_query_expression_clauses = true                                             # force linq query clauses to be on separate lines (only if multiline)

# Indentation options
csharp_indent_switch_labels = true                                                                  # indent case labels in switch statements
csharp_indent_braces = false                                                                        # indent curly braces

# Spacing options
csharp_space_after_cast = false                                                                     # space between cast operator and value
csharp_space_after_keywords_in_control_flow_statements = true                                       # ReSharper: Generalized > Space before parenthesis of control flow statements
csharp_space_between_parentheses = false                                                            # space between parentheses (false or comma separated list: control_flow_statements, expressions, type_casts)
csharp_space_before_colon_in_inheritance_clause = true                                              # space before the colon when inheriting
csharp_space_after_colon_in_inheritance_clause = true                                               # space after the colon when inheriting
csharp_space_around_binary_operators = before_and_after                                             # space around binary operators (before_and_after, none, ignore)
csharp_space_between_method_declaration_parameter_list_parentheses = false                          # space after the opening parenthesis and before closing parenthesis for parameter lists in method declaration
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false                    # space between parentheses for empty parameter lists in method declarations
csharp_space_between_method_declaration_name_and_open_parenthesis = false                           # ReSharper: Generalized > Space before method declaration parenthesis
csharp_space_between_method_call_parameter_list_parentheses = false                                 # space after the opening parenthesis and before closing parenthesis for method calls
csharp_space_between_method_call_empty_parameter_list_parentheses = false                           # space between parentheses for empty method calls
csharp_space_between_method_call_name_and_opening_parenthesis = false                               # ReSharper: Generalized > Space before method call parenthesis
csharp_space_after_comma = true                                                                     # ReSharper: Generalized > Space after comma
csharp_space_before_comma = false                                                                   # ReSharper: Generalized > Space before comma
csharp_space_after_dot = false                                                                      # space after dot
csharp_space_before_dot = false                                                                     # space before dot
csharp_space_after_semicolon_in_for_statement = true                                                # space after semicolon in for statements
csharp_space_before_semicolon_in_for_statement = false                                              # space before semicolon in for statements
csharp_space_before_open_square_brackets = false                                                    # ReSharper: Generalized > Space before brackets
csharp_space_between_empty_square_brackets = false                                                  # space between empty square brackets
csharp_space_between_square_brackets = false                                                        # space between square brackets

# Wrap options
csharp_preserve_single_line_blocks = true                                                           # preserve single line code blocks

# Organize usings
dotnet_sort_system_directives_first = true                                                          # place System.* using directives before others
dotnet_separate_import_directive_groups = false                                                     # add blank line between using directive groups

#### dotnet-format/VS formatting options ####

# New-line options
csharp_new_line_before_members_in_anonymous_types = true                                            # force members in anonymous types to be on separate lines

# Indentation options
csharp_indent_case_contents = true                                                                  # indent case content in switch statements
csharp_indent_labels = no_change                                                                    # indent goto labels: flush_left, one_less_than_current, no_change
csharp_indent_block_contents = true                                                                 # indent block contents
csharp_indent_case_contents_when_block = false                                                      # indent case content in switch statements when in a block

# Spacing options
csharp_space_around_declaration_statements = false                                                  # ignore extra spaces in declaration statements (ignore, false)

# Wrap options
csharp_preserve_single_line_statements = false                                                      # preserve single line statements and method declarations

#### Common code style options ####
# severities: none, silent, suggestion, warning, error

# IDE0003, IDE0009: this. preferences
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion

# IDE0007, IDE0008: var preferences
csharp_style_var_elsewhere = true:suggestion
csharp_style_var_for_built_in_types = true:suggestion
csharp_style_var_when_type_is_apparent = true:suggestion

# Expression-level preferences
dotnet_style_prefer_collection_expression = when_types_loosely_match:suggestion                     # IDE0028, IDE0300, IDE0301, IDE0302, IDE0303, IDE0304, IDE0305, IDE0306: use collection expression (when_types_exactly_match, when_types_loosely_match, never)
csharp_style_prefer_utf8_string_literals = true:suggestion                                          # IDE0230: prefer utf8 string literals to byte arrays

# Modifier preferences
csharp_preferred_modifier_order = public,private,protected,internal,file,new,static,abstract,virtual,sealed,readonly,override,extern,unsafe,volatile,async,required:suggestion      # IDE0036: modifier keyword order
dotnet_style_require_accessibility_modifiers = for_non_interface_members:suggestion                 # IDE0040: require accessibility modifiers (always, for_non_interface_members, never, omit_if_default)

# IDE0047, IDE0048: Parentheses preferences (always_for_clarity, never_if_unnecessary)
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:suggestion             # *, /, %, +, -, <<, >>, &, ^, |
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:suggestion             # >, <, <=, >=, is, as, ==, !=
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:suggestion                  # &&, ||, ??

# IDE0049: Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion

# 'using' directive preferences
csharp_using_directive_placement = outside_namespace:suggestion                                     # IDE0065: using directive placement (outside_namespace, inside_namespace)

# IDE0073: require file header (non-empty string, {fileName}, unset)
file_header_template = unset
dotnet_diagnostic.ide0073.severity = none

# Code-block preferences
csharp_style_namespace_declarations = file_scoped:suggestion                                        # IDE0160, IDE0161: file or block scoped namespaces (block_scoped, file_scoped)

#### dotnet-format/VS code style options ####

# Code-block preferences
csharp_prefer_braces = true:suggestion                                                              # IDE0011: add braces to code blocks (true, false, when_multiline)
csharp_prefer_simple_using_statement = true:suggestion                                              # IDE0063: use simple 'using' statement
csharp_style_prefer_method_group_conversion = true:suggestion                                       # IDE0200: prefer method groups over lambdas
csharp_style_prefer_top_level_statements = true:suggestion                                          # IDE0210, IDE0211: prefer top-level statements
csharp_style_prefer_primary_constructors = false:none                                               # IDE0290: use primary constructor
csharp_prefer_system_threading_lock = true:suggestion                                               # IDE0330: prefer System.Threading.Lock to object

# Expression-level preferences
csharp_style_throw_expression = true:suggestion                                                     # IDE0016: use throw expression
dotnet_style_object_initializer = true:suggestion                                                   # IDE0017: use object initializer
csharp_style_inlined_variable_declaration = true:suggestion                                         # IDE0018: use inline out variable declaration
dotnet_style_collection_initializer = true:suggestion                                               # IDE0028: Use collection initializers
dotnet_style_coalesce_expression = true:suggestion                                                  # IDE0029, IDE0030, IDE0270: prefer null-coalescing expression
dotnet_style_null_propagation = true:suggestion                                                     # IDE0031: use null propagation
dotnet_style_prefer_auto_properties = true:suggestion                                               # IDE0032: use auto properties
dotnet_style_explicit_tuple_names = true:suggestion                                                 # IDE0033: use explicit tuple name
csharp_prefer_simple_default_expression = true:suggestion                                           # IDE0034: use simple 'default' expression
dotnet_style_prefer_inferred_tuple_names = true:suggestion                                          # IDE0037: use inferred tuple names
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion                          # IDE0037: use inferred anonymous type member names
csharp_style_prefer_local_over_anonymous_function = true:suggestion                                 # IDE0039: use local functions instead of lambda
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion                  # IDE0041: use 'is null' for reference equality
csharp_style_deconstructed_variable_declaration = true:suggestion                                   # IDE0042: use variable deconstruction
dotnet_style_prefer_conditional_expression_over_assignment = true:suggestion                        # IDE0045: prefer ternary expression over if-else in assignments
dotnet_style_prefer_conditional_expression_over_return = true:silent                                # IDE0046: prefer ternary expression over if-else in return statements
dotnet_style_prefer_compound_assignment = true:suggestion                                           # IDE0054, IDE0074: use compound assignment
csharp_style_prefer_index_operator = true:suggestion                                                # IDE0056: use index operator [^]
csharp_style_prefer_range_operator = true:suggestion                                                # IDE0057: use range operator [..]
csharp_style_unused_value_expression_statement_preference = discard_variable:silent                 # IDE0058: use discard or unused local variable for expressions (discard_variable, unused_local_variable)
csharp_style_unused_value_assignment_preference = discard_variable:suggestion                       # IDE0059: use discard or unused local variable for assignments (discard_variable, unused_local_variable)
dotnet_style_prefer_simplified_interpolation = true:suggestion                                      # IDE0071: simplify interpolation
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion                                # IDE0075: simplify conditional expression
csharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion                       # IDE0090: use target-typed new
dotnet_style_namespace_match_folder = true:suggestion                                               # IDE0130: Namespace should match folder structure
csharp_style_prefer_null_check_over_type_check = true:suggestion                                    # IDE0150: prefer null check over type check
csharp_style_prefer_tuple_swap = true:suggestion                                                    # IDE0180: use tuples to swap values
dotnet_style_prefer_foreach_explicit_cast_in_source = when_strongly_typed:suggestion                # IDE0220: add explicit cast in foreach loop (always, when_strongly_typed)
csharp_style_prefer_unbound_generic_type_in_nameof = true:suggestion                                # IDE0340: use unbound generic type in nameof
csharp_style_prefer_implicitly_typed_lambda_expression = true:suggestion                            # IDE0350: use implicitly typed lambda

# Pattern matching preferences
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion                             # IDE0019, IDE0260: use pattern matching over 'as' with null check
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion                             # IDE0020, IDE0038: use pattern matching over 'is' with cast check
csharp_style_prefer_switch_expression = true:suggestion                                             # IDE0066: use switch expression
csharp_style_prefer_pattern_matching = true:silent                                                  # IDE0078: use pattern matching
csharp_style_prefer_not_pattern = true:suggestion                                                   # IDE0083: use 'not' pattern
csharp_style_prefer_extended_property_pattern = true:suggestion                                     # IDE0170: use extended property pattern

# Expression-bodied members
csharp_style_expression_bodied_constructors = false:silent                                          # IDE0021: use expression body for constructors (true, when_on_single_line, false)
csharp_style_expression_bodied_methods = false:silent                                               # IDE0022: use expression body for methods (true, when_on_single_line, false)
csharp_style_expression_bodied_operators = false:silent                                             # IDE0023, IDE0024: use expression body for operators (true, when_on_single_line, false)
csharp_style_expression_bodied_properties = true:silent                                             # IDE0025: use expression body for properties (true, when_on_single_line, false)
csharp_style_expression_bodied_indexers = true:silent                                               # IDE0026: use expression body for indexers (true, when_on_single_line, false)
csharp_style_expression_bodied_accessors = true:silent                                              # IDE0027: use expression body for accessors (true, when_on_single_line, false)
csharp_style_expression_bodied_lambdas = true:silent                                                # IDE0053: use expression body for lambdas (true, when_on_single_line, false)
csharp_style_expression_bodied_local_functions = false:silent                                       # IDE0061: use expression body for local functions (true, when_on_single_line, false)

# Field preferences
dotnet_style_readonly_field = true:suggestion                                                       # IDE0044: add readonly modifier to private fields

# Parentheses preferences
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent                           # IDE0047, IDE0048: parentheses preferences for other operators (always_for_clarity, never_if_unnecessary)

# Parameter preferences
dotnet_code_quality_unused_parameters = all:suggestion                                              # IDE0060: remove unused parameter (all, non_public)

# Modifier preferences
csharp_prefer_static_local_function = true:suggestion                                               # IDE0062: make local function static
csharp_style_prefer_readonly_struct = true:suggestion                                               # IDE0250: struct can be made readonly
csharp_style_prefer_readonly_struct_member = true:suggestion                                        # IDE0251: struct member can be made readonly
csharp_prefer_static_anonymous_function = true:suggestion                                           # IDE0320: make anonymous function static

# Suppression preferences
dotnet_remove_unnecessary_suppression_exclusions = none:silent                                      # IDE0079: remove unnecessary suppression (comma separated list of rule IDs or categories prefixed with category:, all, none)

# Null-checking preferences
csharp_style_conditional_delegate_call = true:suggestion                                            # IDE1005: use ?. when invoking lambda

# New line preferences
dotnet_style_allow_multiple_blank_lines_experimental = true:silent                                  # IDE2000: allow multiple blank lines
csharp_style_allow_embedded_statements_on_same_line_experimental = true:silent                      # IDE2001: allow embedded statements on same line as control keyword
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent                # IDE2002: allow blank lines between consecutive braces
dotnet_style_allow_statement_immediately_after_block_experimental = true:silent                     # IDE2003: allow subsequent statement to immediately follow block statement without a blank line in between
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent     # IDE2004: allow a blank line after the colon in a constructor initializer
csharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true:silent      # IDE2005: allow a blank line after the token in a ternary expression
csharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true:silent     # IDE2006: allow a blank line after the token in an arrow expression

# Code style rules without options
dotnet_diagnostic.ide0063.severity = warning

dotnet_diagnostic.ide0001.severity = none                                                           # IDE0001: simplify name
dotnet_diagnostic.ide0002.severity = none                                                           # IDE0002: simplify member access
dotnet_diagnostic.ide0004.severity = none                                                           # IDE0004: remove unnecessary cast
dotnet_diagnostic.ide0005.severity = none                                                           # IDE0005: remove unnecessary import
dotnet_diagnostic.ide0010.severity = none                                                           # IDE0010: add missing cases to switch statement
dotnet_diagnostic.ide0035.severity = none                                                           # IDE0035: remove unreachable code
dotnet_diagnostic.ide0050.severity = none                                                           # IDE0050: convert anonymous type to tuple
dotnet_diagnostic.ide0051.severity = none                                                           # IDE0051: remove unused private member
dotnet_diagnostic.ide0052.severity = none                                                           # IDE0052: remove unread private member
dotnet_diagnostic.ide0055.severity = none                                                           # IDE0055: fix formatting
dotnet_diagnostic.ide0064.severity = none                                                           # IDE0064: make struct fields writable
dotnet_diagnostic.ide0070.severity = none                                                           # IDE0070: use System.HashCode.Combine
dotnet_diagnostic.ide0072.severity = none                                                           # IDE0072: add missing cases to switch expression
dotnet_diagnostic.ide0076.severity = none                                                           # IDE0076: remove invalid global SuppressMessageAttribute
dotnet_diagnostic.ide0077.severity = none                                                           # IDE0077: avoid legacy format target in global SuppressMessageAttribute
dotnet_diagnostic.ide0080.severity = none                                                           # IDE0080: remove unnecessary null-forgiving operator
dotnet_diagnostic.ide0082.severity = none                                                           # IDE0082: convert typeof to nameof
dotnet_diagnostic.ide0100.severity = none                                                           # IDE0100: remove unnecessary equality operator
dotnet_diagnostic.ide0110.severity = none                                                           # IDE0110: remove unnecessary discard
dotnet_diagnostic.ide0120.severity = none                                                           # IDE0120: simplify LINQ expression
dotnet_diagnostic.ide0121.severity = none                                                           # IDE0121: simplify LINQ type check and cast
dotnet_diagnostic.ide0240.severity = none                                                           # IDE0240: nullable directive is redundant
dotnet_diagnostic.ide0241.severity = none                                                           # IDE0241: nullable directive is unnecessary
dotnet_diagnostic.ide0280.severity = none                                                           # IDE0280: use nameof
dotnet_diagnostic.ide1006.severity = none                                                           # IDE1006: inconsistent naming
dotnet_diagnostic.ide3000.severity = none                                                           # IDE3000: implement with Copilot

#### Naming style options ####

dotnet_naming_rule.constants_rule.import_to_resharper = True
dotnet_naming_rule.constants_rule.resharper_description = Constant fields (not private)
dotnet_naming_rule.constants_rule.resharper_guid = 669e5282-fb4b-4e90-91e7-07d269d04b60
dotnet_naming_rule.constants_rule.severity = warning
dotnet_naming_rule.constants_rule.style = upper_camel_case_style
dotnet_naming_rule.constants_rule.symbols = constants_symbols

dotnet_naming_rule.enum_member_rule.import_to_resharper = True
dotnet_naming_rule.enum_member_rule.resharper_description = Enum members
dotnet_naming_rule.enum_member_rule.resharper_guid = 8b8504e3-f0be-4c14-9103-c732f2bddc15
dotnet_naming_rule.enum_member_rule.severity = warning
dotnet_naming_rule.enum_member_rule.style = upper_camel_case_style
dotnet_naming_rule.enum_member_rule.symbols = enum_member_symbols

dotnet_naming_rule.event_rule.import_to_resharper = True
dotnet_naming_rule.event_rule.resharper_description = Events
dotnet_naming_rule.event_rule.resharper_guid = 0c4c6401-2a1f-4db1-a21f-562f51542cf8
dotnet_naming_rule.event_rule.severity = warning
dotnet_naming_rule.event_rule.style = upper_camel_case_style
dotnet_naming_rule.event_rule.symbols = event_symbols

dotnet_naming_rule.interfaces_rule.import_to_resharper = True
dotnet_naming_rule.interfaces_rule.resharper_description = Interfaces
dotnet_naming_rule.interfaces_rule.resharper_exclusive_prefixes_suffixes = true
dotnet_naming_rule.interfaces_rule.resharper_guid = a7a3339e-4e89-4319-9735-a9dc4cb74cc7
dotnet_naming_rule.interfaces_rule.severity = warning
dotnet_naming_rule.interfaces_rule.style = i_upper_camel_case_style
dotnet_naming_rule.interfaces_rule.symbols = interfaces_symbols

dotnet_naming_rule.locals_rule.import_to_resharper = True
dotnet_naming_rule.locals_rule.resharper_description = Local variables
dotnet_naming_rule.locals_rule.resharper_guid = 61a991a4-d0a3-4d19-90a5-f8f4d75c30c1
dotnet_naming_rule.locals_rule.severity = warning
dotnet_naming_rule.locals_rule.style = lower_camel_case_style_1
dotnet_naming_rule.locals_rule.symbols = locals_symbols

dotnet_naming_rule.local_constants_rule.import_to_resharper = True
dotnet_naming_rule.local_constants_rule.resharper_description = Local constants
dotnet_naming_rule.local_constants_rule.resharper_guid = a4f433b8-abcd-4e55-a08f-82e78cef0f0c
dotnet_naming_rule.local_constants_rule.severity = warning
dotnet_naming_rule.local_constants_rule.style = lower_camel_case_style_1
dotnet_naming_rule.local_constants_rule.symbols = local_constants_symbols

dotnet_naming_rule.local_functions_rule.import_to_resharper = True
dotnet_naming_rule.local_functions_rule.resharper_description = Local functions
dotnet_naming_rule.local_functions_rule.resharper_guid = 76f79b1e-ece7-4df2-a322-1bd7fea25eb7
dotnet_naming_rule.local_functions_rule.severity = warning
dotnet_naming_rule.local_functions_rule.style = upper_camel_case_style
dotnet_naming_rule.local_functions_rule.symbols = local_functions_symbols

dotnet_naming_rule.method_rule.import_to_resharper = True
dotnet_naming_rule.method_rule.resharper_description = Methods
dotnet_naming_rule.method_rule.resharper_guid = 8284009d-e743-4d89-9402-a5bf9a89b657
dotnet_naming_rule.method_rule.severity = warning
dotnet_naming_rule.method_rule.style = upper_camel_case_style
dotnet_naming_rule.method_rule.symbols = method_symbols

dotnet_naming_rule.parameters_rule.import_to_resharper = True
dotnet_naming_rule.parameters_rule.resharper_description = Parameters
dotnet_naming_rule.parameters_rule.resharper_guid = 8a85b61a-1024-4f87-b9ef-1fdae19930a1
dotnet_naming_rule.parameters_rule.severity = warning
dotnet_naming_rule.parameters_rule.style = lower_camel_case_style_1
dotnet_naming_rule.parameters_rule.symbols = parameters_symbols

dotnet_naming_rule.private_constants_rule.import_to_resharper = True
dotnet_naming_rule.private_constants_rule.resharper_description = Constant fields (private)
dotnet_naming_rule.private_constants_rule.resharper_guid = 236f7aa5-7b06-43ca-bf2a-9b31bfcff09a
dotnet_naming_rule.private_constants_rule.severity = warning
dotnet_naming_rule.private_constants_rule.style = upper_camel_case_style
dotnet_naming_rule.private_constants_rule.symbols = private_constants_symbols

dotnet_naming_rule.private_instance_fields_rule.import_to_resharper = True
dotnet_naming_rule.private_instance_fields_rule.resharper_description = Instance fields (private)
dotnet_naming_rule.private_instance_fields_rule.resharper_exclusive_prefixes_suffixes = true
dotnet_naming_rule.private_instance_fields_rule.resharper_guid = 4a98fdf6-7d98-4f5a-afeb-ea44ad98c70c
dotnet_naming_rule.private_instance_fields_rule.severity = warning
dotnet_naming_rule.private_instance_fields_rule.style = lower_camel_case_style
dotnet_naming_rule.private_instance_fields_rule.symbols = private_instance_fields_symbols

dotnet_naming_rule.private_static_fields_rule.import_to_resharper = True
dotnet_naming_rule.private_static_fields_rule.resharper_description = Static fields (private)
dotnet_naming_rule.private_static_fields_rule.resharper_exclusive_prefixes_suffixes = true
dotnet_naming_rule.private_static_fields_rule.resharper_guid = f9fce829-e6f4-4cb2-80f1-5497c44f51df
dotnet_naming_rule.private_static_fields_rule.severity = warning
dotnet_naming_rule.private_static_fields_rule.style = lower_camel_case_style
dotnet_naming_rule.private_static_fields_rule.symbols = private_static_fields_symbols

dotnet_naming_rule.private_static_readonly_rule.import_to_resharper = True
dotnet_naming_rule.private_static_readonly_rule.resharper_description = Static readonly fields (private)
dotnet_naming_rule.private_static_readonly_rule.resharper_guid = 15b5b1f1-457c-4ca6-b278-5615aedc07d3
dotnet_naming_rule.private_static_readonly_rule.severity = warning
dotnet_naming_rule.private_static_readonly_rule.style = upper_camel_case_style
dotnet_naming_rule.private_static_readonly_rule.symbols = private_static_readonly_symbols

dotnet_naming_rule.property_rule.import_to_resharper = True
dotnet_naming_rule.property_rule.resharper_description = Properties
dotnet_naming_rule.property_rule.resharper_guid = c85a0503-4de2-40f1-9cd6-a4054c05d384
dotnet_naming_rule.property_rule.severity = warning
dotnet_naming_rule.property_rule.style = upper_camel_case_style
dotnet_naming_rule.property_rule.symbols = property_symbols

dotnet_naming_rule.public_fields_rule.import_to_resharper = True
dotnet_naming_rule.public_fields_rule.resharper_description = Instance fields (not private)
dotnet_naming_rule.public_fields_rule.resharper_guid = 53eecf85-d821-40e8-ac97-fdb734542b84
dotnet_naming_rule.public_fields_rule.severity = warning
dotnet_naming_rule.public_fields_rule.style = upper_camel_case_style
dotnet_naming_rule.public_fields_rule.symbols = public_fields_symbols

dotnet_naming_rule.public_static_fields_rule.import_to_resharper = True
dotnet_naming_rule.public_static_fields_rule.resharper_description = Static fields (not private)
dotnet_naming_rule.public_static_fields_rule.resharper_guid = 70345118-4b40-4ece-937c-bbeb7a0b2e70
dotnet_naming_rule.public_static_fields_rule.severity = warning
dotnet_naming_rule.public_static_fields_rule.style = upper_camel_case_style
dotnet_naming_rule.public_static_fields_rule.symbols = public_static_fields_symbols

dotnet_naming_rule.static_readonly_rule.import_to_resharper = True
dotnet_naming_rule.static_readonly_rule.resharper_description = Static readonly fields (not private)
dotnet_naming_rule.static_readonly_rule.resharper_guid = c873eafb-d57f-481d-8c93-77f6863c2f88
dotnet_naming_rule.static_readonly_rule.severity = warning
dotnet_naming_rule.static_readonly_rule.style = upper_camel_case_style
dotnet_naming_rule.static_readonly_rule.symbols = static_readonly_symbols

dotnet_naming_rule.types_and_namespaces_rule.import_to_resharper = True
dotnet_naming_rule.types_and_namespaces_rule.resharper_description = Types and namespaces
dotnet_naming_rule.types_and_namespaces_rule.resharper_guid = a0b4bc4d-d13b-4a37-b37e-c9c6864e4302
dotnet_naming_rule.types_and_namespaces_rule.severity = warning
dotnet_naming_rule.types_and_namespaces_rule.style = upper_camel_case_style
dotnet_naming_rule.types_and_namespaces_rule.symbols = types_and_namespaces_symbols

dotnet_naming_rule.type_parameters_rule.import_to_resharper = True
dotnet_naming_rule.type_parameters_rule.resharper_description = Type parameters
dotnet_naming_rule.type_parameters_rule.resharper_exclusive_prefixes_suffixes = true
dotnet_naming_rule.type_parameters_rule.resharper_guid = 2c62818f-621b-4425-adc9-78611099bfcb
dotnet_naming_rule.type_parameters_rule.severity = warning
dotnet_naming_rule.type_parameters_rule.style = t_upper_camel_case_style
dotnet_naming_rule.type_parameters_rule.symbols = type_parameters_symbols

dotnet_naming_rule.unity_serialized_field_rule.import_to_resharper = True
dotnet_naming_rule.unity_serialized_field_rule.resharper_description = Unity serialized field
dotnet_naming_rule.unity_serialized_field_rule.resharper_guid = 5f0fdb63-c892-4d2c-9324-15c80b22a7ef
dotnet_naming_rule.unity_serialized_field_rule.severity = warning
dotnet_naming_rule.unity_serialized_field_rule.style = lower_camel_case_style_1
dotnet_naming_rule.unity_serialized_field_rule.symbols = unity_serialized_field_symbols

dotnet_naming_style.i_upper_camel_case_style.capitalization = pascal_case
dotnet_naming_style.i_upper_camel_case_style.required_prefix = I

dotnet_naming_style.lower_camel_case_style.capitalization = camel_case
dotnet_naming_style.lower_camel_case_style.required_prefix = _

dotnet_naming_style.lower_camel_case_style_1.capitalization = camel_case

dotnet_naming_style.t_upper_camel_case_style.capitalization = pascal_case
dotnet_naming_style.t_upper_camel_case_style.required_prefix = T

dotnet_naming_style.upper_camel_case_style.capitalization = pascal_case

dotnet_naming_symbols.constants_symbols.applicable_accessibilities = public,internal,protected,protected_internal,private_protected
dotnet_naming_symbols.constants_symbols.applicable_kinds = field
dotnet_naming_symbols.constants_symbols.required_modifiers = const
dotnet_naming_symbols.constants_symbols.resharper_applicable_kinds = constant_field
dotnet_naming_symbols.constants_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.enum_member_symbols.applicable_accessibilities = *
dotnet_naming_symbols.enum_member_symbols.applicable_kinds =
dotnet_naming_symbols.enum_member_symbols.resharper_applicable_kinds = enum_member
dotnet_naming_symbols.enum_member_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.event_symbols.applicable_accessibilities = *
dotnet_naming_symbols.event_symbols.applicable_kinds = event
dotnet_naming_symbols.event_symbols.resharper_applicable_kinds = event
dotnet_naming_symbols.event_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.interfaces_symbols.applicable_accessibilities = *
dotnet_naming_symbols.interfaces_symbols.applicable_kinds = interface
dotnet_naming_symbols.interfaces_symbols.resharper_applicable_kinds = interface
dotnet_naming_symbols.interfaces_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.locals_symbols.applicable_accessibilities = *
dotnet_naming_symbols.locals_symbols.applicable_kinds = local
dotnet_naming_symbols.locals_symbols.resharper_applicable_kinds = local_variable
dotnet_naming_symbols.locals_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.local_constants_symbols.applicable_accessibilities = *
dotnet_naming_symbols.local_constants_symbols.applicable_kinds = local
dotnet_naming_symbols.local_constants_symbols.required_modifiers = const
dotnet_naming_symbols.local_constants_symbols.resharper_applicable_kinds = local_constant
dotnet_naming_symbols.local_constants_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.local_functions_symbols.applicable_accessibilities = *
dotnet_naming_symbols.local_functions_symbols.applicable_kinds = local_function
dotnet_naming_symbols.local_functions_symbols.resharper_applicable_kinds = local_function
dotnet_naming_symbols.local_functions_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.method_symbols.applicable_accessibilities = *
dotnet_naming_symbols.method_symbols.applicable_kinds = method
dotnet_naming_symbols.method_symbols.resharper_applicable_kinds = method
dotnet_naming_symbols.method_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.parameters_symbols.applicable_accessibilities = *
dotnet_naming_symbols.parameters_symbols.applicable_kinds = parameter
dotnet_naming_symbols.parameters_symbols.resharper_applicable_kinds = parameter
dotnet_naming_symbols.parameters_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.private_constants_symbols.applicable_accessibilities = private
dotnet_naming_symbols.private_constants_symbols.applicable_kinds = field
dotnet_naming_symbols.private_constants_symbols.required_modifiers = const
dotnet_naming_symbols.private_constants_symbols.resharper_applicable_kinds = constant_field
dotnet_naming_symbols.private_constants_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.private_instance_fields_symbols.applicable_accessibilities = private
dotnet_naming_symbols.private_instance_fields_symbols.applicable_kinds = field
dotnet_naming_symbols.private_instance_fields_symbols.resharper_applicable_kinds = field,readonly_field
dotnet_naming_symbols.private_instance_fields_symbols.resharper_required_modifiers = instance

dotnet_naming_symbols.private_static_fields_symbols.applicable_accessibilities = private
dotnet_naming_symbols.private_static_fields_symbols.applicable_kinds = field
dotnet_naming_symbols.private_static_fields_symbols.required_modifiers = static
dotnet_naming_symbols.private_static_fields_symbols.resharper_applicable_kinds = field
dotnet_naming_symbols.private_static_fields_symbols.resharper_required_modifiers = static

dotnet_naming_symbols.private_static_readonly_symbols.applicable_accessibilities = private
dotnet_naming_symbols.private_static_readonly_symbols.applicable_kinds = field
dotnet_naming_symbols.private_static_readonly_symbols.required_modifiers = readonly,static
dotnet_naming_symbols.private_static_readonly_symbols.resharper_applicable_kinds = readonly_field
dotnet_naming_symbols.private_static_readonly_symbols.resharper_required_modifiers = static

dotnet_naming_symbols.property_symbols.applicable_accessibilities = *
dotnet_naming_symbols.property_symbols.applicable_kinds = property
dotnet_naming_symbols.property_symbols.resharper_applicable_kinds = property
dotnet_naming_symbols.property_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.public_fields_symbols.applicable_accessibilities = public,internal,protected,protected_internal,private_protected
dotnet_naming_symbols.public_fields_symbols.applicable_kinds = field
dotnet_naming_symbols.public_fields_symbols.resharper_applicable_kinds = field,readonly_field
dotnet_naming_symbols.public_fields_symbols.resharper_required_modifiers = instance

dotnet_naming_symbols.public_static_fields_symbols.applicable_accessibilities = public,internal,protected,protected_internal,private_protected
dotnet_naming_symbols.public_static_fields_symbols.applicable_kinds = field
dotnet_naming_symbols.public_static_fields_symbols.required_modifiers = static
dotnet_naming_symbols.public_static_fields_symbols.resharper_applicable_kinds = field
dotnet_naming_symbols.public_static_fields_symbols.resharper_required_modifiers = static

dotnet_naming_symbols.static_readonly_symbols.applicable_accessibilities = public,internal,protected,protected_internal,private_protected
dotnet_naming_symbols.static_readonly_symbols.applicable_kinds = field
dotnet_naming_symbols.static_readonly_symbols.required_modifiers = readonly,static
dotnet_naming_symbols.static_readonly_symbols.resharper_applicable_kinds = readonly_field
dotnet_naming_symbols.static_readonly_symbols.resharper_required_modifiers = static

dotnet_naming_symbols.types_and_namespaces_symbols.applicable_accessibilities = *
dotnet_naming_symbols.types_and_namespaces_symbols.applicable_kinds = class,delegate,enum,namespace,struct
dotnet_naming_symbols.types_and_namespaces_symbols.resharper_applicable_kinds = namespace,class,struct,enum,delegate
dotnet_naming_symbols.types_and_namespaces_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.type_parameters_symbols.applicable_accessibilities = *
dotnet_naming_symbols.type_parameters_symbols.applicable_kinds = type_parameter
dotnet_naming_symbols.type_parameters_symbols.resharper_applicable_kinds = type_parameter
dotnet_naming_symbols.type_parameters_symbols.resharper_required_modifiers = any

dotnet_naming_symbols.unity_serialized_field_symbols.applicable_accessibilities = *
dotnet_naming_symbols.unity_serialized_field_symbols.applicable_kinds =
dotnet_naming_symbols.unity_serialized_field_symbols.resharper_applicable_kinds = unity_serialised_field
dotnet_naming_symbols.unity_serialized_field_symbols.resharper_required_modifiers = instance

#### Roslyn analyzer rules ####

dotnet_diagnostic.ca2252.severity = error
dotnet_diagnostic.ca2254.severity = suggestion

dotnet_diagnostic.cs0006.severity = error                                                           # CS0006: Metadata file '{0}' could not be found
dotnet_diagnostic.cs0009.severity = error                                                           # CS0009: Metadata file '{0}' could not be opened -- {1}
dotnet_diagnostic.cs0012.severity = error                                                           # CS0012: The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.
dotnet_diagnostic.cs0016.severity = error                                                           # CS0016: Could not write to output file '{0}' -- '{1}'
dotnet_diagnostic.cs0017.severity = error                                                           # CS0017: Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.
dotnet_diagnostic.cs0019.severity = error                                                           # CS0019: Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'
dotnet_diagnostic.cs0020.severity = error                                                           # CS0020: Division by constant zero
dotnet_diagnostic.cs0021.severity = error                                                           # CS0021: Cannot apply indexing with [] to an expression of type '{0}'
dotnet_diagnostic.cs0022.severity = error                                                           # CS0022: Wrong number of indices inside []; expected {0}
dotnet_diagnostic.cs0023.severity = error                                                           # CS0023: Operator '{0}' cannot be applied to operand of type '{1}'
dotnet_diagnostic.cs0026.severity = error                                                           # CS0026: Keyword 'this' is not valid in a static property, static method, or static field initializer
dotnet_diagnostic.cs0027.severity = error                                                           # CS0027: Keyword 'this' is not available in the current context
dotnet_diagnostic.cs0028.severity = warning                                                         # CS0028: '{0}' has the wrong signature to be an entry point
dotnet_diagnostic.cs0029.severity = error                                                           # CS0029: Cannot implicitly convert type '{0}' to '{1}'
dotnet_diagnostic.cs0030.severity = error                                                           # CS0030: Cannot convert type '{0}' to '{1}'
dotnet_diagnostic.cs0031.severity = error                                                           # CS0031: Constant value '{0}' cannot be converted to a '{1}'
dotnet_diagnostic.cs0034.severity = error                                                           # CS0034: Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'
dotnet_diagnostic.cs0035.severity = error                                                           # CS0035: Operator '{0}' is ambiguous on an operand of type '{1}'
dotnet_diagnostic.cs0036.severity = error                                                           # CS0036: An out parameter cannot have the In attribute
dotnet_diagnostic.cs0037.severity = error                                                           # CS0037: Cannot convert null to '{0}' because it is a non-nullable value type
dotnet_diagnostic.cs0039.severity = error                                                           # CS0039: Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion
dotnet_diagnostic.cs0041.severity = error                                                           # CS0041: Unexpected error writing debug information -- '{0}'
dotnet_diagnostic.cs0050.severity = error                                                           # CS0050: Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'
dotnet_diagnostic.cs0051.severity = error                                                           # CS0051: Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'
dotnet_diagnostic.cs0052.severity = error                                                           # CS0052: Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'
dotnet_diagnostic.cs0053.severity = error                                                           # CS0053: Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'
dotnet_diagnostic.cs0054.severity = error                                                           # CS0054: Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'
dotnet_diagnostic.cs0055.severity = error                                                           # CS0055: Inconsistent accessibility: parameter type '{1}' is less accessible than indexer or property '{0}'
dotnet_diagnostic.cs0056.severity = error                                                           # CS0056: Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'
dotnet_diagnostic.cs0057.severity = error                                                           # CS0057: Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'
dotnet_diagnostic.cs0058.severity = error                                                           # CS0058: Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'
dotnet_diagnostic.cs0059.severity = error                                                           # CS0059: Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'
dotnet_diagnostic.cs0060.severity = error                                                           # CS0060: Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'
dotnet_diagnostic.cs0061.severity = error                                                           # CS0061: Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'
dotnet_diagnostic.cs0065.severity = error                                                           # CS0065: '{0}': event property must have both add and remove accessors
dotnet_diagnostic.cs0066.severity = error                                                           # CS0066: '{0}': event must be of a delegate type
dotnet_diagnostic.cs0067.severity = warning                                                         # CS0067: The event '{0}' is never used
dotnet_diagnostic.cs0068.severity = error                                                           # CS0068: '{0}': instance event in interface cannot have initializer
dotnet_diagnostic.cs0070.severity = error                                                           # CS0070: The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')
dotnet_diagnostic.cs0071.severity = error                                                           # CS0071: An explicit interface implementation of an event must use event accessor syntax
dotnet_diagnostic.cs0072.severity = error                                                           # CS0072: '{0}': cannot override; '{1}' is not an event
dotnet_diagnostic.cs0073.severity = error                                                           # CS0073: An add or remove accessor must have a body
dotnet_diagnostic.cs0074.severity = error                                                           # CS0074: '{0}': abstract event cannot have initializer
dotnet_diagnostic.cs0075.severity = error                                                           # CS0075: To cast a negative value, you must enclose the value in parentheses.
dotnet_diagnostic.cs0076.severity = error                                                           # CS0076: The enumerator name '{0}' is reserved and cannot be used
dotnet_diagnostic.cs0077.severity = error                                                           # CS0077: The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)
dotnet_diagnostic.cs0078.severity = warning                                                         # CS0078: The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity
dotnet_diagnostic.cs0079.severity = error                                                           # CS0079: The event '{0}' can only appear on the left hand side of += or -=
dotnet_diagnostic.cs0080.severity = error                                                           # CS0080: Constraints are not allowed on non-generic declarations
dotnet_diagnostic.cs0081.severity = error                                                           # CS0081: Type parameter declaration must be an identifier not a type
dotnet_diagnostic.cs0082.severity = error                                                           # CS0082: Type '{1}' already reserves a member called '{0}' with the same parameter types
dotnet_diagnostic.cs0100.severity = error                                                           # CS0100: The parameter name '{0}' is a duplicate
dotnet_diagnostic.cs0101.severity = error                                                           # CS0101: The namespace '{1}' already contains a definition for '{0}'
dotnet_diagnostic.cs0102.severity = error                                                           # CS0102: The type '{0}' already contains a definition for '{1}'
dotnet_diagnostic.cs0103.severity = error                                                           # CS0103: The name '{0}' does not exist in the current context
dotnet_diagnostic.cs0104.severity = error                                                           # CS0104: '{0}' is an ambiguous reference between '{1}' and '{2}'
dotnet_diagnostic.cs0105.severity = warning                                                         # CS0105: The using directive for '{0}' appeared previously in this namespace
dotnet_diagnostic.cs0106.severity = error                                                           # CS0106: The modifier '{0}' is not valid for this item
dotnet_diagnostic.cs0107.severity = error                                                           # CS0107: More than one protection modifier
dotnet_diagnostic.cs0108.severity = warning                                                         # CS0108: '{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.
dotnet_diagnostic.cs0109.severity = warning                                                         # CS0109: The member '{0}' does not hide an accessible member. The new keyword is not required.
dotnet_diagnostic.cs0110.severity = error                                                           # CS0110: The evaluation of the constant value for '{0}' involves a circular definition
dotnet_diagnostic.cs0111.severity = error                                                           # CS0111: Type '{1}' already defines a member called '{0}' with the same parameter types
dotnet_diagnostic.cs0112.severity = error                                                           # CS0112: A static member cannot be marked as '{0}'
dotnet_diagnostic.cs0113.severity = error                                                           # CS0113: A member '{0}' marked as override cannot be marked as new or virtual
dotnet_diagnostic.cs0114.severity = warning                                                         # CS0114: '{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
dotnet_diagnostic.cs0115.severity = error                                                           # CS0115: '{0}': no suitable method found to override
dotnet_diagnostic.cs0116.severity = error                                                           # CS0116: A namespace cannot directly contain members such as fields, methods or statements
dotnet_diagnostic.cs0117.severity = error                                                           # CS0117: '{0}' does not contain a definition for '{1}'
dotnet_diagnostic.cs0118.severity = error                                                           # CS0118: '{0}' is a {1} but is used like a {2}
dotnet_diagnostic.cs0119.severity = error                                                           # CS0119: '{0}' is a {1}, which is not valid in the given context
dotnet_diagnostic.cs0120.severity = error                                                           # CS0120: An object reference is required for the non-static field, method, or property '{0}'
dotnet_diagnostic.cs0121.severity = error                                                           # CS0121: The call is ambiguous between the following methods or properties: '{0}' and '{1}'
dotnet_diagnostic.cs0122.severity = error                                                           # CS0122: '{0}' is inaccessible due to its protection level
dotnet_diagnostic.cs0123.severity = error                                                           # CS0123: No overload for '{0}' matches delegate '{1}'
dotnet_diagnostic.cs0126.severity = error                                                           # CS0126: An object of a type convertible to '{0}' is required
dotnet_diagnostic.cs0127.severity = error                                                           # CS0127: Since '{0}' returns void, a return keyword must not be followed by an object expression
dotnet_diagnostic.cs0128.severity = error                                                           # CS0128: A local variable or function named '{0}' is already defined in this scope
dotnet_diagnostic.cs0131.severity = error                                                           # CS0131: The left-hand side of an assignment must be a variable, property or indexer
dotnet_diagnostic.cs0132.severity = error                                                           # CS0132: '{0}': a static constructor must be parameterless
dotnet_diagnostic.cs0133.severity = error                                                           # CS0133: The expression being assigned to '{0}' must be constant
dotnet_diagnostic.cs0134.severity = error                                                           # CS0134: '{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.
dotnet_diagnostic.cs0136.severity = error                                                           # CS0136: A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
dotnet_diagnostic.cs0138.severity = error                                                           # CS0138: A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead
dotnet_diagnostic.cs0139.severity = error                                                           # CS0139: No enclosing loop out of which to break or continue
dotnet_diagnostic.cs0140.severity = error                                                           # CS0140: The label '{0}' is a duplicate
dotnet_diagnostic.cs0143.severity = error                                                           # CS0143: The type '{0}' has no constructors defined
dotnet_diagnostic.cs0144.severity = error                                                           # CS0144: Cannot create an instance of the abstract type or interface '{0}'
dotnet_diagnostic.cs0145.severity = error                                                           # CS0145: A const field requires a value to be provided
dotnet_diagnostic.cs0146.severity = error                                                           # CS0146: Circular base type dependency involving '{0}' and '{1}'
dotnet_diagnostic.cs0148.severity = error                                                           # CS0148: The delegate '{0}' does not have a valid constructor
dotnet_diagnostic.cs0149.severity = error                                                           # CS0149: Method name expected
dotnet_diagnostic.cs0150.severity = error                                                           # CS0150: A constant value is expected
dotnet_diagnostic.cs0151.severity = error                                                           # CS0151: A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.
dotnet_diagnostic.cs0152.severity = error                                                           # CS0152: The switch statement contains multiple cases with the label value '{0}'
dotnet_diagnostic.cs0153.severity = error                                                           # CS0153: A goto case is only valid inside a switch statement
dotnet_diagnostic.cs0154.severity = error                                                           # CS0154: The property or indexer '{0}' cannot be used in this context because it lacks the get accessor
dotnet_diagnostic.cs0155.severity = error                                                           # CS0155: The type caught or thrown must be derived from System.Exception
dotnet_diagnostic.cs0156.severity = error                                                           # CS0156: A throw statement with no arguments is not allowed outside of a catch clause
dotnet_diagnostic.cs0157.severity = error                                                           # CS0157: Control cannot leave the body of a finally clause
dotnet_diagnostic.cs0158.severity = error                                                           # CS0158: The label '{0}' shadows another label by the same name in a contained scope
dotnet_diagnostic.cs0159.severity = error                                                           # CS0159: No such label '{0}' within the scope of the goto statement
dotnet_diagnostic.cs0160.severity = error                                                           # CS0160: A previous catch clause already catches all exceptions of this or of a super type ('{0}')
dotnet_diagnostic.cs0161.severity = error                                                           # CS0161: '{0}': not all code paths return a value
dotnet_diagnostic.cs0162.severity = warning                                                         # CS0162: Unreachable code detected
dotnet_diagnostic.cs0163.severity = error                                                           # CS0163: Control cannot fall through from one case label ('{0}') to another
dotnet_diagnostic.cs0164.severity = warning                                                         # CS0164: This label has not been referenced
dotnet_diagnostic.cs0165.severity = error                                                           # CS0165: Use of unassigned local variable '{0}'
dotnet_diagnostic.cs0168.severity = warning                                                         # CS0168: The variable '{0}' is declared but never used
dotnet_diagnostic.cs0169.severity = warning                                                         # CS0169: The field '{0}' is never used
dotnet_diagnostic.cs0170.severity = error                                                           # CS0170: Use of possibly unassigned field '{0}'
dotnet_diagnostic.cs0171.severity = error                                                           # CS0171: Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.
dotnet_diagnostic.cs0172.severity = error                                                           # CS0172: Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another
dotnet_diagnostic.cs0173.severity = error                                                           # CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'
dotnet_diagnostic.cs0174.severity = error                                                           # CS0174: A base class is required for a 'base' reference
dotnet_diagnostic.cs0175.severity = error                                                           # CS0175: Use of keyword 'base' is not valid in this context
dotnet_diagnostic.cs0176.severity = error                                                           # CS0176: Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead
dotnet_diagnostic.cs0177.severity = error                                                           # CS0177: The out parameter '{0}' must be assigned to before control leaves the current method
dotnet_diagnostic.cs0178.severity = error                                                           # CS0178: Invalid rank specifier: expected ',' or ']'
dotnet_diagnostic.cs0179.severity = error                                                           # CS0179: '{0}' cannot be extern and declare a body
dotnet_diagnostic.cs0180.severity = error                                                           # CS0180: '{0}' cannot be both extern and abstract
dotnet_diagnostic.cs0181.severity = error                                                           # CS0181: Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type
dotnet_diagnostic.cs0182.severity = error                                                           # CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type
dotnet_diagnostic.cs0183.severity = warning                                                         # CS0183: The given expression is always of the provided ('{0}') type
dotnet_diagnostic.cs0184.severity = warning                                                         # CS0184: The given expression is never of the provided ('{0}') type
dotnet_diagnostic.cs0185.severity = error                                                           # CS0185: '{0}' is not a reference type as required by the lock statement
dotnet_diagnostic.cs0186.severity = error                                                           # CS0186: Use of null is not valid in this context
dotnet_diagnostic.cs0188.severity = error                                                           # CS0188: The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.
dotnet_diagnostic.cs0190.severity = error                                                           # CS0190: The __arglist construct is valid only within a variable argument method
dotnet_diagnostic.cs0191.severity = error                                                           # CS0191: A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)
dotnet_diagnostic.cs0192.severity = error                                                           # CS0192: A readonly field cannot be used as a ref or out value (except in a constructor)
dotnet_diagnostic.cs0193.severity = error                                                           # CS0193: The * or -> operator must be applied to a pointer
dotnet_diagnostic.cs0196.severity = error                                                           # CS0196: A pointer must be indexed by only one value
dotnet_diagnostic.cs0197.severity = warning                                                         # CS0197: Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class
dotnet_diagnostic.cs0198.severity = error                                                           # CS0198: A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)
dotnet_diagnostic.cs0199.severity = error                                                           # CS0199: A static readonly field cannot be used as a ref or out value (except in a static constructor)
dotnet_diagnostic.cs0200.severity = error                                                           # CS0200: Property or indexer '{0}' cannot be assigned to -- it is read only
dotnet_diagnostic.cs0201.severity = error                                                           # CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
dotnet_diagnostic.cs0202.severity = error                                                           # CS0202: foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property
dotnet_diagnostic.cs0204.severity = error                                                           # CS0204: Only 65534 locals, including those generated by the compiler, are allowed
dotnet_diagnostic.cs0205.severity = error                                                           # CS0205: Cannot call an abstract base member: '{0}'
dotnet_diagnostic.cs0206.severity = error                                                           # CS0206: A non ref-returning property or indexer may not be used as an out or ref value
dotnet_diagnostic.cs0208.severity = error                                                           # CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')
dotnet_diagnostic.cs0209.severity = error                                                           # CS0209: The type of a local declared in a fixed statement must be a pointer type
dotnet_diagnostic.cs0210.severity = error                                                           # CS0210: You must provide an initializer in a fixed or using statement declaration
dotnet_diagnostic.cs0211.severity = error                                                           # CS0211: Cannot take the address of the given expression
dotnet_diagnostic.cs0212.severity = error                                                           # CS0212: You can only take the address of an unfixed expression inside of a fixed statement initializer
dotnet_diagnostic.cs0213.severity = error                                                           # CS0213: You cannot use the fixed statement to take the address of an already fixed expression
dotnet_diagnostic.cs0214.severity = error                                                           # CS0214: Pointers and fixed size buffers may only be used in an unsafe context
dotnet_diagnostic.cs0215.severity = error                                                           # CS0215: The return type of operator True or False must be bool
dotnet_diagnostic.cs0216.severity = error                                                           # CS0216: The operator '{0}' requires a matching operator '{1}' to also be defined
dotnet_diagnostic.cs0217.severity = error                                                           # CS0217: In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types
dotnet_diagnostic.cs0218.severity = error                                                           # CS0218: In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false
dotnet_diagnostic.cs0219.severity = warning                                                         # CS0219: The variable '{0}' is assigned but its value is never used
dotnet_diagnostic.cs0220.severity = error                                                           # CS0220: The operation overflows at compile time in checked mode
dotnet_diagnostic.cs0221.severity = error                                                           # CS0221: Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)
dotnet_diagnostic.cs0224.severity = error                                                           # CS0224: A method with vararg cannot be generic, be in a generic type, or have a params parameter
dotnet_diagnostic.cs0225.severity = error                                                           # CS0225: The params parameter must have a valid collection type
dotnet_diagnostic.cs0226.severity = error                                                           # CS0226: An __arglist expression may only appear inside of a call or new expression
dotnet_diagnostic.cs0227.severity = error                                                           # CS0227: Unsafe code may only appear if compiling with /unsafe
dotnet_diagnostic.cs0229.severity = error                                                           # CS0229: Ambiguity between '{0}' and '{1}'
dotnet_diagnostic.cs0230.severity = error                                                           # CS0230: Type and identifier are both required in a foreach statement
dotnet_diagnostic.cs0231.severity = error                                                           # CS0231: A params parameter must be the last parameter in a parameter list
dotnet_diagnostic.cs0233.severity = error                                                           # CS0233: '{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context
dotnet_diagnostic.cs0234.severity = error                                                           # CS0234: The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)
dotnet_diagnostic.cs0236.severity = error                                                           # CS0236: A field initializer cannot reference the non-static field, method, or property '{0}'
dotnet_diagnostic.cs0238.severity = error                                                           # CS0238: '{0}' cannot be sealed because it is not an override
dotnet_diagnostic.cs0239.severity = error                                                           # CS0239: '{0}': cannot override inherited member '{1}' because it is sealed
dotnet_diagnostic.cs0242.severity = error                                                           # CS0242: The operation in question is undefined on void pointers
dotnet_diagnostic.cs0243.severity = error                                                           # CS0243: The Conditional attribute is not valid on '{0}' because it is an override method
dotnet_diagnostic.cs0244.severity = error                                                           # CS0244: Neither 'is' nor 'as' is valid on pointer types
dotnet_diagnostic.cs0245.severity = error                                                           # CS0245: Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.
dotnet_diagnostic.cs0246.severity = error                                                           # CS0246: The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)
dotnet_diagnostic.cs0247.severity = error                                                           # CS0247: Cannot use a negative size with stackalloc
dotnet_diagnostic.cs0248.severity = error                                                           # CS0248: Cannot create an array with a negative size
dotnet_diagnostic.cs0249.severity = error                                                           # CS0249: Do not override object.Finalize. Instead, provide a destructor.
dotnet_diagnostic.cs0250.severity = error                                                           # CS0250: Do not directly call your base type Finalize method. It is called automatically from your destructor.
dotnet_diagnostic.cs0251.severity = warning                                                         # CS0251: Indexing an array with a negative index (array indices always start at zero)
dotnet_diagnostic.cs0252.severity = warning                                                         # CS0252: Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'
dotnet_diagnostic.cs0253.severity = warning                                                         # CS0253: Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'
dotnet_diagnostic.cs0254.severity = error                                                           # CS0254: The right hand side of a fixed statement assignment may not be a cast expression
dotnet_diagnostic.cs0255.severity = error                                                           # CS0255: stackalloc may not be used in a catch or finally block
dotnet_diagnostic.cs0257.severity = error                                                           # CS0257: An __arglist parameter must be the last parameter in a parameter list
dotnet_diagnostic.cs0260.severity = error                                                           # CS0260: Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists
dotnet_diagnostic.cs0261.severity = error                                                           # CS0261: Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces
dotnet_diagnostic.cs0262.severity = error                                                           # CS0262: Partial declarations of '{0}' have conflicting accessibility modifiers
dotnet_diagnostic.cs0263.severity = error                                                           # CS0263: Partial declarations of '{0}' must not specify different base classes
dotnet_diagnostic.cs0264.severity = error                                                           # CS0264: Partial declarations of '{0}' must have the same type parameter names in the same order
dotnet_diagnostic.cs0265.severity = error                                                           # CS0265: Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'
dotnet_diagnostic.cs0266.severity = error                                                           # CS0266: Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)
dotnet_diagnostic.cs0267.severity = error                                                           # CS0267: The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', 'event', an instance constructor name, or a method or property return type.
dotnet_diagnostic.cs0268.severity = error                                                           # CS0268: Imported type '{0}' is invalid. It contains a circular base type dependency.
dotnet_diagnostic.cs0269.severity = error                                                           # CS0269: Use of unassigned out parameter '{0}'
dotnet_diagnostic.cs0270.severity = error                                                           # CS0270: Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)
dotnet_diagnostic.cs0271.severity = error                                                           # CS0271: The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible
dotnet_diagnostic.cs0272.severity = error                                                           # CS0272: The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible
dotnet_diagnostic.cs0273.severity = error                                                           # CS0273: The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'
dotnet_diagnostic.cs0274.severity = error                                                           # CS0274: Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'
dotnet_diagnostic.cs0276.severity = error                                                           # CS0276: '{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor
dotnet_diagnostic.cs0277.severity = error                                                           # CS0277: '{0}' does not implement interface member '{1}'. '{2}' is not public.
dotnet_diagnostic.cs0278.severity = warning                                                         # CS0278: '{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.
dotnet_diagnostic.cs0279.severity = warning                                                         # CS0279: '{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.
dotnet_diagnostic.cs0280.severity = warning                                                         # CS0280: '{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.
dotnet_diagnostic.cs0281.severity = error                                                           # CS0281: Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.
dotnet_diagnostic.cs0282.severity = warning                                                         # CS0282: There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.
dotnet_diagnostic.cs0283.severity = error                                                           # CS0283: The type '{0}' cannot be declared const
dotnet_diagnostic.cs0304.severity = error                                                           # CS0304: Cannot create an instance of the variable type '{0}' because it does not have the new() constraint
dotnet_diagnostic.cs0305.severity = error                                                           # CS0305: Using the generic {1} '{0}' requires {2} type arguments
dotnet_diagnostic.cs0306.severity = error                                                           # CS0306: The type '{0}' may not be used as a type argument
dotnet_diagnostic.cs0307.severity = error                                                           # CS0307: The {1} '{0}' cannot be used with type arguments
dotnet_diagnostic.cs0308.severity = error                                                           # CS0308: The non-generic {1} '{0}' cannot be used with type arguments
dotnet_diagnostic.cs0310.severity = error                                                           # CS0310: '{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'
dotnet_diagnostic.cs0311.severity = error                                                           # CS0311: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.
dotnet_diagnostic.cs0312.severity = error                                                           # CS0312: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.
dotnet_diagnostic.cs0313.severity = error                                                           # CS0313: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.
dotnet_diagnostic.cs0314.severity = error                                                           # CS0314: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.
dotnet_diagnostic.cs0315.severity = error                                                           # CS0315: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.
dotnet_diagnostic.cs0316.severity = error                                                           # CS0316: The parameter name '{0}' conflicts with an automatically-generated parameter name
dotnet_diagnostic.cs0400.severity = error                                                           # CS0400: The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)
dotnet_diagnostic.cs0401.severity = error                                                           # CS0401: The new() constraint must be the last restrictive constraint specified
dotnet_diagnostic.cs0402.severity = warning                                                         # CS0402: '{0}': an entry point cannot be generic or in a generic type
dotnet_diagnostic.cs0403.severity = error                                                           # CS0403: Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.
dotnet_diagnostic.cs0405.severity = error                                                           # CS0405: Duplicate constraint '{0}' for type parameter '{1}'
dotnet_diagnostic.cs0406.severity = error                                                           # CS0406: The class type constraint '{0}' must come before any other constraints
dotnet_diagnostic.cs0407.severity = error                                                           # CS0407: '{1} {0}' has the wrong return type
dotnet_diagnostic.cs0409.severity = error                                                           # CS0409: A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.
dotnet_diagnostic.cs0411.severity = error                                                           # CS0411: The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.
dotnet_diagnostic.cs0412.severity = error                                                           # CS0412: '{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter
dotnet_diagnostic.cs0413.severity = error                                                           # CS0413: The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint
dotnet_diagnostic.cs0414.severity = warning                                                         # CS0414: The field '{0}' is assigned but its value is never used
dotnet_diagnostic.cs0415.severity = error                                                           # CS0415: The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration
dotnet_diagnostic.cs0416.severity = error                                                           # CS0416: '{0}': an attribute argument cannot use type parameters
dotnet_diagnostic.cs0417.severity = error                                                           # CS0417: '{0}': cannot provide arguments when creating an instance of a variable type
dotnet_diagnostic.cs0418.severity = error                                                           # CS0418: '{0}': an abstract type cannot be sealed or static
dotnet_diagnostic.cs0419.severity = warning                                                         # CS0419: Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.
dotnet_diagnostic.cs0420.severity = warning                                                         # CS0420: '{0}': a reference to a volatile field will not be treated as volatile
dotnet_diagnostic.cs0423.severity = error                                                           # CS0423: Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract
dotnet_diagnostic.cs0424.severity = error                                                           # CS0424: '{0}': a class with the ComImport attribute cannot specify a base class
dotnet_diagnostic.cs0425.severity = error                                                           # CS0425: The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.
dotnet_diagnostic.cs0426.severity = error                                                           # CS0426: The type name '{0}' does not exist in the type '{1}'
dotnet_diagnostic.cs0428.severity = error                                                           # CS0428: Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?
dotnet_diagnostic.cs0430.severity = error                                                           # CS0430: The extern alias '{0}' was not specified in a /reference option
dotnet_diagnostic.cs0431.severity = error                                                           # CS0431: Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.
dotnet_diagnostic.cs0432.severity = error                                                           # CS0432: Alias '{0}' not found
dotnet_diagnostic.cs0433.severity = error                                                           # CS0433: The type '{1}' exists in both '{0}' and '{2}'
dotnet_diagnostic.cs0434.severity = error                                                           # CS0434: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'
dotnet_diagnostic.cs0435.severity = warning                                                         # CS0435: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.
dotnet_diagnostic.cs0436.severity = warning                                                         # CS0436: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.
dotnet_diagnostic.cs0437.severity = warning                                                         # CS0437: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.
dotnet_diagnostic.cs0438.severity = error                                                           # CS0438: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'
dotnet_diagnostic.cs0439.severity = error                                                           # CS0439: An extern alias declaration must precede all other elements defined in the namespace
dotnet_diagnostic.cs0440.severity = warning                                                         # CS0440: Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias
dotnet_diagnostic.cs0441.severity = error                                                           # CS0441: '{0}': a type cannot be both static and sealed
dotnet_diagnostic.cs0442.severity = error                                                           # CS0442: '{0}': abstract properties cannot have private accessors
dotnet_diagnostic.cs0443.severity = error                                                           # CS0443: Syntax error; value expected
dotnet_diagnostic.cs0445.severity = error                                                           # CS0445: Cannot modify the result of an unboxing conversion
dotnet_diagnostic.cs0446.severity = error                                                           # CS0446: Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?
dotnet_diagnostic.cs0448.severity = error                                                           # CS0448: The return type for ++ or -- operator must match the parameter type or be derived from the parameter type
dotnet_diagnostic.cs0449.severity = error                                                           # CS0449: The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.
dotnet_diagnostic.cs0450.severity = error                                                           # CS0450: '{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint
dotnet_diagnostic.cs0451.severity = error                                                           # CS0451: The 'new()' constraint cannot be used with the 'struct' constraint
dotnet_diagnostic.cs0452.severity = error                                                           # CS0452: The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'
dotnet_diagnostic.cs0453.severity = error                                                           # CS0453: The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'
dotnet_diagnostic.cs0454.severity = error                                                           # CS0454: Circular constraint dependency involving '{0}' and '{1}'
dotnet_diagnostic.cs0455.severity = error                                                           # CS0455: Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'
dotnet_diagnostic.cs0456.severity = error                                                           # CS0456: Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'
dotnet_diagnostic.cs0457.severity = error                                                           # CS0457: Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'
dotnet_diagnostic.cs0458.severity = warning                                                         # CS0458: The result of the expression is always 'null' of type '{0}'
dotnet_diagnostic.cs0460.severity = error                                                           # CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.
dotnet_diagnostic.cs0462.severity = error                                                           # CS0462: The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden
dotnet_diagnostic.cs0463.severity = error                                                           # CS0463: Evaluation of the decimal constant expression failed
dotnet_diagnostic.cs0464.severity = warning                                                         # CS0464: Comparing with null of type '{0}' always produces 'false'
dotnet_diagnostic.cs0465.severity = warning                                                         # CS0465: Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
dotnet_diagnostic.cs0466.severity = error                                                           # CS0466: '{0}' should not have a params parameter since '{1}' does not
dotnet_diagnostic.cs0469.severity = warning                                                         # CS0469: The 'goto case' value is not implicitly convertible to type '{0}'
dotnet_diagnostic.cs0470.severity = error                                                           # CS0470: Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.
dotnet_diagnostic.cs0472.severity = warning                                                         # CS0472: The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'
dotnet_diagnostic.cs0473.severity = warning                                                         # CS0473: Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.
dotnet_diagnostic.cs0500.severity = error                                                           # CS0500: '{0}' cannot declare a body because it is marked abstract
dotnet_diagnostic.cs0501.severity = error                                                           # CS0501: '{0}' must declare a body because it is not marked abstract, extern, or partial
dotnet_diagnostic.cs0502.severity = error                                                           # CS0502: '{0}' cannot be both abstract and sealed
dotnet_diagnostic.cs0503.severity = error                                                           # CS0503: The abstract {0} '{1}' cannot be marked virtual
dotnet_diagnostic.cs0504.severity = error                                                           # CS0504: The constant '{0}' cannot be marked static
dotnet_diagnostic.cs0505.severity = error                                                           # CS0505: '{0}': cannot override because '{1}' is not a function
dotnet_diagnostic.cs0506.severity = error                                                           # CS0506: '{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override
dotnet_diagnostic.cs0507.severity = error                                                           # CS0507: '{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'
dotnet_diagnostic.cs0508.severity = error                                                           # CS0508: '{0}': return type must be '{2}' to match overridden member '{1}'
dotnet_diagnostic.cs0509.severity = error                                                           # CS0509: '{0}': cannot derive from sealed type '{1}'
dotnet_diagnostic.cs0513.severity = error                                                           # CS0513: '{0}' is abstract but it is contained in non-abstract type '{1}'
dotnet_diagnostic.cs0514.severity = error                                                           # CS0514: '{0}': static constructor cannot have an explicit 'this' or 'base' constructor call
dotnet_diagnostic.cs0515.severity = error                                                           # CS0515: '{0}': access modifiers are not allowed on static constructors
dotnet_diagnostic.cs0516.severity = error                                                           # CS0516: Constructor '{0}' cannot call itself
dotnet_diagnostic.cs0517.severity = error                                                           # CS0517: '{0}' has no base class and cannot call a base constructor
dotnet_diagnostic.cs0518.severity = error                                                           # CS0518: Predefined type '{0}' is not defined or imported
dotnet_diagnostic.cs0522.severity = error                                                           # CS0522: '{0}': structs cannot call base class constructors
dotnet_diagnostic.cs0523.severity = error                                                           # CS0523: Struct member '{0}' of type '{1}' causes a cycle in the struct layout
dotnet_diagnostic.cs0525.severity = error                                                           # CS0525: Interfaces cannot contain instance fields
dotnet_diagnostic.cs0526.severity = error                                                           # CS0526: Interfaces cannot contain instance constructors
dotnet_diagnostic.cs0527.severity = error                                                           # CS0527: Type '{0}' in interface list is not an interface
dotnet_diagnostic.cs0528.severity = error                                                           # CS0528: '{0}' is already listed in interface list
dotnet_diagnostic.cs0529.severity = error                                                           # CS0529: Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'
dotnet_diagnostic.cs0533.severity = error                                                           # CS0533: '{0}' hides inherited abstract member '{1}'
dotnet_diagnostic.cs0534.severity = error                                                           # CS0534: '{0}' does not implement inherited abstract member '{1}'
dotnet_diagnostic.cs0535.severity = error                                                           # CS0535: '{0}' does not implement interface member '{1}'
dotnet_diagnostic.cs0537.severity = error                                                           # CS0537: The class System.Object cannot have a base class or implement an interface
dotnet_diagnostic.cs0538.severity = error                                                           # CS0538: '{0}' in explicit interface declaration is not an interface
dotnet_diagnostic.cs0539.severity = error                                                           # CS0539: '{0}' in explicit interface declaration is not found among members of the interface that can be implemented
dotnet_diagnostic.cs0540.severity = error                                                           # CS0540: '{0}': containing type does not implement interface '{1}'
dotnet_diagnostic.cs0541.severity = error                                                           # CS0541: '{0}': explicit interface declaration can only be declared in a class, record, struct or interface
dotnet_diagnostic.cs0542.severity = error                                                           # CS0542: '{0}': member names cannot be the same as their enclosing type
dotnet_diagnostic.cs0543.severity = error                                                           # CS0543: '{0}': the enumerator value is too large to fit in its type
dotnet_diagnostic.cs0544.severity = error                                                           # CS0544: '{0}': cannot override because '{1}' is not a property
dotnet_diagnostic.cs0545.severity = error                                                           # CS0545: '{0}': cannot override because '{1}' does not have an overridable get accessor
dotnet_diagnostic.cs0546.severity = error                                                           # CS0546: '{0}': cannot override because '{1}' does not have an overridable set accessor
dotnet_diagnostic.cs0547.severity = error                                                           # CS0547: '{0}': property or indexer cannot have void type
dotnet_diagnostic.cs0548.severity = error                                                           # CS0548: '{0}': property or indexer must have at least one accessor
dotnet_diagnostic.cs0549.severity = error                                                           # CS0549: '{0}' is a new virtual member in sealed type '{1}'
dotnet_diagnostic.cs0550.severity = error                                                           # CS0550: '{0}' adds an accessor not found in interface member '{1}'
dotnet_diagnostic.cs0551.severity = error                                                           # CS0551: Explicit interface implementation '{0}' is missing accessor '{1}'
dotnet_diagnostic.cs0552.severity = error                                                           # CS0552: '{0}': user-defined conversions to or from an interface are not allowed
dotnet_diagnostic.cs0553.severity = error                                                           # CS0553: '{0}': user-defined conversions to or from a base type are not allowed
dotnet_diagnostic.cs0554.severity = error                                                           # CS0554: '{0}': user-defined conversions to or from a derived type are not allowed
dotnet_diagnostic.cs0555.severity = error                                                           # CS0555: User-defined operator cannot convert a type to itself
dotnet_diagnostic.cs0556.severity = error                                                           # CS0556: User-defined conversion must convert to or from the enclosing type
dotnet_diagnostic.cs0557.severity = error                                                           # CS0557: Duplicate user-defined conversion in type '{0}'
dotnet_diagnostic.cs0558.severity = error                                                           # CS0558: User-defined operator '{0}' must be declared static and public
dotnet_diagnostic.cs0559.severity = error                                                           # CS0559: The parameter type for ++ or -- operator must be the containing type
dotnet_diagnostic.cs0562.severity = error                                                           # CS0562: The parameter of a unary operator must be the containing type
dotnet_diagnostic.cs0563.severity = error                                                           # CS0563: One of the parameters of a binary operator must be the containing type
dotnet_diagnostic.cs0564.severity = error                                                           # CS0564: The first operand of an overloaded shift operator must have the same type as the containing type
dotnet_diagnostic.cs0567.severity = error                                                           # CS0567: Conversion, equality, or inequality operators declared in interfaces must be abstract or virtual
dotnet_diagnostic.cs0569.severity = error                                                           # CS0569: '{0}': cannot override '{1}' because it is not supported by the language
dotnet_diagnostic.cs0570.severity = error                                                           # CS0570: '{0}' is not supported by the language
dotnet_diagnostic.cs0571.severity = error                                                           # CS0571: '{0}': cannot explicitly call operator or accessor
dotnet_diagnostic.cs0572.severity = error                                                           # CS0572: '{0}': cannot reference a type through an expression; try '{1}' instead
dotnet_diagnostic.cs0574.severity = error                                                           # CS0574: Name of destructor must match name of type
dotnet_diagnostic.cs0575.severity = error                                                           # CS0575: Only class types can contain destructors
dotnet_diagnostic.cs0576.severity = error                                                           # CS0576: Namespace '{1}' contains a definition conflicting with alias '{0}'
dotnet_diagnostic.cs0577.severity = error                                                           # CS0577: The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation
dotnet_diagnostic.cs0578.severity = error                                                           # CS0578: The Conditional attribute is not valid on '{0}' because its return type is not void
dotnet_diagnostic.cs0579.severity = error                                                           # CS0579: Duplicate '{0}' attribute
dotnet_diagnostic.cs0582.severity = error                                                           # CS0582: The Conditional attribute is not valid on interface members
dotnet_diagnostic.cs0590.severity = error                                                           # CS0590: User-defined operators cannot return void
dotnet_diagnostic.cs0591.severity = error                                                           # CS0591: Invalid value for argument to '{0}' attribute
dotnet_diagnostic.cs0592.severity = error                                                           # CS0592: Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.
dotnet_diagnostic.cs0594.severity = error                                                           # CS0594: Floating-point constant is outside the range of type '{0}'
dotnet_diagnostic.cs0595.severity = error                                                           # CS0595: Invalid real literal.
dotnet_diagnostic.cs0596.severity = error                                                           # CS0596: The Guid attribute must be specified with the ComImport attribute
dotnet_diagnostic.cs0599.severity = error                                                           # CS0599: Invalid value for named attribute argument '{0}'
dotnet_diagnostic.cs0601.severity = error                                                           # CS0601: The DllImport attribute must be specified on a method marked 'extern' that is either 'static' or an extension member
dotnet_diagnostic.cs0610.severity = error                                                           # CS0610: Field or property cannot be of type '{0}'
dotnet_diagnostic.cs0611.severity = error                                                           # CS0611: Array elements cannot be of type '{0}'
dotnet_diagnostic.cs0612.severity = warning                                                         # CS0612: '{0}' is obsolete
dotnet_diagnostic.cs0616.severity = error                                                           # CS0616: '{0}' is not an attribute class
dotnet_diagnostic.cs0617.severity = error                                                           # CS0617: '{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.
dotnet_diagnostic.cs0618.severity = warning                                                         # CS0618: '{0}' is obsolete: '{1}'
dotnet_diagnostic.cs0619.severity = error                                                           # CS0619: '{0}' is obsolete: '{1}'
dotnet_diagnostic.cs0620.severity = error                                                           # CS0620: Indexers cannot have void type
dotnet_diagnostic.cs0621.severity = error                                                           # CS0621: '{0}': virtual or abstract members cannot be private
dotnet_diagnostic.cs0622.severity = error                                                           # CS0622: Can only use array initializer expressions to assign to array types. Try using a new expression instead.
dotnet_diagnostic.cs0623.severity = error                                                           # CS0623: Array initializers can only be used in a variable or field initializer. Try using a new expression instead.
dotnet_diagnostic.cs0625.severity = error                                                           # CS0625: '{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute
dotnet_diagnostic.cs0626.severity = warning                                                         # CS0626: Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.
dotnet_diagnostic.cs0628.severity = warning                                                         # CS0628: '{0}': new protected member declared in sealed type
dotnet_diagnostic.cs0629.severity = error                                                           # CS0629: Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'
dotnet_diagnostic.cs0630.severity = error                                                           # CS0630: '{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter
dotnet_diagnostic.cs0631.severity = error                                                           # CS0631: ref and out are not valid in this context
dotnet_diagnostic.cs0633.severity = error                                                           # CS0633: The argument to the '{0}' attribute must be a valid identifier
dotnet_diagnostic.cs0636.severity = error                                                           # CS0636: The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
dotnet_diagnostic.cs0637.severity = error                                                           # CS0637: The FieldOffset attribute is not allowed on static or const fields
dotnet_diagnostic.cs0641.severity = error                                                           # CS0641: Attribute '{0}' is only valid on classes derived from System.Attribute
dotnet_diagnostic.cs0642.severity = warning                                                         # CS0642: Possible mistaken empty statement
dotnet_diagnostic.cs0643.severity = error                                                           # CS0643: '{0}' duplicate named attribute argument
dotnet_diagnostic.cs0644.severity = error                                                           # CS0644: '{0}' cannot derive from special class '{1}'
dotnet_diagnostic.cs0646.severity = error                                                           # CS0646: Cannot specify the DefaultMember attribute on a type containing an indexer
dotnet_diagnostic.cs0648.severity = error                                                           # CS0648: '{0}' is a type not supported by the language
dotnet_diagnostic.cs0649.severity = warning                                                         # CS0649: Field '{0}' is never assigned to, and will always have its default value {1}
dotnet_diagnostic.cs0650.severity = error                                                           # CS0650: Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.
dotnet_diagnostic.cs0652.severity = warning                                                         # CS0652: Comparison to integral constant is useless; the constant is outside the range of type '{0}'
dotnet_diagnostic.cs0653.severity = error                                                           # CS0653: Cannot apply attribute class '{0}' because it is abstract
dotnet_diagnostic.cs0655.severity = error                                                           # CS0655: '{0}' is not a valid named attribute argument because it is not a valid attribute parameter type
dotnet_diagnostic.cs0656.severity = error                                                           # CS0656: Missing compiler required member '{0}.{1}'
dotnet_diagnostic.cs0657.severity = warning                                                         # CS0657: '{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.
dotnet_diagnostic.cs0658.severity = warning                                                         # CS0658: '{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.
dotnet_diagnostic.cs0659.severity = warning                                                         # CS0659: '{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()
dotnet_diagnostic.cs0660.severity = warning                                                         # CS0660: '{0}' defines operator == or operator != but does not override Object.Equals(object o)
dotnet_diagnostic.cs0661.severity = warning                                                         # CS0661: '{0}' defines operator == or operator != but does not override Object.GetHashCode()
dotnet_diagnostic.cs0662.severity = error                                                           # CS0662: Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.
dotnet_diagnostic.cs0663.severity = error                                                           # CS0663: '{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'
dotnet_diagnostic.cs0664.severity = error                                                           # CS0664: Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type
dotnet_diagnostic.cs0665.severity = warning                                                         # CS0665: Assignment in conditional expression is always constant; did you mean to use == instead of = ?
dotnet_diagnostic.cs0666.severity = error                                                           # CS0666: '{0}': new protected member declared in struct
dotnet_diagnostic.cs0668.severity = error                                                           # CS0668: Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type
dotnet_diagnostic.cs0669.severity = error                                                           # CS0669: A class with the ComImport attribute cannot have a user-defined constructor
dotnet_diagnostic.cs0670.severity = error                                                           # CS0670: Field cannot have void type
dotnet_diagnostic.cs0672.severity = warning                                                         # CS0672: Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.
dotnet_diagnostic.cs0673.severity = error                                                           # CS0673: System.Void cannot be used from C# -- use typeof(void) to get the void type object
dotnet_diagnostic.cs0674.severity = error                                                           # CS0674: Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.
dotnet_diagnostic.cs0675.severity = warning                                                         # CS0675: Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first
dotnet_diagnostic.cs0677.severity = error                                                           # CS0677: '{0}': a volatile field cannot be of the type '{1}'
dotnet_diagnostic.cs0678.severity = error                                                           # CS0678: '{0}': a field cannot be both volatile and readonly
dotnet_diagnostic.cs0681.severity = error                                                           # CS0681: The modifier 'abstract' is not valid on fields. Try using a property instead.
dotnet_diagnostic.cs0682.severity = error                                                           # CS0682: '{0}' cannot implement '{1}' because it is not supported by the language
dotnet_diagnostic.cs0683.severity = error                                                           # CS0683: '{0}' explicit method implementation cannot implement '{1}' because it is an accessor
dotnet_diagnostic.cs0684.severity = warning                                                         # CS0684: '{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'
dotnet_diagnostic.cs0685.severity = error                                                           # CS0685: Conditional member '{0}' cannot have an out parameter
dotnet_diagnostic.cs0686.severity = error                                                           # CS0686: Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.
dotnet_diagnostic.cs0687.severity = error                                                           # CS0687: The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.
dotnet_diagnostic.cs0689.severity = error                                                           # CS0689: Cannot derive from '{0}' because it is a type parameter
dotnet_diagnostic.cs0692.severity = error                                                           # CS0692: Duplicate type parameter '{0}'
dotnet_diagnostic.cs0693.severity = warning                                                         # CS0693: Type parameter '{0}' has the same name as the type parameter from outer type '{1}'
dotnet_diagnostic.cs0694.severity = error                                                           # CS0694: Type parameter '{0}' has the same name as the containing type, or method
dotnet_diagnostic.cs0695.severity = error                                                           # CS0695: '{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions
dotnet_diagnostic.cs0699.severity = error                                                           # CS0699: '{1}' does not define type parameter '{0}'
dotnet_diagnostic.cs0701.severity = error                                                           # CS0701: '{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
dotnet_diagnostic.cs0702.severity = error                                                           # CS0702: Constraint cannot be special class '{0}'
dotnet_diagnostic.cs0703.severity = error                                                           # CS0703: Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'
dotnet_diagnostic.cs0704.severity = error                                                           # CS0704: Cannot do non-virtual member lookup in '{0}' because it is a type parameter
dotnet_diagnostic.cs0706.severity = error                                                           # CS0706: Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
dotnet_diagnostic.cs0708.severity = error                                                           # CS0708: '{0}': cannot declare instance members in a static class
dotnet_diagnostic.cs0709.severity = error                                                           # CS0709: '{1}': cannot derive from static class '{0}'
dotnet_diagnostic.cs0710.severity = error                                                           # CS0710: Static classes cannot have instance constructors
dotnet_diagnostic.cs0711.severity = error                                                           # CS0711: Static classes cannot contain destructors
dotnet_diagnostic.cs0712.severity = error                                                           # CS0712: Cannot create an instance of the static class '{0}'
dotnet_diagnostic.cs0713.severity = error                                                           # CS0713: Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.
dotnet_diagnostic.cs0714.severity = error                                                           # CS0714: '{0}': static classes cannot implement interfaces
dotnet_diagnostic.cs0715.severity = error                                                           # CS0715: '{0}': static classes cannot contain user-defined operators
dotnet_diagnostic.cs0716.severity = error                                                           # CS0716: Cannot convert to static type '{0}'
dotnet_diagnostic.cs0717.severity = error                                                           # CS0717: '{0}': static classes cannot be used as constraints
dotnet_diagnostic.cs0718.severity = error                                                           # CS0718: '{0}': static types cannot be used as type arguments
dotnet_diagnostic.cs0719.severity = error                                                           # CS0719: '{0}': array elements cannot be of static type
dotnet_diagnostic.cs0720.severity = error                                                           # CS0720: '{0}': cannot declare indexers in a static class
dotnet_diagnostic.cs0721.severity = error                                                           # CS0721: '{0}': static types cannot be used as parameters
dotnet_diagnostic.cs0722.severity = error                                                           # CS0722: '{0}': static types cannot be used as return types
dotnet_diagnostic.cs0723.severity = error                                                           # CS0723: Cannot declare a variable of static type '{0}'
dotnet_diagnostic.cs0724.severity = error                                                           # CS0724: A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause
dotnet_diagnostic.cs0726.severity = error                                                           # CS0726: '{0}' is not a valid format specifier
dotnet_diagnostic.cs0728.severity = warning                                                         # CS0728: Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.
dotnet_diagnostic.cs0729.severity = error                                                           # CS0729: Type '{0}' is defined in this assembly, but a type forwarder is specified for it
dotnet_diagnostic.cs0730.severity = error                                                           # CS0730: Cannot forward type '{0}' because it is a nested type of '{1}'
dotnet_diagnostic.cs0731.severity = error                                                           # CS0731: The type forwarder for type '{0}' in assembly '{1}' causes a cycle
dotnet_diagnostic.cs0734.severity = error                                                           # CS0734: The /moduleassemblyname option may only be specified when building a target type of 'module'
dotnet_diagnostic.cs0735.severity = error                                                           # CS0735: Invalid type specified as an argument for TypeForwardedTo attribute
dotnet_diagnostic.cs0736.severity = error                                                           # CS0736: '{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.
dotnet_diagnostic.cs0737.severity = error                                                           # CS0737: '{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.
dotnet_diagnostic.cs0738.severity = error                                                           # CS0738: '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.
dotnet_diagnostic.cs0739.severity = error                                                           # CS0739: '{0}' duplicate TypeForwardedToAttribute
dotnet_diagnostic.cs0742.severity = error                                                           # CS0742: A query body must end with a select clause or a group clause
dotnet_diagnostic.cs0743.severity = error                                                           # CS0743: Expected contextual keyword 'on'
dotnet_diagnostic.cs0744.severity = error                                                           # CS0744: Expected contextual keyword 'equals'
dotnet_diagnostic.cs0745.severity = error                                                           # CS0745: Expected contextual keyword 'by'
dotnet_diagnostic.cs0746.severity = error                                                           # CS0746: Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.
dotnet_diagnostic.cs0747.severity = error                                                           # CS0747: Invalid initializer member declarator
dotnet_diagnostic.cs0748.severity = error                                                           # CS0748: Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit
dotnet_diagnostic.cs0750.severity = error                                                           # CS0750: A partial member cannot have the 'abstract' modifier
dotnet_diagnostic.cs0751.severity = error                                                           # CS0751: A partial member must be declared within a partial type
dotnet_diagnostic.cs0754.severity = error                                                           # CS0754: A partial member may not explicitly implement an interface member
dotnet_diagnostic.cs0755.severity = error                                                           # CS0755: Both partial method declarations must be extension methods or neither may be an extension method
dotnet_diagnostic.cs0756.severity = error                                                           # CS0756: A partial method may not have multiple defining declarations
dotnet_diagnostic.cs0757.severity = error                                                           # CS0757: A partial method may not have multiple implementing declarations
dotnet_diagnostic.cs0758.severity = error                                                           # CS0758: Both partial member declarations must use a params parameter or neither may use a params parameter
dotnet_diagnostic.cs0759.severity = error                                                           # CS0759: No defining declaration found for implementing declaration of partial method '{0}'
dotnet_diagnostic.cs0761.severity = error                                                           # CS0761: Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'
dotnet_diagnostic.cs0762.severity = error                                                           # CS0762: Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration
dotnet_diagnostic.cs0763.severity = error                                                           # CS0763: Both partial member declarations must be static or neither may be static
dotnet_diagnostic.cs0764.severity = error                                                           # CS0764: Both partial member declarations must be unsafe or neither may be unsafe
dotnet_diagnostic.cs0765.severity = error                                                           # CS0765: Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees
dotnet_diagnostic.cs0767.severity = error                                                           # CS0767: Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out
dotnet_diagnostic.cs0768.severity = error                                                           # CS0768: Constructor '{0}' cannot call itself through another constructor
dotnet_diagnostic.cs0809.severity = warning                                                         # CS0809: Obsolete member '{0}' overrides non-obsolete member '{1}'
dotnet_diagnostic.cs0811.severity = warning                                                         # CS0811: The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.
dotnet_diagnostic.cs0815.severity = error                                                           # CS0815: Cannot assign {0} to an implicitly-typed variable
dotnet_diagnostic.cs0818.severity = error                                                           # CS0818: Implicitly-typed variables must be initialized
dotnet_diagnostic.cs0819.severity = error                                                           # CS0819: Implicitly-typed variables cannot have multiple declarators
dotnet_diagnostic.cs0820.severity = error                                                           # CS0820: Cannot initialize an implicitly-typed variable with an array initializer
dotnet_diagnostic.cs0821.severity = error                                                           # CS0821: Implicitly-typed local variables cannot be fixed
dotnet_diagnostic.cs0822.severity = error                                                           # CS0822: Implicitly-typed variables cannot be constant
dotnet_diagnostic.cs0824.severity = warning                                                         # CS0824: Constructor '{0}' is marked external
dotnet_diagnostic.cs0825.severity = error                                                           # CS0825: The contextual keyword 'var' may only appear within a local variable declaration or in script code
dotnet_diagnostic.cs0826.severity = error                                                           # CS0826: No best type found for implicitly-typed array
dotnet_diagnostic.cs0828.severity = error                                                           # CS0828: Cannot assign '{0}' to anonymous type property
dotnet_diagnostic.cs0831.severity = error                                                           # CS0831: An expression tree may not contain a base access
dotnet_diagnostic.cs0832.severity = error                                                           # CS0832: An expression tree may not contain an assignment operator
dotnet_diagnostic.cs0833.severity = error                                                           # CS0833: An anonymous type cannot have multiple properties with the same name
dotnet_diagnostic.cs0834.severity = error                                                           # CS0834: A lambda expression with a statement body cannot be converted to an expression tree
dotnet_diagnostic.cs0835.severity = error                                                           # CS0835: Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type
dotnet_diagnostic.cs0836.severity = error                                                           # CS0836: Cannot use anonymous type in a constant expression
dotnet_diagnostic.cs0837.severity = error                                                           # CS0837: The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.
dotnet_diagnostic.cs0838.severity = error                                                           # CS0838: An expression tree may not contain a multidimensional array initializer
dotnet_diagnostic.cs0839.severity = error                                                           # CS0839: Argument missing
dotnet_diagnostic.cs0841.severity = error                                                           # CS0841: Cannot use local variable '{0}' before it is declared
dotnet_diagnostic.cs0843.severity = error                                                           # CS0843: Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.
dotnet_diagnostic.cs0844.severity = error                                                           # CS0844: Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.
dotnet_diagnostic.cs0845.severity = error                                                           # CS0845: An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side
dotnet_diagnostic.cs0846.severity = error                                                           # CS0846: A nested array initializer is expected
dotnet_diagnostic.cs0847.severity = error                                                           # CS0847: An array initializer of length '{0}' is expected
dotnet_diagnostic.cs0853.severity = error                                                           # CS0853: An expression tree may not contain a named argument specification
dotnet_diagnostic.cs0854.severity = error                                                           # CS0854: An expression tree may not contain a call or invocation that uses optional arguments
dotnet_diagnostic.cs0855.severity = error                                                           # CS0855: An expression tree may not contain an indexed property
dotnet_diagnostic.cs0856.severity = error                                                           # CS0856: Indexed property '{0}' has non-optional arguments which must be provided
dotnet_diagnostic.cs0857.severity = error                                                           # CS0857: Indexed property '{0}' must have all arguments optional
dotnet_diagnostic.cs1001.severity = error                                                           # CS1001: Identifier expected
dotnet_diagnostic.cs1002.severity = error                                                           # CS1002: ; expected
dotnet_diagnostic.cs1003.severity = error                                                           # CS1003: Syntax error, '{0}' expected
dotnet_diagnostic.cs1004.severity = error                                                           # CS1004: Duplicate '{0}' modifier
dotnet_diagnostic.cs1007.severity = error                                                           # CS1007: Property accessor already defined
dotnet_diagnostic.cs1008.severity = error                                                           # CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected
dotnet_diagnostic.cs1009.severity = error                                                           # CS1009: Unrecognized escape sequence
dotnet_diagnostic.cs1010.severity = error                                                           # CS1010: Newline in constant
dotnet_diagnostic.cs1011.severity = error                                                           # CS1011: Empty character literal
dotnet_diagnostic.cs1012.severity = error                                                           # CS1012: Too many characters in character literal
dotnet_diagnostic.cs1013.severity = error                                                           # CS1013: Invalid number
dotnet_diagnostic.cs1014.severity = error                                                           # CS1014: A get or set accessor expected
dotnet_diagnostic.cs1015.severity = error                                                           # CS1015: An object, string, or class type expected
dotnet_diagnostic.cs1016.severity = error                                                           # CS1016: Named attribute argument expected
dotnet_diagnostic.cs1017.severity = error                                                           # CS1017: Catch clauses cannot follow the general catch clause of a try statement
dotnet_diagnostic.cs1018.severity = error                                                           # CS1018: Keyword 'this' or 'base' expected
dotnet_diagnostic.cs1019.severity = error                                                           # CS1019: Overloadable unary operator expected
dotnet_diagnostic.cs1020.severity = error                                                           # CS1020: Overloadable binary operator expected
dotnet_diagnostic.cs1021.severity = error                                                           # CS1021: Integral constant is too large
dotnet_diagnostic.cs1022.severity = error                                                           # CS1022: Type or namespace definition, or end-of-file expected
dotnet_diagnostic.cs1023.severity = error                                                           # CS1023: Embedded statement cannot be a declaration or labeled statement
dotnet_diagnostic.cs1024.severity = error                                                           # CS1024: Preprocessor directive expected
dotnet_diagnostic.cs1025.severity = error                                                           # CS1025: Single-line comment or end-of-line expected
dotnet_diagnostic.cs1026.severity = error                                                           # CS1026: ) expected
dotnet_diagnostic.cs1027.severity = error                                                           # CS1027: #endif directive expected
dotnet_diagnostic.cs1028.severity = error                                                           # CS1028: Unexpected preprocessor directive
dotnet_diagnostic.cs1029.severity = error                                                           # CS1029: #warning: '{0}'
dotnet_diagnostic.cs1030.severity = warning                                                         # CS1030: '#warning' directive
dotnet_diagnostic.cs1031.severity = error                                                           # CS1031: Type expected
dotnet_diagnostic.cs1032.severity = error                                                           # CS1032: Cannot define/undefine preprocessor symbols after first token in file
dotnet_diagnostic.cs1035.severity = error                                                           # CS1035: End-of-file found, '*/' expected
dotnet_diagnostic.cs1037.severity = error                                                           # CS1037: Overloadable operator expected
dotnet_diagnostic.cs1038.severity = error                                                           # CS1038: #endregion directive expected
dotnet_diagnostic.cs1039.severity = error                                                           # CS1039: Unterminated string literal
dotnet_diagnostic.cs1040.severity = error                                                           # CS1040: Preprocessor directives must appear as the first non-whitespace character on a line
dotnet_diagnostic.cs1041.severity = error                                                           # CS1041: Identifier expected; '{1}' is a keyword
dotnet_diagnostic.cs1043.severity = error                                                           # CS1043: { or ; expected
dotnet_diagnostic.cs1044.severity = error                                                           # CS1044: Cannot use more than one type in a for, using, fixed, or declaration statement
dotnet_diagnostic.cs1055.severity = error                                                           # CS1055: An add or remove accessor expected
dotnet_diagnostic.cs1056.severity = error                                                           # CS1056: Unexpected character '{0}'
dotnet_diagnostic.cs1057.severity = error                                                           # CS1057: '{0}': static classes cannot contain protected members
dotnet_diagnostic.cs1058.severity = warning                                                         # CS1058: A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.
dotnet_diagnostic.cs1059.severity = error                                                           # CS1059: The operand of an increment or decrement operator must be a variable, property or indexer
dotnet_diagnostic.cs1061.severity = error                                                           # CS1061: '{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)
dotnet_diagnostic.cs1062.severity = warning                                                         # CS1062: The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}
dotnet_diagnostic.cs1063.severity = error                                                           # CS1063: The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}
dotnet_diagnostic.cs1064.severity = warning                                                         # CS1064: The best overloaded Add method '{0}' for the collection initializer element is obsolete.
dotnet_diagnostic.cs1065.severity = error                                                           # CS1065: Default values are not valid in this context.
dotnet_diagnostic.cs1066.severity = warning                                                         # CS1066: The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
dotnet_diagnostic.cs1067.severity = error                                                           # CS1067: Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order
dotnet_diagnostic.cs1068.severity = error                                                           # CS1068: The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.
dotnet_diagnostic.cs1069.severity = error                                                           # CS1069: The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.
dotnet_diagnostic.cs1070.severity = error                                                           # CS1070: The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.
dotnet_diagnostic.cs1072.severity = warning                                                         # CS1072: Expected identifier or numeric literal.
dotnet_diagnostic.cs1073.severity = error                                                           # CS1073: Unexpected token '{0}'
dotnet_diagnostic.cs1100.severity = error                                                           # CS1100: Method '{0}' has a parameter modifier 'this' which is not on the first parameter
dotnet_diagnostic.cs1103.severity = error                                                           # CS1103: The receiver parameter of an extension cannot be of type '{0}'
dotnet_diagnostic.cs1104.severity = error                                                           # CS1104: A parameter array cannot be used with 'this' modifier on an extension method
dotnet_diagnostic.cs1105.severity = error                                                           # CS1105: Extension method must be static
dotnet_diagnostic.cs1106.severity = error                                                           # CS1106: Extension method must be defined in a non-generic static class
dotnet_diagnostic.cs1107.severity = error                                                           # CS1107: A parameter can only have one '{0}' modifier
dotnet_diagnostic.cs1109.severity = error                                                           # CS1109: Extension methods must be defined in a top level static class; {0} is a nested class
dotnet_diagnostic.cs1110.severity = error                                                           # CS1110: Cannot define a new extension because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?
dotnet_diagnostic.cs1112.severity = error                                                           # CS1112: Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.
dotnet_diagnostic.cs1113.severity = error                                                           # CS1113: Extension method '{0}' defined on value type '{1}' cannot be used to create delegates
dotnet_diagnostic.cs1501.severity = error                                                           # CS1501: No overload for method '{0}' takes {1} arguments
dotnet_diagnostic.cs1503.severity = error                                                           # CS1503: Argument {0}: cannot convert from '{1}' to '{2}'
dotnet_diagnostic.cs1504.severity = error                                                           # CS1504: Source file '{0}' could not be opened -- {1}
dotnet_diagnostic.cs1507.severity = error                                                           # CS1507: Cannot link resource files when building a module
dotnet_diagnostic.cs1508.severity = error                                                           # CS1508: Resource identifier '{0}' has already been used in this assembly
dotnet_diagnostic.cs1509.severity = error                                                           # CS1509: The referenced file '{0}' is not an assembly
dotnet_diagnostic.cs1510.severity = error                                                           # CS1510: A ref or out value must be an assignable variable
dotnet_diagnostic.cs1511.severity = error                                                           # CS1511: Keyword 'base' is not available in a static method
dotnet_diagnostic.cs1512.severity = error                                                           # CS1512: Keyword 'base' is not available in the current context
dotnet_diagnostic.cs1513.severity = error                                                           # CS1513: } expected
dotnet_diagnostic.cs1514.severity = error                                                           # CS1514: { expected
dotnet_diagnostic.cs1515.severity = error                                                           # CS1515: 'in' expected
dotnet_diagnostic.cs1517.severity = error                                                           # CS1517: Invalid preprocessor expression
dotnet_diagnostic.cs1519.severity = error                                                           # CS1519: Invalid token '{0}' in a member declaration
dotnet_diagnostic.cs1520.severity = error                                                           # CS1520: Method must have a return type
dotnet_diagnostic.cs1521.severity = error                                                           # CS1521: Invalid base type
dotnet_diagnostic.cs1522.severity = warning                                                         # CS1522: Empty switch block
dotnet_diagnostic.cs1524.severity = error                                                           # CS1524: Expected catch or finally
dotnet_diagnostic.cs1525.severity = error                                                           # CS1525: Invalid expression term '{0}'
dotnet_diagnostic.cs1526.severity = error                                                           # CS1526: A new expression requires an argument list or (), [], or {} after type
dotnet_diagnostic.cs1527.severity = error                                                           # CS1527: Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected
dotnet_diagnostic.cs1528.severity = error                                                           # CS1528: Expected ; or = (cannot specify constructor arguments in declaration)
dotnet_diagnostic.cs1529.severity = error                                                           # CS1529: A using clause must precede all other elements defined in the namespace except extern alias declarations
dotnet_diagnostic.cs1534.severity = error                                                           # CS1534: Overloaded binary operator '{0}' takes two parameters
dotnet_diagnostic.cs1535.severity = error                                                           # CS1535: Overloaded unary operator '{0}' takes one parameter
dotnet_diagnostic.cs1536.severity = error                                                           # CS1536: Invalid parameter type 'void'
dotnet_diagnostic.cs1537.severity = error                                                           # CS1537: The using alias '{0}' appeared previously in this namespace
dotnet_diagnostic.cs1540.severity = error                                                           # CS1540: Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)
dotnet_diagnostic.cs1542.severity = error                                                           # CS1542: '{0}' cannot be added to this assembly because it already is an assembly
dotnet_diagnostic.cs1545.severity = error                                                           # CS1545: Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'
dotnet_diagnostic.cs1546.severity = error                                                           # CS1546: Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'
dotnet_diagnostic.cs1547.severity = error                                                           # CS1547: Keyword 'void' cannot be used in this context
dotnet_diagnostic.cs1551.severity = error                                                           # CS1551: Indexers must have at least one parameter
dotnet_diagnostic.cs1552.severity = error                                                           # CS1552: Array type specifier, [], must appear before parameter name
dotnet_diagnostic.cs1553.severity = error                                                           # CS1553: Declaration is not valid; use '{0} operator <dest-type> (...' instead
dotnet_diagnostic.cs1555.severity = error                                                           # CS1555: Could not find '{0}' specified for Main method
dotnet_diagnostic.cs1556.severity = error                                                           # CS1556: '{0}' specified for Main method must be a non-generic class, record, struct, or interface
dotnet_diagnostic.cs1558.severity = error                                                           # CS1558: '{0}' does not have a suitable static 'Main' method
dotnet_diagnostic.cs1562.severity = error                                                           # CS1562: Outputs without source must have the /out option specified
dotnet_diagnostic.cs1564.severity = error                                                           # CS1564: Conflicting options specified: Win32 resource file; Win32 manifest
dotnet_diagnostic.cs1565.severity = error                                                           # CS1565: Conflicting options specified: Win32 resource file; Win32 icon
dotnet_diagnostic.cs1566.severity = error                                                           # CS1566: Error reading resource '{0}' -- '{1}'
dotnet_diagnostic.cs1569.severity = error                                                           # CS1569: Error writing to XML documentation file: {0}
dotnet_diagnostic.cs1570.severity = warning                                                         # CS1570: XML comment has badly formed XML -- '{0}'
dotnet_diagnostic.cs1571.severity = warning                                                         # CS1571: XML comment has a duplicate param tag for '{0}'
dotnet_diagnostic.cs1572.severity = warning                                                         # CS1572: XML comment has a param tag for '{0}', but there is no parameter by that name
dotnet_diagnostic.cs1573.severity = warning                                                         # CS1573: Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)
dotnet_diagnostic.cs1574.severity = warning                                                         # CS1574: XML comment has cref attribute '{0}' that could not be resolved
dotnet_diagnostic.cs1575.severity = error                                                           # CS1575: A stackalloc expression requires [] after type
dotnet_diagnostic.cs1576.severity = error                                                           # CS1576: The line number specified for #line directive is missing or invalid
dotnet_diagnostic.cs1578.severity = error                                                           # CS1578: Quoted file name, single-line comment or end-of-line expected
dotnet_diagnostic.cs1579.severity = error                                                           # CS1579: foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'
dotnet_diagnostic.cs1580.severity = warning                                                         # CS1580: Invalid type for parameter {0} in XML comment cref attribute: '{1}'
dotnet_diagnostic.cs1581.severity = warning                                                         # CS1581: Invalid return type in XML comment cref attribute
dotnet_diagnostic.cs1583.severity = error                                                           # CS1583: Error reading Win32 resources -- {0}
dotnet_diagnostic.cs1584.severity = warning                                                         # CS1584: XML comment has syntactically incorrect cref attribute '{0}'
dotnet_diagnostic.cs1585.severity = error                                                           # CS1585: Member modifier '{0}' must precede the member type and name
dotnet_diagnostic.cs1586.severity = error                                                           # CS1586: Array creation must have array size or array initializer
dotnet_diagnostic.cs1587.severity = warning                                                         # CS1587: XML comment is not placed on a valid language element
dotnet_diagnostic.cs1589.severity = warning                                                         # CS1589: Unable to include XML fragment '{1}' of file '{0}' -- {2}
dotnet_diagnostic.cs1590.severity = warning                                                         # CS1590: Invalid XML include element -- {0}
dotnet_diagnostic.cs1591.severity = warning                                                         # CS1591: Missing XML comment for publicly visible type or member '{0}'
dotnet_diagnostic.cs1592.severity = warning                                                         # CS1592: Badly formed XML in included comments file -- '{0}'
dotnet_diagnostic.cs1593.severity = error                                                           # CS1593: Delegate '{0}' does not take {1} arguments
dotnet_diagnostic.cs1597.severity = error                                                           # CS1597: Semicolon after method or accessor block is not valid
dotnet_diagnostic.cs1599.severity = error                                                           # CS1599: The return type of a method, delegate, or function pointer cannot be '{0}'
dotnet_diagnostic.cs1600.severity = error                                                           # CS1600: Compilation cancelled by user
dotnet_diagnostic.cs1601.severity = error                                                           # CS1601: Cannot make reference to variable of type '{0}'
dotnet_diagnostic.cs1604.severity = error                                                           # CS1604: Cannot assign to '{0}' because it is read-only
dotnet_diagnostic.cs1605.severity = error                                                           # CS1605: Cannot use '{0}' as a ref or out value because it is read-only
dotnet_diagnostic.cs1607.severity = warning                                                         # CS1607:
dotnet_diagnostic.cs1608.severity = error                                                           # CS1608: The RequiredAttribute attribute is not permitted on C# types
dotnet_diagnostic.cs1609.severity = error                                                           # CS1609: Modifiers cannot be placed on event accessor declarations
dotnet_diagnostic.cs1611.severity = error                                                           # CS1611: The params parameter cannot be declared as {0}
dotnet_diagnostic.cs1612.severity = error                                                           # CS1612: Cannot modify the return value of '{0}' because it is not a variable
dotnet_diagnostic.cs1613.severity = error                                                           # CS1613: The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)
dotnet_diagnostic.cs1614.severity = error                                                           # CS1614: '{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.
dotnet_diagnostic.cs1615.severity = error                                                           # CS1615: Argument {0} may not be passed with the '{1}' keyword
dotnet_diagnostic.cs1616.severity = warning                                                         # CS1616: Option '{0}' overrides attribute '{1}' given in a source file or added module
dotnet_diagnostic.cs1617.severity = error                                                           # CS1617: Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.
dotnet_diagnostic.cs1618.severity = error                                                           # CS1618: Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute
dotnet_diagnostic.cs1619.severity = error                                                           # CS1619: Cannot create temporary file -- {0}
dotnet_diagnostic.cs1620.severity = error                                                           # CS1620: Argument {0} must be passed with the '{1}' keyword
dotnet_diagnostic.cs1621.severity = error                                                           # CS1621: The yield statement cannot be used inside an anonymous method or lambda expression
dotnet_diagnostic.cs1622.severity = error                                                           # CS1622: Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.
dotnet_diagnostic.cs1623.severity = error                                                           # CS1623: Iterators cannot have ref, in or out parameters
dotnet_diagnostic.cs1624.severity = error                                                           # CS1624: The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type
dotnet_diagnostic.cs1625.severity = error                                                           # CS1625: Cannot yield in the body of a finally clause
dotnet_diagnostic.cs1626.severity = error                                                           # CS1626: Cannot yield a value in the body of a try block with a catch clause
dotnet_diagnostic.cs1627.severity = error                                                           # CS1627: Expression expected after yield return
dotnet_diagnostic.cs1628.severity = error                                                           # CS1628: Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function
dotnet_diagnostic.cs1631.severity = error                                                           # CS1631: Cannot yield a value in the body of a catch clause
dotnet_diagnostic.cs1632.severity = error                                                           # CS1632: Control cannot leave the body of an anonymous method or lambda expression
dotnet_diagnostic.cs1633.severity = warning                                                         # CS1633: Unrecognized #pragma directive
dotnet_diagnostic.cs1634.severity = warning                                                         # CS1634: Expected 'disable' or 'restore'
dotnet_diagnostic.cs1635.severity = warning                                                         # CS1635: Cannot restore warning 'CS{0}' because it was disabled globally
dotnet_diagnostic.cs1636.severity = error                                                           # CS1636: __arglist is not allowed in the parameter list of iterators
dotnet_diagnostic.cs1637.severity = error                                                           # CS1637: Iterators cannot have pointer type parameters
dotnet_diagnostic.cs1639.severity = error                                                           # CS1639: The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature
dotnet_diagnostic.cs1640.severity = error                                                           # CS1640: foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation
dotnet_diagnostic.cs1641.severity = error                                                           # CS1641: A fixed size buffer field must have the array size specifier after the field name
dotnet_diagnostic.cs1642.severity = error                                                           # CS1642: Fixed size buffer fields may only be members of structs
dotnet_diagnostic.cs1643.severity = error                                                           # CS1643: Not all code paths return a value in {0} of type '{1}'
dotnet_diagnostic.cs1645.severity = warning                                                         # CS1645: Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers
dotnet_diagnostic.cs1646.severity = error                                                           # CS1646: Keyword, identifier, or string expected after verbatim specifier: @
dotnet_diagnostic.cs1648.severity = error                                                           # CS1648: Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)
dotnet_diagnostic.cs1649.severity = error                                                           # CS1649: Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)
dotnet_diagnostic.cs1650.severity = error                                                           # CS1650: Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)
dotnet_diagnostic.cs1651.severity = error                                                           # CS1651: Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)
dotnet_diagnostic.cs1654.severity = error                                                           # CS1654: Cannot modify members of '{0}' because it is a '{1}'
dotnet_diagnostic.cs1655.severity = error                                                           # CS1655: Cannot use fields of '{0}' as a ref or out value because it is a '{1}'
dotnet_diagnostic.cs1656.severity = error                                                           # CS1656: Cannot assign to '{0}' because it is a '{1}'
dotnet_diagnostic.cs1657.severity = error                                                           # CS1657: Cannot use '{0}' as a ref or out value because it is a '{1}'
dotnet_diagnostic.cs1658.severity = warning                                                         # CS1658: {0}. See also error CS{1}.
dotnet_diagnostic.cs1660.severity = error                                                           # CS1660: Cannot convert {0} to type '{1}' because it is not a delegate type
dotnet_diagnostic.cs1661.severity = error                                                           # CS1661: Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types
dotnet_diagnostic.cs1662.severity = error                                                           # CS1662: Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type
dotnet_diagnostic.cs1663.severity = error                                                           # CS1663: Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double
dotnet_diagnostic.cs1664.severity = error                                                           # CS1664: Fixed size buffer of length {0} and type '{1}' is too big
dotnet_diagnostic.cs1665.severity = error                                                           # CS1665: Fixed size buffers must have a length greater than zero
dotnet_diagnostic.cs1666.severity = error                                                           # CS1666: You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.
dotnet_diagnostic.cs1667.severity = error                                                           # CS1667: Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.
dotnet_diagnostic.cs1668.severity = warning                                                         # CS1668: Invalid search path '{0}' specified in '{1}' -- '{2}'
dotnet_diagnostic.cs1669.severity = error                                                           # CS1669: __arglist is not valid in this context
dotnet_diagnostic.cs1670.severity = error                                                           # CS1670: params is not valid in this context
dotnet_diagnostic.cs1671.severity = error                                                           # CS1671: A namespace declaration cannot have modifiers or attributes
dotnet_diagnostic.cs1672.severity = error                                                           # CS1672: Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64
dotnet_diagnostic.cs1673.severity = error                                                           # CS1673: Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local function and using the local instead.
dotnet_diagnostic.cs1674.severity = error                                                           # CS1674: '{0}': type used in a using statement must implement 'System.IDisposable'.
dotnet_diagnostic.cs1676.severity = error                                                           # CS1676: Parameter {0} must be declared with the '{1}' keyword
dotnet_diagnostic.cs1677.severity = error                                                           # CS1677: Parameter {0} should not be declared with the '{1}' keyword
dotnet_diagnostic.cs1678.severity = error                                                           # CS1678: Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'
dotnet_diagnostic.cs1679.severity = error                                                           # CS1679: Invalid extern alias for '/reference'; '{0}' is not a valid identifier
dotnet_diagnostic.cs1680.severity = error                                                           # CS1680: Invalid reference alias option: '{0}=' -- missing filename
dotnet_diagnostic.cs1681.severity = error                                                           # CS1681: You cannot redefine the global extern alias
dotnet_diagnostic.cs1685.severity = warning                                                         # CS1685: The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'
dotnet_diagnostic.cs1686.severity = error                                                           # CS1686: Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression
dotnet_diagnostic.cs1687.severity = warning                                                         # CS1687: Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect
dotnet_diagnostic.cs1688.severity = error                                                           # CS1688: Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters
dotnet_diagnostic.cs1689.severity = error                                                           # CS1689: Attribute '{0}' is only valid on methods or attribute classes
dotnet_diagnostic.cs1690.severity = warning                                                         # CS1690: Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class
dotnet_diagnostic.cs1692.severity = warning                                                         # CS1692: Invalid number
dotnet_diagnostic.cs1695.severity = warning                                                         # CS1695: Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."
dotnet_diagnostic.cs1696.severity = warning                                                         # CS1696: Single-line comment or end-of-line expected
dotnet_diagnostic.cs1697.severity = warning                                                         # CS1697: Different checksum values given for '{0}'
dotnet_diagnostic.cs1700.severity = warning                                                         # CS1700: Assembly reference '{0}' is invalid and cannot be resolved
dotnet_diagnostic.cs1701.severity = warning                                                         # CS1701: Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy
dotnet_diagnostic.cs1702.severity = warning                                                         # CS1702: Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy
dotnet_diagnostic.cs1703.severity = error                                                           # CS1703: Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.
dotnet_diagnostic.cs1704.severity = error                                                           # CS1704: An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.
dotnet_diagnostic.cs1705.severity = error                                                           # CS1705: Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'
dotnet_diagnostic.cs1708.severity = error                                                           # CS1708: Fixed size buffers can only be accessed through locals or fields
dotnet_diagnostic.cs1710.severity = warning                                                         # CS1710: XML comment has a duplicate typeparam tag for '{0}'
dotnet_diagnostic.cs1711.severity = warning                                                         # CS1711: XML comment has a typeparam tag for '{0}', but there is no type parameter by that name
dotnet_diagnostic.cs1712.severity = warning                                                         # CS1712: Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)
dotnet_diagnostic.cs1715.severity = error                                                           # CS1715: '{0}': type must be '{2}' to match overridden member '{1}'
dotnet_diagnostic.cs1716.severity = error                                                           # CS1716: Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.
dotnet_diagnostic.cs1717.severity = warning                                                         # CS1717: Assignment made to same variable; did you mean to assign something else?
dotnet_diagnostic.cs1718.severity = warning                                                         # CS1718: Comparison made to same variable; did you mean to compare something else?
dotnet_diagnostic.cs1719.severity = error                                                           # CS1719: Error opening Win32 resource file '{0}' -- '{1}'
dotnet_diagnostic.cs1720.severity = warning                                                         # CS1720: Expression will always cause a System.NullReferenceException because the default value of '{0}' is null
dotnet_diagnostic.cs1721.severity = error                                                           # CS1721: Class '{0}' cannot have multiple base classes: '{1}' and '{2}'
dotnet_diagnostic.cs1722.severity = error                                                           # CS1722: Base class '{0}' must come before any interfaces
dotnet_diagnostic.cs1723.severity = warning                                                         # CS1723: XML comment has cref attribute '{0}' that refers to a type parameter
dotnet_diagnostic.cs1725.severity = error                                                           # CS1725: Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.
dotnet_diagnostic.cs1726.severity = error                                                           # CS1726: Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.
dotnet_diagnostic.cs1728.severity = error                                                           # CS1728: Cannot bind delegate to '{0}' because it is a member of 'System.Nullable<T>'
dotnet_diagnostic.cs1729.severity = error                                                           # CS1729: '{0}' does not contain a constructor that takes {1} arguments
dotnet_diagnostic.cs1730.severity = error                                                           # CS1730: Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations
dotnet_diagnostic.cs1733.severity = error                                                           # CS1733: Expected expression
dotnet_diagnostic.cs1734.severity = warning                                                         # CS1734: XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name
dotnet_diagnostic.cs1735.severity = warning                                                         # CS1735: XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name
dotnet_diagnostic.cs1736.severity = error                                                           # CS1736: Default parameter value for '{0}' must be a compile-time constant
dotnet_diagnostic.cs1737.severity = error                                                           # CS1737: Optional parameters must appear after all required parameters
dotnet_diagnostic.cs1738.severity = error                                                           # CS1738: Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.
dotnet_diagnostic.cs1739.severity = error                                                           # CS1739: The best overload for '{0}' does not have a parameter named '{1}'
dotnet_diagnostic.cs1740.severity = error                                                           # CS1740: Named argument '{0}' cannot be specified multiple times
dotnet_diagnostic.cs1741.severity = error                                                           # CS1741: A ref or out parameter cannot have a default value
dotnet_diagnostic.cs1742.severity = error                                                           # CS1742: An array access may not have a named argument specifier
dotnet_diagnostic.cs1743.severity = error                                                           # CS1743: Cannot specify a default value for the 'this' parameter
dotnet_diagnostic.cs1744.severity = error                                                           # CS1744: Named argument '{0}' specifies a parameter for which a positional argument has already been given
dotnet_diagnostic.cs1745.severity = error                                                           # CS1745: Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute
dotnet_diagnostic.cs1746.severity = error                                                           # CS1746: The delegate '{0}' does not have a parameter named '{1}'
dotnet_diagnostic.cs1747.severity = error                                                           # CS1747: Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.
dotnet_diagnostic.cs1748.severity = error                                                           # CS1748: Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?
dotnet_diagnostic.cs1750.severity = error                                                           # CS1750: A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'
dotnet_diagnostic.cs1751.severity = error                                                           # CS1751: Cannot specify a default value for a parameter collection
dotnet_diagnostic.cs1752.severity = error                                                           # CS1752: Interop type '{0}' cannot be embedded. Use the applicable interface instead.
dotnet_diagnostic.cs1754.severity = error                                                           # CS1754: Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs1756.severity = error                                                           # CS1756: Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.
dotnet_diagnostic.cs1757.severity = error                                                           # CS1757: Embedded interop struct '{0}' can contain only public instance fields.
dotnet_diagnostic.cs1758.severity = error                                                           # CS1758: Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs1759.severity = error                                                           # CS1759: Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.
dotnet_diagnostic.cs1760.severity = error                                                           # CS1760: Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.
dotnet_diagnostic.cs1761.severity = error                                                           # CS1761: Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs1762.severity = warning                                                         # CS1762: A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.
dotnet_diagnostic.cs1763.severity = error                                                           # CS1763: '{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null
dotnet_diagnostic.cs1764.severity = error                                                           # CS1764: Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression
dotnet_diagnostic.cs1766.severity = error                                                           # CS1766: Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.
dotnet_diagnostic.cs1767.severity = error                                                           # CS1767: Interface '{0}' has an invalid source interface which is required to embed event '{1}'.
dotnet_diagnostic.cs1768.severity = error                                                           # CS1768: Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs1769.severity = error                                                           # CS1769: Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.
dotnet_diagnostic.cs1770.severity = error                                                           # CS1770: A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type
dotnet_diagnostic.cs1773.severity = error                                                           # CS1773: Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise
dotnet_diagnostic.cs1774.severity = error                                                           # CS1774: Embedded interop method '{0}' contains a body.
dotnet_diagnostic.cs1900.severity = error                                                           # CS1900: Warning level must be zero or greater
dotnet_diagnostic.cs1902.severity = error                                                           # CS1902: Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'
dotnet_diagnostic.cs1906.severity = error                                                           # CS1906: Invalid option '{0}'; Resource visibility must be either 'public' or 'private'
dotnet_diagnostic.cs1908.severity = error                                                           # CS1908: The type of the argument to the DefaultParameterValue attribute must match the parameter type
dotnet_diagnostic.cs1910.severity = error                                                           # CS1910: Argument of type '{0}' is not applicable for the DefaultParameterValue attribute
dotnet_diagnostic.cs1911.severity = warning                                                         # CS1911: Access to member 'name' through a 'base' keyword from an anonymous method, lambda expression, query expression, or iterator results in unverifiable code. Consider moving the access into a helper method on the containing type.
dotnet_diagnostic.cs1912.severity = error                                                           # CS1912: Duplicate initialization of member '{0}'
dotnet_diagnostic.cs1913.severity = error                                                           # CS1913: Member '{0}' cannot be initialized. It is not a field or property.
dotnet_diagnostic.cs1914.severity = error                                                           # CS1914: Static field or property '{0}' cannot be assigned in an object initializer
dotnet_diagnostic.cs1917.severity = error                                                           # CS1917: Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type
dotnet_diagnostic.cs1918.severity = error                                                           # CS1918: Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type
dotnet_diagnostic.cs1919.severity = error                                                           # CS1919: Unsafe type '{0}' cannot be used in object creation
dotnet_diagnostic.cs1920.severity = error                                                           # CS1920: Element initializer cannot be empty
dotnet_diagnostic.cs1921.severity = error                                                           # CS1921: The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.
dotnet_diagnostic.cs1922.severity = error                                                           # CS1922: Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'
dotnet_diagnostic.cs1926.severity = error                                                           # CS1926: Error opening Win32 manifest file {0} -- {1}
dotnet_diagnostic.cs1927.severity = warning                                                         # CS1927: Ignoring /win32manifest for module because it only applies to assemblies
dotnet_diagnostic.cs1929.severity = error                                                           # CS1929: '{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'
dotnet_diagnostic.cs1930.severity = error                                                           # CS1930: The range variable '{0}' has already been declared
dotnet_diagnostic.cs1931.severity = error                                                           # CS1931: The range variable '{0}' conflicts with a previous declaration of '{0}'
dotnet_diagnostic.cs1932.severity = error                                                           # CS1932: Cannot assign {0} to a range variable
dotnet_diagnostic.cs1934.severity = error                                                           # CS1934: Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.
dotnet_diagnostic.cs1935.severity = error                                                           # CS1935: Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?
dotnet_diagnostic.cs1936.severity = error                                                           # CS1936: Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.
dotnet_diagnostic.cs1937.severity = error                                                           # CS1937: The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.
dotnet_diagnostic.cs1938.severity = error                                                           # CS1938: The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.
dotnet_diagnostic.cs1939.severity = error                                                           # CS1939: Cannot pass the range variable '{0}' as an out or ref parameter
dotnet_diagnostic.cs1940.severity = error                                                           # CS1940: Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.
dotnet_diagnostic.cs1941.severity = error                                                           # CS1941: The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.
dotnet_diagnostic.cs1942.severity = error                                                           # CS1942: The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.
dotnet_diagnostic.cs1943.severity = error                                                           # CS1943: An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.
dotnet_diagnostic.cs1944.severity = error                                                           # CS1944: An expression tree may not contain an unsafe pointer operation
dotnet_diagnostic.cs1945.severity = error                                                           # CS1945: An expression tree may not contain an anonymous method expression
dotnet_diagnostic.cs1946.severity = error                                                           # CS1946: An anonymous method expression cannot be converted to an expression tree
dotnet_diagnostic.cs1947.severity = error                                                           # CS1947: Range variable '{0}' cannot be assigned to -- it is read only
dotnet_diagnostic.cs1948.severity = error                                                           # CS1948: The range variable '{0}' cannot have the same name as a method type parameter
dotnet_diagnostic.cs1949.severity = error                                                           # CS1949: The contextual keyword 'var' cannot be used in a range variable declaration
dotnet_diagnostic.cs1950.severity = error                                                           # CS1950: The best overloaded Add method '{0}' for the collection initializer has some invalid arguments
dotnet_diagnostic.cs1951.severity = error                                                           # CS1951: An expression tree lambda may not contain a ref, in or out parameter
dotnet_diagnostic.cs1952.severity = error                                                           # CS1952: An expression tree lambda may not contain a method with variable arguments
dotnet_diagnostic.cs1954.severity = error                                                           # CS1954: The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.
dotnet_diagnostic.cs1955.severity = error                                                           # CS1955: Non-invocable member '{0}' cannot be used like a method.
dotnet_diagnostic.cs1956.severity = warning                                                         # CS1956: Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.
dotnet_diagnostic.cs1957.severity = warning                                                         # CS1957: Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.
dotnet_diagnostic.cs1958.severity = error                                                           # CS1958: Object and collection initializer expressions may not be applied to a delegate creation expression
dotnet_diagnostic.cs1959.severity = error                                                           # CS1959: '{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.
dotnet_diagnostic.cs1960.severity = error                                                           # CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
dotnet_diagnostic.cs1961.severity = error                                                           # CS1961: Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.
dotnet_diagnostic.cs1962.severity = error                                                           # CS1962: The typeof operator cannot be used on the dynamic type
dotnet_diagnostic.cs1963.severity = error                                                           # CS1963: An expression tree may not contain a dynamic operation
dotnet_diagnostic.cs1964.severity = error                                                           # CS1964: '{0}': user-defined conversions to or from the dynamic type are not allowed
dotnet_diagnostic.cs1965.severity = error                                                           # CS1965: '{0}': cannot derive from the dynamic type
dotnet_diagnostic.cs1966.severity = error                                                           # CS1966: '{0}': cannot implement a dynamic interface '{1}'
dotnet_diagnostic.cs1967.severity = error                                                           # CS1967: Constraint cannot be the dynamic type
dotnet_diagnostic.cs1968.severity = error                                                           # CS1968: Constraint cannot be a dynamic type '{0}'
dotnet_diagnostic.cs1969.severity = error                                                           # CS1969: One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?
dotnet_diagnostic.cs1970.severity = error                                                           # CS1970: Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.
dotnet_diagnostic.cs1971.severity = error                                                           # CS1971: The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.
dotnet_diagnostic.cs1972.severity = error                                                           # CS1972: The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.
dotnet_diagnostic.cs1973.severity = error                                                           # CS1973: '{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
dotnet_diagnostic.cs1974.severity = warning                                                         # CS1974: The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.
dotnet_diagnostic.cs1975.severity = error                                                           # CS1975: The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.
dotnet_diagnostic.cs1976.severity = error                                                           # CS1976: Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?
dotnet_diagnostic.cs1977.severity = error                                                           # CS1977: Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.
dotnet_diagnostic.cs1978.severity = error                                                           # CS1978: Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.
dotnet_diagnostic.cs1979.severity = error                                                           # CS1979: Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed
dotnet_diagnostic.cs1980.severity = error                                                           # CS1980: Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?
dotnet_diagnostic.cs1981.severity = warning                                                         # CS1981: Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values
dotnet_diagnostic.cs1983.severity = error                                                           # CS1983: The return type of an async method must be void, Task, Task<T>, a task-like type, IAsyncEnumerable<T>, or IAsyncEnumerator<T>
dotnet_diagnostic.cs1984.severity = error                                                           # CS1984: Cannot await in the body of a finally clause
dotnet_diagnostic.cs1985.severity = error                                                           # CS1985: Cannot await in a catch clause
dotnet_diagnostic.cs1986.severity = error                                                           # CS1986: 'await' requires that the type {0} have a suitable 'GetAwaiter' method
dotnet_diagnostic.cs1988.severity = error                                                           # CS1988: Async methods cannot have ref, in or out parameters
dotnet_diagnostic.cs1989.severity = error                                                           # CS1989: Async lambda expressions cannot be converted to expression trees
dotnet_diagnostic.cs1991.severity = error                                                           # CS1991: '{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.
dotnet_diagnostic.cs1992.severity = error                                                           # CS1992: The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier
dotnet_diagnostic.cs1994.severity = error                                                           # CS1994: The 'async' modifier can only be used in methods that have a body.
dotnet_diagnostic.cs1995.severity = error                                                           # CS1995: The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause
dotnet_diagnostic.cs1996.severity = error                                                           # CS1996: Cannot await in the body of a lock statement
dotnet_diagnostic.cs1997.severity = error                                                           # CS1997: Since '{0}' is an async method that returns '{1}', a return keyword must not be followed by an object expression
dotnet_diagnostic.cs1998.severity = warning                                                         # CS1998: Async function without await expression
dotnet_diagnostic.cs2001.severity = error                                                           # CS2001: Source file '{0}' could not be found.
dotnet_diagnostic.cs2002.severity = warning                                                         # CS2002: Source file '{0}' specified multiple times
dotnet_diagnostic.cs2005.severity = error                                                           # CS2005: Missing file specification for '{0}' option
dotnet_diagnostic.cs2006.severity = error                                                           # CS2006: Command-line syntax error: Missing '{0}' for '{1}' option
dotnet_diagnostic.cs2007.severity = error                                                           # CS2007: Unrecognized option: '{0}'
dotnet_diagnostic.cs2008.severity = warning                                                         # CS2008: No source files specified.
dotnet_diagnostic.cs2011.severity = error                                                           # CS2011: Error opening response file '{0}'
dotnet_diagnostic.cs2012.severity = error                                                           # CS2012: Cannot open '{0}' for writing -- {1}
dotnet_diagnostic.cs2013.severity = error                                                           # CS2013: Invalid image base number '{0}'
dotnet_diagnostic.cs2015.severity = error                                                           # CS2015: '{0}' is a binary file instead of a text file
dotnet_diagnostic.cs2016.severity = error                                                           # CS2016: Code page '{0}' is invalid or not installed
dotnet_diagnostic.cs2017.severity = error                                                           # CS2017: Cannot specify /main if building a module or library
dotnet_diagnostic.cs2019.severity = error                                                           # CS2019: Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'
dotnet_diagnostic.cs2021.severity = error                                                           # CS2021: File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long
dotnet_diagnostic.cs2023.severity = warning                                                         # CS2023: Ignoring /noconfig option because it was specified in a response file
dotnet_diagnostic.cs2024.severity = error                                                           # CS2024: Invalid file section alignment '{0}'
dotnet_diagnostic.cs2029.severity = warning                                                         # CS2029: Invalid name for a preprocessing symbol; '{0}' is not a valid identifier
dotnet_diagnostic.cs2033.severity = error                                                           # CS2033: Cannot create short filename '{0}' when a long filename with the same short filename already exists
dotnet_diagnostic.cs2034.severity = error                                                           # CS2034: A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.
dotnet_diagnostic.cs2035.severity = error                                                           # CS2035: Command-line syntax error: Missing ':<number>' for '{0}' option
dotnet_diagnostic.cs2036.severity = error                                                           # CS2036: The /pdb option requires that the /debug option also be used
dotnet_diagnostic.cs2037.severity = error                                                           # CS2037: An expression tree lambda may not contain a COM call with ref omitted on arguments
dotnet_diagnostic.cs2038.severity = warning                                                         # CS2038: The language name '{0}' is invalid.
dotnet_diagnostic.cs2039.severity = error                                                           # CS2039: Command-line syntax error: Invalid Guid format '{0}' for option '{1}'
dotnet_diagnostic.cs2040.severity = error                                                           # CS2040: Command-line syntax error: Missing Guid for option '{1}'
dotnet_diagnostic.cs2041.severity = error                                                           # CS2041: Invalid output name: {0}
dotnet_diagnostic.cs2042.severity = error                                                           # CS2042: Invalid debug information format: {0}
dotnet_diagnostic.cs2043.severity = error                                                           # CS2043: 'id#' syntax is no longer supported. Use '$id' instead.
dotnet_diagnostic.cs2044.severity = error                                                           # CS2044: /sourcelink switch is only supported when emitting PDB.
dotnet_diagnostic.cs2045.severity = error                                                           # CS2045: /embed switch is only supported when emitting a PDB.
dotnet_diagnostic.cs2046.severity = error                                                           # CS2046: Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.
dotnet_diagnostic.cs3000.severity = warning                                                         # CS3000: Methods with variable arguments are not CLS-compliant
dotnet_diagnostic.cs3001.severity = warning                                                         # CS3001: Argument type '{0}' is not CLS-compliant
dotnet_diagnostic.cs3002.severity = warning                                                         # CS3002: Return type of '{0}' is not CLS-compliant
dotnet_diagnostic.cs3003.severity = warning                                                         # CS3003: Type of '{0}' is not CLS-compliant
dotnet_diagnostic.cs3005.severity = warning                                                         # CS3005: Identifier '{0}' differing only in case is not CLS-compliant
dotnet_diagnostic.cs3006.severity = warning                                                         # CS3006: Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant
dotnet_diagnostic.cs3007.severity = warning                                                         # CS3007: Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant
dotnet_diagnostic.cs3008.severity = warning                                                         # CS3008: Identifier '{0}' is not CLS-compliant
dotnet_diagnostic.cs3009.severity = warning                                                         # CS3009: '{0}': base type '{1}' is not CLS-compliant
dotnet_diagnostic.cs3010.severity = warning                                                         # CS3010: '{0}': CLS-compliant interfaces must have only CLS-compliant members
dotnet_diagnostic.cs3011.severity = warning                                                         # CS3011: '{0}': only CLS-compliant members can be abstract
dotnet_diagnostic.cs3012.severity = warning                                                         # CS3012: You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking
dotnet_diagnostic.cs3013.severity = warning                                                         # CS3013: Added modules must be marked with the CLSCompliant attribute to match the assembly
dotnet_diagnostic.cs3014.severity = warning                                                         # CS3014: '{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute
dotnet_diagnostic.cs3015.severity = warning                                                         # CS3015: '{0}' has no accessible constructors which use only CLS-compliant types
dotnet_diagnostic.cs3016.severity = warning                                                         # CS3016: Arrays as attribute arguments is not CLS-compliant
dotnet_diagnostic.cs3017.severity = warning                                                         # CS3017: You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly
dotnet_diagnostic.cs3018.severity = warning                                                         # CS3018: '{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'
dotnet_diagnostic.cs3019.severity = warning                                                         # CS3019: CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly
dotnet_diagnostic.cs3021.severity = warning                                                         # CS3021: '{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute
dotnet_diagnostic.cs3022.severity = warning                                                         # CS3022: CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.
dotnet_diagnostic.cs3023.severity = warning                                                         # CS3023: CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.
dotnet_diagnostic.cs3024.severity = warning                                                         # CS3024: Constraint type '{0}' is not CLS-compliant
dotnet_diagnostic.cs3026.severity = warning                                                         # CS3026: CLS-compliant field '{0}' cannot be volatile
dotnet_diagnostic.cs3027.severity = warning                                                         # CS3027: '{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant
dotnet_diagnostic.cs3028.severity = error                                                           # CS3028: Algorithm '{0}' is not supported
dotnet_diagnostic.cs4001.severity = error                                                           # CS4001: Cannot await '{0}'
dotnet_diagnostic.cs4003.severity = error                                                           # CS4003: 'await' cannot be used as an identifier within an async method or lambda expression
dotnet_diagnostic.cs4004.severity = error                                                           # CS4004: Cannot await in an unsafe context
dotnet_diagnostic.cs4005.severity = error                                                           # CS4005: Async methods cannot have pointer type parameters
dotnet_diagnostic.cs4006.severity = error                                                           # CS4006: __arglist is not allowed in the parameter list of async methods
dotnet_diagnostic.cs4007.severity = error                                                           # CS4007: Instance of type '{0}' cannot be preserved across 'await' or 'yield' boundary.
dotnet_diagnostic.cs4008.severity = error                                                           # CS4008: Cannot await 'void'
dotnet_diagnostic.cs4009.severity = error                                                           # CS4009: A void or int returning entry point cannot be async
dotnet_diagnostic.cs4010.severity = error                                                           # CS4010: Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task<T>, none of which are convertible to '{1}'.
dotnet_diagnostic.cs4011.severity = error                                                           # CS4011: 'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'
dotnet_diagnostic.cs4012.severity = error                                                           # CS4012: Parameters of type '{0}' cannot be declared in async methods or async lambda expressions.
dotnet_diagnostic.cs4013.severity = error                                                           # CS4013: Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method
dotnet_diagnostic.cs4014.severity = warning                                                         # CS4014: Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.
dotnet_diagnostic.cs4015.severity = error                                                           # CS4015: 'MethodImplOptions.Synchronized' cannot be applied to an async method
dotnet_diagnostic.cs4016.severity = error                                                           # CS4016: Since this is an async method, the return expression must be of type '{0}' rather than '{1}'
dotnet_diagnostic.cs4017.severity = error                                                           # CS4017: CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'
dotnet_diagnostic.cs4018.severity = error                                                           # CS4018: CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'
dotnet_diagnostic.cs4019.severity = error                                                           # CS4019: CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'
dotnet_diagnostic.cs4020.severity = error                                                           # CS4020: The CallerLineNumberAttribute may only be applied to parameters with default values
dotnet_diagnostic.cs4021.severity = error                                                           # CS4021: The CallerFilePathAttribute may only be applied to parameters with default values
dotnet_diagnostic.cs4022.severity = error                                                           # CS4022: The CallerMemberNameAttribute may only be applied to parameters with default values
dotnet_diagnostic.cs4023.severity = error                                                           # CS4023: /platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe
dotnet_diagnostic.cs4024.severity = warning                                                         # CS4024: The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
dotnet_diagnostic.cs4025.severity = warning                                                         # CS4025: The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
dotnet_diagnostic.cs4026.severity = warning                                                         # CS4026: The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
dotnet_diagnostic.cs4027.severity = error                                                           # CS4027: '{0}' does not implement '{1}'
dotnet_diagnostic.cs4028.severity = error                                                           # CS4028: 'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?
dotnet_diagnostic.cs4029.severity = error                                                           # CS4029: Cannot return an expression of type 'void'
dotnet_diagnostic.cs4030.severity = error                                                           # CS4030: Security attribute '{0}' cannot be applied to an Async method.
dotnet_diagnostic.cs4031.severity = error                                                           # CS4031: Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.
dotnet_diagnostic.cs4032.severity = error                                                           # CS4032: The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task<{0}>'.
dotnet_diagnostic.cs4033.severity = error                                                           # CS4033: The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.
dotnet_diagnostic.cs4034.severity = error                                                           # CS4034: The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.
dotnet_diagnostic.cs4036.severity = error                                                           # CS4036: '{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)
dotnet_diagnostic.cs5001.severity = error                                                           # CS5001: Program does not contain a static 'Main' method suitable for an entry point
dotnet_diagnostic.cs7000.severity = error                                                           # CS7000: Unexpected use of an aliased name
dotnet_diagnostic.cs7002.severity = error                                                           # CS7002: Unexpected use of a generic name
dotnet_diagnostic.cs7003.severity = error                                                           # CS7003: Unexpected use of an unbound generic name
dotnet_diagnostic.cs7006.severity = error                                                           # CS7006: Expressions and statements can only occur in a method body
dotnet_diagnostic.cs7007.severity = error                                                           # CS7007: A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead
dotnet_diagnostic.cs7008.severity = error                                                           # CS7008: The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session
dotnet_diagnostic.cs7009.severity = error                                                           # CS7009: Cannot use #r after first token in file
dotnet_diagnostic.cs7010.severity = error                                                           # CS7010: Quoted file name expected
dotnet_diagnostic.cs7011.severity = error                                                           # CS7011: #r is only allowed in scripts
dotnet_diagnostic.cs7012.severity = error                                                           # CS7012: The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)
dotnet_diagnostic.cs7013.severity = error                                                           # CS7013: Name '{0}' exceeds the maximum length allowed in metadata.
dotnet_diagnostic.cs7014.severity = error                                                           # CS7014: Attributes are not valid in this context.
dotnet_diagnostic.cs7015.severity = error                                                           # CS7015: 'extern alias' is not valid in this context
dotnet_diagnostic.cs7016.severity = error                                                           # CS7016: Alias '{0}' conflicts with {1} definition
dotnet_diagnostic.cs7017.severity = error                                                           # CS7017: Member definition, statement, or end-of-file expected
dotnet_diagnostic.cs7018.severity = error                                                           # CS7018: Expected a script (.csx file) but none specified
dotnet_diagnostic.cs7019.severity = error                                                           # CS7019: Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.
dotnet_diagnostic.cs7020.severity = error                                                           # CS7020: Cannot use 'yield' in top-level script code
dotnet_diagnostic.cs7021.severity = error                                                           # CS7021: Cannot declare namespace in script code
dotnet_diagnostic.cs7022.severity = warning                                                         # CS7022: The entry point of the program is global code; ignoring '{0}' entry point.
dotnet_diagnostic.cs7023.severity = warning                                                         # CS7023: The second operand of an 'is' or 'as' operator may not be static type '{0}'
dotnet_diagnostic.cs7024.severity = error                                                           # CS7024: Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.
dotnet_diagnostic.cs7025.severity = error                                                           # CS7025: Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'
dotnet_diagnostic.cs7026.severity = error                                                           # CS7026: Assembly and module attributes are not allowed in this context
dotnet_diagnostic.cs7027.severity = error                                                           # CS7027: Error signing output with public key from file '{0}' -- {1}
dotnet_diagnostic.cs7028.severity = error                                                           # CS7028: Error signing output with public key from container '{0}' -- {1}
dotnet_diagnostic.cs7029.severity = error                                                           # CS7029: Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.
dotnet_diagnostic.cs7030.severity = error                                                           # CS7030: Cannot pass null for friend assembly name
dotnet_diagnostic.cs7032.severity = error                                                           # CS7032: Key file '{0}' is missing the private key needed for signing
dotnet_diagnostic.cs7033.severity = warning                                                         # CS7033: Delay signing was specified and requires a public key, but no public key was specified
dotnet_diagnostic.cs7034.severity = error                                                           # CS7034: The specified version string '{0}' does not conform to the required format - major[.minor[.build[.revision]]]
dotnet_diagnostic.cs7035.severity = warning                                                         # CS7035: The specified version string '{0}' does not conform to the recommended format - major.minor.build.revision
dotnet_diagnostic.cs7036.severity = error                                                           # CS7036: There is no argument given that corresponds to the required parameter '{0}' of '{1}'
dotnet_diagnostic.cs7038.severity = error                                                           # CS7038: Failed to emit module '{0}': {1}
dotnet_diagnostic.cs7041.severity = error                                                           # CS7041: Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly
dotnet_diagnostic.cs7042.severity = error                                                           # CS7042: The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.
dotnet_diagnostic.cs7043.severity = error                                                           # CS7043: Cannot emit update; {0} '{1}' is missing.
dotnet_diagnostic.cs7045.severity = error                                                           # CS7045: Parameter not valid for the specified unmanaged type.
dotnet_diagnostic.cs7046.severity = error                                                           # CS7046: Attribute parameter '{0}' must be specified.
dotnet_diagnostic.cs7047.severity = error                                                           # CS7047: Attribute parameter '{0}' or '{1}' must be specified.
dotnet_diagnostic.cs7048.severity = error                                                           # CS7048: First argument to a security attribute must be a valid SecurityAction
dotnet_diagnostic.cs7049.severity = error                                                           # CS7049: Security attribute '{0}' has an invalid SecurityAction value '{1}'
dotnet_diagnostic.cs7050.severity = error                                                           # CS7050: SecurityAction value '{0}' is invalid for security attributes applied to an assembly
dotnet_diagnostic.cs7051.severity = error                                                           # CS7051: SecurityAction value '{0}' is invalid for security attributes applied to a type or a method
dotnet_diagnostic.cs7052.severity = error                                                           # CS7052: SecurityAction value '{0}' is invalid for PrincipalPermission attribute
dotnet_diagnostic.cs7053.severity = error                                                           # CS7053: An expression tree may not contain '{0}'
dotnet_diagnostic.cs7054.severity = error                                                           # CS7054: Unmanaged type '{0}' not valid for fields.
dotnet_diagnostic.cs7055.severity = error                                                           # CS7055: Unmanaged type '{0}' is only valid for fields.
dotnet_diagnostic.cs7056.severity = error                                                           # CS7056: Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute
dotnet_diagnostic.cs7057.severity = error                                                           # CS7057: Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'
dotnet_diagnostic.cs7058.severity = error                                                           # CS7058: The specified version string '{0}' does not conform to the required format - major.minor.build.revision (without wildcards)
dotnet_diagnostic.cs7059.severity = error                                                           # CS7059: Executables cannot be satellite assemblies; culture should always be empty
dotnet_diagnostic.cs7061.severity = error                                                           # CS7061: Duplicate '{0}' attribute in '{1}'
dotnet_diagnostic.cs7064.severity = error                                                           # CS7064: Error opening icon file {0} -- {1}
dotnet_diagnostic.cs7065.severity = error                                                           # CS7065: Error building Win32 resources -- {0}
dotnet_diagnostic.cs7067.severity = error                                                           # CS7067: Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.
dotnet_diagnostic.cs7068.severity = error                                                           # CS7068: Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules
dotnet_diagnostic.cs7069.severity = error                                                           # CS7069: Reference to type '{0}' claims it is defined in '{1}', but it could not be found
dotnet_diagnostic.cs7070.severity = error                                                           # CS7070: Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.
dotnet_diagnostic.cs7071.severity = error                                                           # CS7071: Assembly reference '{0}' is invalid and cannot be resolved
dotnet_diagnostic.cs7079.severity = error                                                           # CS7079: The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.
dotnet_diagnostic.cs7080.severity = warning                                                         # CS7080: The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.
dotnet_diagnostic.cs7081.severity = warning                                                         # CS7081: The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.
dotnet_diagnostic.cs7082.severity = warning                                                         # CS7082: The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.
dotnet_diagnostic.cs7083.severity = error                                                           # CS7083: Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.
dotnet_diagnostic.cs7084.severity = error                                                           # CS7084: A Windows Runtime event may not be passed as an out or ref parameter.
dotnet_diagnostic.cs7086.severity = error                                                           # CS7086: Module name '{0}' stored in '{1}' must match its filename.
dotnet_diagnostic.cs7087.severity = error                                                           # CS7087: Invalid module name: {0}
dotnet_diagnostic.cs7088.severity = error                                                           # CS7088: Invalid '{0}' value: '{1}'.
dotnet_diagnostic.cs7089.severity = error                                                           # CS7089: AppConfigPath must be absolute.
dotnet_diagnostic.cs7090.severity = warning                                                         # CS7090: Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source
dotnet_diagnostic.cs7091.severity = error                                                           # CS7091: Attribute '{0}' given in a source file conflicts with option '{1}'.
dotnet_diagnostic.cs7092.severity = error                                                           # CS7092: A fixed buffer may only have one dimension.
dotnet_diagnostic.cs7093.severity = error                                                           # CS7093: Cannot read config file '{0}' -- '{1}'
dotnet_diagnostic.cs7094.severity = error                                                           # CS7094: Cannot await in the filter expression of a catch clause
dotnet_diagnostic.cs7095.severity = warning                                                         # CS7095: Filter expression is a constant 'true', consider removing the filter
dotnet_diagnostic.cs7096.severity = error                                                           # CS7096: Cannot continue since the edit includes a reference to an embedded type: '{0}'.
dotnet_diagnostic.cs7098.severity = error                                                           # CS7098: Linked netmodule metadata must provide a full PE image: '{0}'.
dotnet_diagnostic.cs7099.severity = error                                                           # CS7099: Metadata references are not supported.
dotnet_diagnostic.cs7100.severity = error                                                           # CS7100: Assembly culture strings may not contain embedded NUL characters.
dotnet_diagnostic.cs7101.severity = error                                                           # CS7101: Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.
dotnet_diagnostic.cs7102.severity = error                                                           # CS7102: Compilation options '{0}' and '{1}' can't both be specified at the same time.
dotnet_diagnostic.cs7103.severity = error                                                           # CS7103: Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}': {3}
dotnet_diagnostic.cs8001.severity = warning                                                         # CS8001: The command line switch '{0}' is not yet implemented and was ignored.
dotnet_diagnostic.cs8002.severity = warning                                                         # CS8002: Referenced assembly '{0}' does not have a strong name.
dotnet_diagnostic.cs8003.severity = error                                                           # CS8003: Invalid signature public key specified in AssemblySignatureKeyAttribute.
dotnet_diagnostic.cs8004.severity = error                                                           # CS8004: Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.
dotnet_diagnostic.cs8005.severity = error                                                           # CS8005: Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.
dotnet_diagnostic.cs8006.severity = error                                                           # CS8006: Forwarded type '{0}' conflicts with type declared in primary module of this assembly.
dotnet_diagnostic.cs8007.severity = error                                                           # CS8007: Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.
dotnet_diagnostic.cs8008.severity = error                                                           # CS8008: Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.
dotnet_diagnostic.cs8009.severity = warning                                                         # CS8009: Referenced assembly '{0}' has different culture setting of '{1}'.
dotnet_diagnostic.cs8010.severity = error                                                           # CS8010: Agnostic assembly cannot have a processor specific module '{0}'.
dotnet_diagnostic.cs8011.severity = error                                                           # CS8011: Assembly and module '{0}' cannot target different processors.
dotnet_diagnostic.cs8012.severity = warning                                                         # CS8012: Referenced assembly '{0}' targets a different processor.
dotnet_diagnostic.cs8013.severity = error                                                           # CS8013: Cryptographic failure while creating hashes.
dotnet_diagnostic.cs8014.severity = error                                                           # CS8014: Reference to '{0}' netmodule missing.
dotnet_diagnostic.cs8015.severity = error                                                           # CS8015: Module '{0}' is already defined in this assembly. Each module must have a unique filename.
dotnet_diagnostic.cs8016.severity = error                                                           # CS8016: Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?
dotnet_diagnostic.cs8017.severity = error                                                           # CS8017: The parameter has multiple distinct default values.
dotnet_diagnostic.cs8018.severity = warning                                                         # CS8018: Within cref attributes, nested types of generic types should be qualified.
dotnet_diagnostic.cs8019.severity = warning                                                         # CS8019: Unnecessary using directive.
dotnet_diagnostic.cs8020.severity = silent                                                          # CS8020: Unused extern alias.
dotnet_diagnostic.cs8021.severity = warning                                                         # CS8021: No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.
dotnet_diagnostic.cs8022.severity = error                                                           # CS8022: Feature '{0}' is not available in C# 1. Please use language version {1} or greater.
dotnet_diagnostic.cs8023.severity = error                                                           # CS8023: Feature '{0}' is not available in C# 2. Please use language version {1} or greater.
dotnet_diagnostic.cs8024.severity = error                                                           # CS8024: Feature '{0}' is not available in C# 3. Please use language version {1} or greater.
dotnet_diagnostic.cs8025.severity = error                                                           # CS8025: Feature '{0}' is not available in C# 4. Please use language version {1} or greater.
dotnet_diagnostic.cs8026.severity = error                                                           # CS8026: Feature '{0}' is not available in C# 5. Please use language version {1} or greater.
dotnet_diagnostic.cs8027.severity = error                                                           # CS8027: The field has multiple distinct constant values.
dotnet_diagnostic.cs8028.severity = error                                                           # CS8028: '{0}': a class with the ComImport attribute cannot specify field initializers.
dotnet_diagnostic.cs8029.severity = warning                                                         # CS8029: Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.
dotnet_diagnostic.cs8030.severity = error                                                           # CS8030: Anonymous function converted to a void returning delegate cannot return a value
dotnet_diagnostic.cs8031.severity = error                                                           # CS8031: Async lambda expression converted to a '{0}' returning delegate cannot return a value
dotnet_diagnostic.cs8032.severity = warning                                                         # CS8032: An instance of analyzer {0} cannot be created from {1} : {2}.
dotnet_diagnostic.cs8033.severity = warning                                                         # CS8033: The assembly {0} does not contain any analyzers.
dotnet_diagnostic.cs8034.severity = warning                                                         # CS8034: Unable to load Analyzer assembly {0} : {1}
dotnet_diagnostic.cs8035.severity = error                                                           # CS8035: Error reading ruleset file {0} - {1}
dotnet_diagnostic.cs8036.severity = error                                                           # CS8036: Error reading debug information for '{0}'
dotnet_diagnostic.cs8040.severity = suggestion                                                      # CS8040: Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.
dotnet_diagnostic.cs8050.severity = error                                                           # CS8050: Only auto-implemented properties, or properties that use the 'field' keyword, can have initializers.
dotnet_diagnostic.cs8051.severity = error                                                           # CS8051: Auto-implemented properties must have get accessors.
dotnet_diagnostic.cs8053.severity = error                                                           # CS8053: Instance properties in interfaces cannot have initializers.
dotnet_diagnostic.cs8054.severity = error                                                           # CS8054: Enums cannot contain explicit parameterless constructors
dotnet_diagnostic.cs8055.severity = error                                                           # CS8055: Cannot emit debug information for a source text without encoding.
dotnet_diagnostic.cs8057.severity = error                                                           # CS8057: Block bodies and expression bodies cannot both be provided.
dotnet_diagnostic.cs8058.severity = error                                                           # CS8058: Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.
dotnet_diagnostic.cs8059.severity = error                                                           # CS8059: Feature '{0}' is not available in C# 6. Please use language version {1} or greater.
dotnet_diagnostic.cs8070.severity = error                                                           # CS8070: Control cannot fall out of switch from final case label ('{0}')
dotnet_diagnostic.cs8072.severity = error                                                           # CS8072: An expression tree lambda may not contain a null propagating operator.
dotnet_diagnostic.cs8073.severity = warning                                                         # CS8073: The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'
dotnet_diagnostic.cs8074.severity = error                                                           # CS8074: An expression tree lambda may not contain a dictionary initializer.
dotnet_diagnostic.cs8075.severity = error                                                           # CS8075: An extension Add method is not supported for a collection initializer in an expression lambda.
dotnet_diagnostic.cs8076.severity = error                                                           # CS8076: Missing close delimiter '}' for interpolated expression started with '{'.
dotnet_diagnostic.cs8078.severity = error                                                           # CS8078: An expression is too long or complex to compile
dotnet_diagnostic.cs8079.severity = error                                                           # CS8079: Use of possibly unassigned auto-implemented property '{0}'
dotnet_diagnostic.cs8080.severity = error                                                           # CS8080: Auto-implemented properties must override all accessors of the overridden property.
dotnet_diagnostic.cs8081.severity = error                                                           # CS8081: Expression does not have a name.
dotnet_diagnostic.cs8082.severity = error                                                           # CS8082: Sub-expression cannot be used in an argument to nameof.
dotnet_diagnostic.cs8083.severity = error                                                           # CS8083: An alias-qualified name is not an expression.
dotnet_diagnostic.cs8084.severity = error                                                           # CS8084: Type parameters are not allowed on a method group as an argument to 'nameof'.
dotnet_diagnostic.cs8085.severity = error                                                           # CS8085: A 'using static' directive cannot be used to declare an alias
dotnet_diagnostic.cs8086.severity = error                                                           # CS8086: A '{0}' character must be escaped (by doubling) in an interpolated string.
dotnet_diagnostic.cs8087.severity = error                                                           # CS8087: A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.
dotnet_diagnostic.cs8088.severity = error                                                           # CS8088: A format specifier may not contain trailing whitespace.
dotnet_diagnostic.cs8089.severity = error                                                           # CS8089: Empty format specifier.
dotnet_diagnostic.cs8090.severity = error                                                           # CS8090: There is an error in a referenced assembly '{0}'.
dotnet_diagnostic.cs8091.severity = error                                                           # CS8091: '{0}' cannot be extern and have a constructor initializer
dotnet_diagnostic.cs8092.severity = error                                                           # CS8092: Expression or declaration statement expected.
dotnet_diagnostic.cs8093.severity = error                                                           # CS8093: Extension method groups are not allowed as an argument to 'nameof'.
dotnet_diagnostic.cs8094.severity = warning                                                         # CS8094: Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.
dotnet_diagnostic.cs8095.severity = error                                                           # CS8095: Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.
dotnet_diagnostic.cs8096.severity = error                                                           # CS8096: Debug entry point must be a definition of a method declared in the current compilation.
dotnet_diagnostic.cs8097.severity = error                                                           # CS8097: #load is only allowed in scripts
dotnet_diagnostic.cs8098.severity = error                                                           # CS8098: Cannot use #load after first token in file
dotnet_diagnostic.cs8099.severity = error                                                           # CS8099: Source file references are not supported.
dotnet_diagnostic.cs8100.severity = error                                                           # CS8100: The 'await' operator cannot be used in a static script variable initializer.
dotnet_diagnostic.cs8101.severity = error                                                           # CS8101: The pathmap option was incorrectly formatted.
dotnet_diagnostic.cs8102.severity = error                                                           # CS8102: Public signing was specified and requires a public key, but no public key was specified.
dotnet_diagnostic.cs8103.severity = error                                                           # CS8103: Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals or try the EXPERIMENTAL feature flag 'experimental-data-section-string-literals'.
dotnet_diagnostic.cs8104.severity = error                                                           # CS8104: An error occurred while writing the output file: {0}.
dotnet_diagnostic.cs8105.severity = warning                                                         # CS8105: Attribute '{0}' is ignored when public signing is specified.
dotnet_diagnostic.cs8106.severity = error                                                           # CS8106: Option '{0}' must be an absolute path.
dotnet_diagnostic.cs8107.severity = error                                                           # CS8107: Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.
dotnet_diagnostic.cs8108.severity = error                                                           # CS8108: Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.
dotnet_diagnostic.cs8110.severity = error                                                           # CS8110: An expression tree may not contain a reference to a local function
dotnet_diagnostic.cs8111.severity = error                                                           # CS8111: Invalid instrumentation kind: {0}
dotnet_diagnostic.cs8112.severity = error                                                           # CS8112: Local function '{0}' must declare a body because it is not marked 'static extern'.
dotnet_diagnostic.cs8113.severity = error                                                           # CS8113: Invalid hash algorithm name: '{0}'
dotnet_diagnostic.cs8115.severity = error                                                           # CS8115: A throw expression is not allowed in this context.
dotnet_diagnostic.cs8116.severity = error                                                           # CS8116: It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.
dotnet_diagnostic.cs8117.severity = error                                                           # CS8117: Invalid operand for pattern match; value required, but found '{0}'.
dotnet_diagnostic.cs8119.severity = error                                                           # CS8119: The switch expression must be a value; found '{0}'.
dotnet_diagnostic.cs8120.severity = error                                                           # CS8120: The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.
dotnet_diagnostic.cs8121.severity = error                                                           # CS8121: An expression of type '{0}' cannot be handled by a pattern of type '{1}'.
dotnet_diagnostic.cs8122.severity = error                                                           # CS8122: An expression tree may not contain an 'is' pattern-matching operator.
dotnet_diagnostic.cs8123.severity = warning                                                         # CS8123: The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.
dotnet_diagnostic.cs8124.severity = error                                                           # CS8124: Tuple must contain at least two elements.
dotnet_diagnostic.cs8125.severity = error                                                           # CS8125: Tuple element name '{0}' is only allowed at position {1}.
dotnet_diagnostic.cs8126.severity = error                                                           # CS8126: Tuple element name '{0}' is disallowed at any position.
dotnet_diagnostic.cs8127.severity = error                                                           # CS8127: Tuple element names must be unique.
dotnet_diagnostic.cs8128.severity = error                                                           # CS8128: Member '{0}' was not found on type '{1}' from assembly '{2}'.
dotnet_diagnostic.cs8129.severity = error                                                           # CS8129: No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.
dotnet_diagnostic.cs8130.severity = error                                                           # CS8130: Cannot infer the type of implicitly-typed deconstruction variable '{0}'.
dotnet_diagnostic.cs8131.severity = error                                                           # CS8131: Deconstruct assignment requires an expression with a type on the right-hand-side.
dotnet_diagnostic.cs8132.severity = error                                                           # CS8132: Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.
dotnet_diagnostic.cs8133.severity = error                                                           # CS8133: Cannot deconstruct dynamic objects.
dotnet_diagnostic.cs8134.severity = error                                                           # CS8134: Deconstruction must contain at least two variables.
dotnet_diagnostic.cs8135.severity = error                                                           # CS8135: Tuple with {0} elements cannot be converted to type '{1}'.
dotnet_diagnostic.cs8136.severity = error                                                           # CS8136: Deconstruction 'var (...)' form disallows a specific type for 'var'.
dotnet_diagnostic.cs8137.severity = error                                                           # CS8137: Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?
dotnet_diagnostic.cs8138.severity = error                                                           # CS8138: Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.
dotnet_diagnostic.cs8139.severity = error                                                           # CS8139: '{0}': cannot change tuple element names when overriding inherited member '{1}'
dotnet_diagnostic.cs8140.severity = error                                                           # CS8140: '{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.
dotnet_diagnostic.cs8141.severity = error                                                           # CS8141: The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).
dotnet_diagnostic.cs8142.severity = error                                                           # CS8142: Both partial member declarations, '{0}' and '{1}', must use the same tuple element names.
dotnet_diagnostic.cs8143.severity = error                                                           # CS8143: An expression tree may not contain a tuple literal.
dotnet_diagnostic.cs8144.severity = error                                                           # CS8144: An expression tree may not contain a tuple conversion.
dotnet_diagnostic.cs8145.severity = error                                                           # CS8145: Auto-implemented properties cannot return by reference
dotnet_diagnostic.cs8146.severity = error                                                           # CS8146: Properties which return by reference must have a get accessor
dotnet_diagnostic.cs8147.severity = error                                                           # CS8147: Properties which return by reference cannot have set accessors
dotnet_diagnostic.cs8148.severity = error                                                           # CS8148: '{0}' must match by reference return of overridden member '{1}'
dotnet_diagnostic.cs8149.severity = error                                                           # CS8149: By-reference returns may only be used in methods that return by reference
dotnet_diagnostic.cs8150.severity = error                                                           # CS8150: By-value returns may only be used in methods that return by value
dotnet_diagnostic.cs8151.severity = error                                                           # CS8151: The return expression must be of type '{0}' because this method returns by reference
dotnet_diagnostic.cs8152.severity = error                                                           # CS8152: '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.
dotnet_diagnostic.cs8153.severity = error                                                           # CS8153: An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference
dotnet_diagnostic.cs8154.severity = error                                                           # CS8154: The body of '{0}' cannot be an iterator block because '{0}' returns by reference
dotnet_diagnostic.cs8155.severity = error                                                           # CS8155: Lambda expressions that return by reference cannot be converted to expression trees
dotnet_diagnostic.cs8156.severity = error                                                           # CS8156: An expression cannot be used in this context because it may not be passed or returned by reference
dotnet_diagnostic.cs8157.severity = error                                                           # CS8157: Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference
dotnet_diagnostic.cs8158.severity = error                                                           # CS8158: Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference
dotnet_diagnostic.cs8159.severity = error                                                           # CS8159: Cannot return the range variable '{0}' by reference
dotnet_diagnostic.cs8160.severity = error                                                           # CS8160: A readonly field cannot be returned by writable reference
dotnet_diagnostic.cs8161.severity = error                                                           # CS8161: A static readonly field cannot be returned by writable reference
dotnet_diagnostic.cs8162.severity = error                                                           # CS8162: Members of readonly field '{0}' cannot be returned by writable reference
dotnet_diagnostic.cs8163.severity = error                                                           # CS8163: Fields of static readonly field '{0}' cannot be returned by writable reference
dotnet_diagnostic.cs8166.severity = error                                                           # CS8166: Cannot return a parameter by reference '{0}' because it is not a ref parameter
dotnet_diagnostic.cs8167.severity = error                                                           # CS8167: Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter
dotnet_diagnostic.cs8168.severity = error                                                           # CS8168: Cannot return local '{0}' by reference because it is not a ref local
dotnet_diagnostic.cs8169.severity = error                                                           # CS8169: Cannot return a member of local '{0}' by reference because it is not a ref local
dotnet_diagnostic.cs8170.severity = error                                                           # CS8170: Struct members cannot return 'this' or other instance members by reference
dotnet_diagnostic.cs8171.severity = error                                                           # CS8171: Cannot initialize a by-value variable with a reference
dotnet_diagnostic.cs8172.severity = error                                                           # CS8172: Cannot initialize a by-reference variable with a value
dotnet_diagnostic.cs8173.severity = error                                                           # CS8173: The expression must be of type '{0}' because it is being assigned by reference
dotnet_diagnostic.cs8174.severity = error                                                           # CS8174: A declaration of a by-reference variable must have an initializer
dotnet_diagnostic.cs8175.severity = error                                                           # CS8175: Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression
dotnet_diagnostic.cs8178.severity = error                                                           # CS8178: A reference returned by a call to '{0}' cannot be preserved across 'await' or 'yield' boundary.
dotnet_diagnostic.cs8179.severity = error                                                           # CS8179: Predefined type '{0}' is not defined or imported
dotnet_diagnostic.cs8180.severity = error                                                           # CS8180: { or ; or => expected
dotnet_diagnostic.cs8181.severity = error                                                           # CS8181: 'new' cannot be used with tuple type. Use a tuple literal expression instead.
dotnet_diagnostic.cs8182.severity = error                                                           # CS8182: Predefined type '{0}' must be a struct.
dotnet_diagnostic.cs8183.severity = error                                                           # CS8183: Cannot infer the type of implicitly-typed discard.
dotnet_diagnostic.cs8185.severity = error                                                           # CS8185: A declaration is not allowed in this context.
dotnet_diagnostic.cs8186.severity = error                                                           # CS8186: A foreach loop must declare its iteration variables.
dotnet_diagnostic.cs8187.severity = error                                                           # CS8187: Tuple element names are not permitted on the left of a deconstruction.
dotnet_diagnostic.cs8188.severity = error                                                           # CS8188: An expression tree may not contain a throw-expression.
dotnet_diagnostic.cs8189.severity = error                                                           # CS8189: Ref mismatch between '{0}' and delegate '{1}'
dotnet_diagnostic.cs8190.severity = error                                                           # CS8190: Provided source code kind is unsupported or invalid: '{0}'
dotnet_diagnostic.cs8191.severity = error                                                           # CS8191: Provided documentation mode is unsupported or invalid: '{0}'.
dotnet_diagnostic.cs8192.severity = error                                                           # CS8192: Provided language version is unsupported or invalid: '{0}'.
dotnet_diagnostic.cs8196.severity = error                                                           # CS8196: Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.
dotnet_diagnostic.cs8197.severity = error                                                           # CS8197: Cannot infer the type of implicitly-typed out variable '{0}'.
dotnet_diagnostic.cs8198.severity = error                                                           # CS8198: An expression tree may not contain an out argument variable declaration.
dotnet_diagnostic.cs8199.severity = error                                                           # CS8199: The syntax 'var (...)' as an lvalue is reserved.
dotnet_diagnostic.cs8202.severity = error                                                           # CS8202: Public signing is not supported for netmodules.
dotnet_diagnostic.cs8203.severity = error                                                           # CS8203: Invalid assembly name: {0}
dotnet_diagnostic.cs8204.severity = error                                                           # CS8204: For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.
dotnet_diagnostic.cs8206.severity = error                                                           # CS8206: Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.
dotnet_diagnostic.cs8207.severity = error                                                           # CS8207: An expression tree may not contain a discard.
dotnet_diagnostic.cs8208.severity = error                                                           # CS8208: It is not legal to use the type 'dynamic' in a pattern.
dotnet_diagnostic.cs8209.severity = error                                                           # CS8209: A value of type 'void' may not be assigned.
dotnet_diagnostic.cs8210.severity = error                                                           # CS8210: A tuple may not contain a value of type 'void'.
dotnet_diagnostic.cs8300.severity = error                                                           # CS8300: Merge conflict marker encountered
dotnet_diagnostic.cs8301.severity = error                                                           # CS8301: Invalid name for a preprocessing symbol; '{0}' is not a valid identifier
dotnet_diagnostic.cs8302.severity = error                                                           # CS8302: Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.
dotnet_diagnostic.cs8303.severity = error                                                           # CS8303: Specified language version '{0}' cannot have leading zeroes
dotnet_diagnostic.cs8304.severity = error                                                           # CS8304: Compiler version: '{0}'. Language version: {1}.
dotnet_diagnostic.cs8305.severity = warning                                                         # CS8305: '{0}' is for evaluation purposes only and is subject to change or removal in future updates.
dotnet_diagnostic.cs8306.severity = error                                                           # CS8306: Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.
dotnet_diagnostic.cs8307.severity = error                                                           # CS8307: The first operand of an 'as' operator may not be a tuple literal without a natural type.
dotnet_diagnostic.cs8308.severity = error                                                           # CS8308: Do not use refout when using refonly.
dotnet_diagnostic.cs8309.severity = error                                                           # CS8309: Cannot compile net modules when using /refout or /refonly.
dotnet_diagnostic.cs8310.severity = error                                                           # CS8310: Operator '{0}' cannot be applied to operand '{1}'
dotnet_diagnostic.cs8312.severity = error                                                           # CS8312: Use of default literal is not valid in this context
dotnet_diagnostic.cs8314.severity = error                                                           # CS8314: An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.
dotnet_diagnostic.cs8315.severity = error                                                           # CS8315: Operator '{0}' is ambiguous on operands '{1}' and '{2}'
dotnet_diagnostic.cs8320.severity = error                                                           # CS8320: Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.
dotnet_diagnostic.cs8321.severity = warning                                                         # CS8321: The local function '{0}' is declared but never used
dotnet_diagnostic.cs8322.severity = error                                                           # CS8322: Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.
dotnet_diagnostic.cs8323.severity = error                                                           # CS8323: Named argument '{0}' is used out-of-position but is followed by an unnamed argument
dotnet_diagnostic.cs8324.severity = error                                                           # CS8324: Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.
dotnet_diagnostic.cs8325.severity = error                                                           # CS8325: 'await' cannot be used in an expression containing a ref conditional operator
dotnet_diagnostic.cs8326.severity = error                                                           # CS8326: Both conditional operator values must be ref values or neither may be a ref value
dotnet_diagnostic.cs8327.severity = error                                                           # CS8327: The expression must be of type '{0}' to match the alternative ref value
dotnet_diagnostic.cs8328.severity = error                                                           # CS8328: The parameter modifier '{0}' cannot be used with '{1}'
dotnet_diagnostic.cs8329.severity = error                                                           # CS8329: Cannot use {0} '{1}' as a ref or out value because it is a readonly variable
dotnet_diagnostic.cs8330.severity = error                                                           # CS8330: Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable
dotnet_diagnostic.cs8331.severity = error                                                           # CS8331: Cannot assign to {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable
dotnet_diagnostic.cs8332.severity = error                                                           # CS8332: Cannot assign to a member of {0} '{1}' or use it as the right hand side of a ref assignment because it is a readonly variable
dotnet_diagnostic.cs8333.severity = error                                                           # CS8333: Cannot return {0} '{1}' by writable reference because it is a readonly variable
dotnet_diagnostic.cs8334.severity = error                                                           # CS8334: Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable
dotnet_diagnostic.cs8335.severity = error                                                           # CS8335: Do not use '{0}'. This is reserved for compiler usage.
dotnet_diagnostic.cs8336.severity = error                                                           # CS8336: The type name '{0}' is reserved to be used by the compiler.
dotnet_diagnostic.cs8337.severity = error                                                           # CS8337: The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.
dotnet_diagnostic.cs8338.severity = error                                                           # CS8338: The first 'in' or 'ref readonly' parameter of the extension method '{0}' must be a concrete (non-generic) value type.
dotnet_diagnostic.cs8340.severity = error                                                           # CS8340: Instance fields of readonly structs must be readonly.
dotnet_diagnostic.cs8341.severity = error                                                           # CS8341: Auto-implemented instance properties in readonly structs must be readonly.
dotnet_diagnostic.cs8342.severity = error                                                           # CS8342: Field-like events are not allowed in readonly structs.
dotnet_diagnostic.cs8345.severity = error                                                           # CS8345: Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.
dotnet_diagnostic.cs8346.severity = error                                                           # CS8346: Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.
dotnet_diagnostic.cs8347.severity = error                                                           # CS8347: Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope
dotnet_diagnostic.cs8348.severity = error                                                           # CS8348: Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope
dotnet_diagnostic.cs8349.severity = error                                                           # CS8349: Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope
dotnet_diagnostic.cs8350.severity = error                                                           # CS8350: This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope
dotnet_diagnostic.cs8351.severity = error                                                           # CS8351: Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes
dotnet_diagnostic.cs8352.severity = error                                                           # CS8352: Cannot use variable '{0}' in this context because it may expose referenced variables outside of their declaration scope
dotnet_diagnostic.cs8353.severity = error                                                           # CS8353: A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method
dotnet_diagnostic.cs8354.severity = error                                                           # CS8354: Cannot return 'this' by reference.
dotnet_diagnostic.cs8355.severity = error                                                           # CS8355: An in parameter cannot have the Out attribute.
dotnet_diagnostic.cs8356.severity = error                                                           # CS8356: Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'
dotnet_diagnostic.cs8357.severity = error                                                           # CS8357: The specified version string '{0}' contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation
dotnet_diagnostic.cs8358.severity = error                                                           # CS8358: Cannot use attribute constructor '{0}' because it has 'in' or 'ref readonly' parameters.
dotnet_diagnostic.cs8359.severity = warning                                                         # CS8359: Filter expression is a constant 'false', consider removing the catch clause
dotnet_diagnostic.cs8360.severity = warning                                                         # CS8360: Filter expression is a constant 'false', consider removing the try-catch block
dotnet_diagnostic.cs8361.severity = error                                                           # CS8361: A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.
dotnet_diagnostic.cs8362.severity = error                                                           # CS8362: __arglist cannot have an argument of void type
dotnet_diagnostic.cs8364.severity = error                                                           # CS8364: Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.
dotnet_diagnostic.cs8370.severity = error                                                           # CS8370: Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.
dotnet_diagnostic.cs8371.severity = warning                                                         # CS8371: Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.
dotnet_diagnostic.cs8372.severity = error                                                           # CS8372: Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property
dotnet_diagnostic.cs8373.severity = error                                                           # CS8373: The left-hand side of a ref assignment must be a ref variable.
dotnet_diagnostic.cs8374.severity = error                                                           # CS8374: Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.
dotnet_diagnostic.cs8375.severity = error                                                           # CS8375: The 'new()' constraint cannot be used with the 'unmanaged' constraint
dotnet_diagnostic.cs8377.severity = error                                                           # CS8377: The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'
dotnet_diagnostic.cs8378.severity = error                                                           # CS8378: __arglist cannot have an argument passed by 'in' or 'out'
dotnet_diagnostic.cs8379.severity = error                                                           # CS8379: Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'
dotnet_diagnostic.cs8380.severity = error                                                           # CS8380: '{0}': cannot specify both a constraint class and the 'unmanaged' constraint
dotnet_diagnostic.cs8381.severity = error                                                           # CS8381: "Invalid rank specifier: expected ']'
dotnet_diagnostic.cs8382.severity = error                                                           # CS8382: An expression tree may not contain a tuple == or != operator
dotnet_diagnostic.cs8383.severity = warning                                                         # CS8383: Tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator
dotnet_diagnostic.cs8384.severity = error                                                           # CS8384: Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.
dotnet_diagnostic.cs8385.severity = error                                                           # CS8385: The given expression cannot be used in a fixed statement
dotnet_diagnostic.cs8386.severity = error                                                           # CS8386: Invalid object creation
dotnet_diagnostic.cs8387.severity = warning                                                         # CS8387: Type parameter '{0}' has the same name as the type parameter from outer method '{1}'
dotnet_diagnostic.cs8388.severity = error                                                           # CS8388: An out variable cannot be declared as a ref local
dotnet_diagnostic.cs8389.severity = error                                                           # CS8389: Omitting the type argument is not allowed in the current context
dotnet_diagnostic.cs8400.severity = error                                                           # CS8400: Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.
dotnet_diagnostic.cs8401.severity = error                                                           # CS8401: To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.
dotnet_diagnostic.cs8403.severity = error                                                           # CS8403: Method '{0}' with an iterator block must be 'async' to return '{1}'
dotnet_diagnostic.cs8410.severity = error                                                           # CS8410: '{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
dotnet_diagnostic.cs8411.severity = error                                                           # CS8411: Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'
dotnet_diagnostic.cs8412.severity = error                                                           # CS8412: Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property
dotnet_diagnostic.cs8413.severity = error                                                           # CS8413: Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation
dotnet_diagnostic.cs8414.severity = error                                                           # CS8414: foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?
dotnet_diagnostic.cs8415.severity = error                                                           # CS8415: Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?
dotnet_diagnostic.cs8416.severity = error                                                           # CS8416: Cannot use a collection of dynamic type in an asynchronous foreach
dotnet_diagnostic.cs8417.severity = error                                                           # CS8417: '{0}': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?
dotnet_diagnostic.cs8418.severity = error                                                           # CS8418: '{0}': type used in a using statement must implement 'System.IDisposable'. Did you mean 'await using' rather than 'using'?
dotnet_diagnostic.cs8419.severity = error                                                           # CS8419: The body of an async-iterator method must contain a 'yield' statement.
dotnet_diagnostic.cs8420.severity = error                                                           # CS8420: The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.
dotnet_diagnostic.cs8421.severity = error                                                           # CS8421: A static local function cannot contain a reference to '{0}'.
dotnet_diagnostic.cs8422.severity = error                                                           # CS8422: A static local function cannot contain a reference to 'this' or 'base'.
dotnet_diagnostic.cs8423.severity = error                                                           # CS8423: Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.
dotnet_diagnostic.cs8424.severity = warning                                                         # CS8424: The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable
dotnet_diagnostic.cs8425.severity = warning                                                         # CS8425: Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable<>.GetAsyncEnumerator' will be unconsumed
dotnet_diagnostic.cs8426.severity = error                                                           # CS8426: The attribute [EnumeratorCancellation] cannot be used on multiple parameters
dotnet_diagnostic.cs8427.severity = error                                                           # CS8427: Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.
dotnet_diagnostic.cs8428.severity = error                                                           # CS8428: Invocation of implicit Index Indexer cannot name the argument.
dotnet_diagnostic.cs8429.severity = error                                                           # CS8429: Invocation of implicit Range Indexer cannot name the argument.
dotnet_diagnostic.cs8500.severity = warning                                                         # CS8500: This takes the address of, gets the size of, or declares a pointer to a managed type
dotnet_diagnostic.cs8502.severity = error                                                           # CS8502: Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.
dotnet_diagnostic.cs8503.severity = error                                                           # CS8503: A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'
dotnet_diagnostic.cs8504.severity = error                                                           # CS8504: Pattern missing
dotnet_diagnostic.cs8505.severity = error                                                           # CS8505: A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.
dotnet_diagnostic.cs8506.severity = error                                                           # CS8506: No best type was found for the switch expression.
dotnet_diagnostic.cs8508.severity = error                                                           # CS8508: The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.
dotnet_diagnostic.cs8509.severity = warning                                                         # CS8509: Switch expression does not handle all possible values of its input type
dotnet_diagnostic.cs8510.severity = error                                                           # CS8510: The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.
dotnet_diagnostic.cs8511.severity = error                                                           # CS8511: An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.
dotnet_diagnostic.cs8512.severity = warning                                                         # CS8512: The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.
dotnet_diagnostic.cs8513.severity = warning                                                         # CS8513: The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.
dotnet_diagnostic.cs8514.severity = error                                                           # CS8514: An expression tree may not contain a switch expression.
dotnet_diagnostic.cs8515.severity = error                                                           # CS8515: Parentheses are required around the switch governing expression.
dotnet_diagnostic.cs8516.severity = error                                                           # CS8516: The name '{0}' does not identify tuple element '{1}'.
dotnet_diagnostic.cs8517.severity = error                                                           # CS8517: The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.
dotnet_diagnostic.cs8518.severity = error                                                           # CS8518: An expression of type '{0}' can never match the provided pattern.
dotnet_diagnostic.cs8519.severity = warning                                                         # CS8519: The given expression never matches the provided pattern.
dotnet_diagnostic.cs8520.severity = warning                                                         # CS8520: The given expression always matches the provided constant.
dotnet_diagnostic.cs8521.severity = error                                                           # CS8521: Pattern-matching is not permitted for pointer types.
dotnet_diagnostic.cs8522.severity = error                                                           # CS8522: Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.
dotnet_diagnostic.cs8523.severity = error                                                           # CS8523: The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.
dotnet_diagnostic.cs8524.severity = warning                                                         # CS8524: The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.
dotnet_diagnostic.cs8597.severity = warning                                                         # CS8597: Thrown value may be null.
dotnet_diagnostic.cs8598.severity = error                                                           # CS8598: The suppression operator is not allowed in this context
dotnet_diagnostic.cs8600.severity = warning                                                         # CS8600: Converting null literal or possible null value to non-nullable type.
dotnet_diagnostic.cs8601.severity = warning                                                         # CS8601: Possible null reference assignment.
dotnet_diagnostic.cs8602.severity = warning                                                         # CS8602: Dereference of a possibly null reference.
dotnet_diagnostic.cs8603.severity = warning                                                         # CS8603: Possible null reference return.
dotnet_diagnostic.cs8604.severity = warning                                                         # CS8604: Possible null reference argument for parameter '{0}' in '{1}'.
dotnet_diagnostic.cs8605.severity = warning                                                         # CS8605: Unboxing a possibly null value.
dotnet_diagnostic.cs8607.severity = warning                                                         # CS8607: A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]
dotnet_diagnostic.cs8608.severity = warning                                                         # CS8608: Nullability of reference types in type doesn't match overridden member.
dotnet_diagnostic.cs8609.severity = warning                                                         # CS8609: Nullability of reference types in return type doesn't match overridden member.
dotnet_diagnostic.cs8610.severity = warning                                                         # CS8610: Nullability of reference types in type of parameter '{0}' doesn't match overridden member.
dotnet_diagnostic.cs8611.severity = warning                                                         # CS8611: Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.
dotnet_diagnostic.cs8612.severity = warning                                                         # CS8612: Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.
dotnet_diagnostic.cs8613.severity = warning                                                         # CS8613: Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.
dotnet_diagnostic.cs8614.severity = warning                                                         # CS8614: Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.
dotnet_diagnostic.cs8615.severity = warning                                                         # CS8615: Nullability of reference types in type doesn't match implemented member '{0}'.
dotnet_diagnostic.cs8616.severity = warning                                                         # CS8616: Nullability of reference types in return type doesn't match implemented member '{0}'.
dotnet_diagnostic.cs8617.severity = warning                                                         # CS8617: Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.
dotnet_diagnostic.cs8618.severity = warning                                                         # CS8618: Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring the {0} as nullable.
dotnet_diagnostic.cs8619.severity = warning                                                         # CS8619: Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.
dotnet_diagnostic.cs8620.severity = warning                                                         # CS8620: Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.
dotnet_diagnostic.cs8621.severity = warning                                                         # CS8621: Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8622.severity = warning                                                         # CS8622: Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8623.severity = error                                                           # CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
dotnet_diagnostic.cs8624.severity = warning                                                         # CS8624: Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.
dotnet_diagnostic.cs8625.severity = warning                                                         # CS8625: Cannot convert null literal to non-nullable reference type.
dotnet_diagnostic.cs8627.severity = error                                                           # CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.
dotnet_diagnostic.cs8628.severity = error                                                           # CS8628: Cannot use a nullable reference type in object creation.
dotnet_diagnostic.cs8629.severity = warning                                                         # CS8629: Nullable value type may be null.
dotnet_diagnostic.cs8630.severity = error                                                           # CS8630: Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater.
dotnet_diagnostic.cs8631.severity = warning                                                         # CS8631: The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.
dotnet_diagnostic.cs8632.severity = warning                                                         # CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
dotnet_diagnostic.cs8633.severity = warning                                                         # CS8633: Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.
dotnet_diagnostic.cs8634.severity = warning                                                         # CS8634: The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.
dotnet_diagnostic.cs8635.severity = error                                                           # CS8635: Unexpected character sequence '...'
dotnet_diagnostic.cs8636.severity = error                                                           # CS8636: Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'
dotnet_diagnostic.cs8637.severity = error                                                           # CS8637: Expected 'enable', 'disable', or 'restore'
dotnet_diagnostic.cs8639.severity = error                                                           # CS8639: The typeof operator cannot be used on a nullable reference type
dotnet_diagnostic.cs8640.severity = error                                                           # CS8640: Expression tree cannot contain value of ref struct or restricted type '{0}'.
dotnet_diagnostic.cs8641.severity = error                                                           # CS8641: 'else' cannot start a statement.
dotnet_diagnostic.cs8642.severity = error                                                           # CS8642: An expression tree may not contain a null coalescing assignment
dotnet_diagnostic.cs8643.severity = warning                                                         # CS8643: Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.
dotnet_diagnostic.cs8644.severity = warning                                                         # CS8644: '{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match.
dotnet_diagnostic.cs8645.severity = warning                                                         # CS8645: '{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.
dotnet_diagnostic.cs8646.severity = error                                                           # CS8646: '{0}' is explicitly implemented more than once.
dotnet_diagnostic.cs8647.severity = error                                                           # CS8647: A using variable cannot be used directly within a switch section (consider using braces).
dotnet_diagnostic.cs8648.severity = error                                                           # CS8648: A goto cannot jump to a location after a using declaration.
dotnet_diagnostic.cs8649.severity = error                                                           # CS8649: A goto cannot jump to a location before a using declaration within the same block.
dotnet_diagnostic.cs8650.severity = error                                                           # CS8650: It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.
dotnet_diagnostic.cs8651.severity = error                                                           # CS8651: It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.
dotnet_diagnostic.cs8652.severity = error                                                           # CS8652: The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
dotnet_diagnostic.cs8655.severity = warning                                                         # CS8655: The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.
dotnet_diagnostic.cs8656.severity = warning                                                         # CS8656: Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.
dotnet_diagnostic.cs8657.severity = error                                                           # CS8657: Static member '{0}' cannot be marked 'readonly'.
dotnet_diagnostic.cs8658.severity = error                                                           # CS8658: Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.
dotnet_diagnostic.cs8659.severity = error                                                           # CS8659: Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.
dotnet_diagnostic.cs8660.severity = error                                                           # CS8660: Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.
dotnet_diagnostic.cs8661.severity = error                                                           # CS8661: Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.
dotnet_diagnostic.cs8662.severity = error                                                           # CS8662: Field-like event '{0}' cannot be 'readonly'.
dotnet_diagnostic.cs8663.severity = error                                                           # CS8663: Both partial member declarations must be readonly or neither may be readonly
dotnet_diagnostic.cs8664.severity = error                                                           # CS8664: '{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor
dotnet_diagnostic.cs8665.severity = error                                                           # CS8665: Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.
dotnet_diagnostic.cs8666.severity = error                                                           # CS8666: Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.
dotnet_diagnostic.cs8667.severity = warning                                                         # CS8667: Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'
dotnet_diagnostic.cs8668.severity = error                                                           # CS8668: Expected 'warnings', 'annotations', or end of directive
dotnet_diagnostic.cs8669.severity = warning                                                         # CS8669: The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.
dotnet_diagnostic.cs8670.severity = warning                                                         # CS8670: Object or collection initializer implicitly dereferences possibly null member '{0}'.
dotnet_diagnostic.cs8700.severity = error                                                           # CS8700: Multiple analyzer config files cannot be in the same directory ('{0}').
dotnet_diagnostic.cs8701.severity = error                                                           # CS8701: Target runtime doesn't support default interface implementation.
dotnet_diagnostic.cs8702.severity = error                                                           # CS8702: '{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.
dotnet_diagnostic.cs8703.severity = error                                                           # CS8703: The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.
dotnet_diagnostic.cs8704.severity = error                                                           # CS8704: '{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.
dotnet_diagnostic.cs8705.severity = error                                                           # CS8705: Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.
dotnet_diagnostic.cs8706.severity = error                                                           # CS8706: '{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.
dotnet_diagnostic.cs8707.severity = error                                                           # CS8707: Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.
dotnet_diagnostic.cs8711.severity = error                                                           # CS8711: Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs8712.severity = error                                                           # CS8712: '{0}': abstract event cannot use event accessor syntax
dotnet_diagnostic.cs8714.severity = warning                                                         # CS8714: The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.
dotnet_diagnostic.cs8715.severity = error                                                           # CS8715: Duplicate null suppression operator ('!')
dotnet_diagnostic.cs8716.severity = error                                                           # CS8716: There is no target type for the default literal.
dotnet_diagnostic.cs8750.severity = error                                                           # CS8750: Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.
dotnet_diagnostic.cs8751.severity = error                                                           # CS8751: Internal error in the C# compiler.
dotnet_diagnostic.cs8752.severity = error                                                           # CS8752: The type '{0}' may not be used as the target type of new()
dotnet_diagnostic.cs8753.severity = error                                                           # CS8753: Use of new() is not valid in this context
dotnet_diagnostic.cs8754.severity = error                                                           # CS8754: There is no target type for '{0}'
dotnet_diagnostic.cs8755.severity = error                                                           # CS8755: '{0}' cannot be used as a modifier on a function pointer parameter.
dotnet_diagnostic.cs8756.severity = error                                                           # CS8756: Function pointer '{0}' does not take {1} arguments
dotnet_diagnostic.cs8757.severity = error                                                           # CS8757: No overload for '{0}' matches function pointer '{1}'
dotnet_diagnostic.cs8758.severity = error                                                           # CS8758: Ref mismatch between '{0}' and function pointer '{1}'
dotnet_diagnostic.cs8759.severity = error                                                           # CS8759: Cannot create a function pointer for '{0}' because it is not a static method
dotnet_diagnostic.cs8760.severity = error                                                           # CS8760: '{0}': extern event cannot have initializer
dotnet_diagnostic.cs8761.severity = error                                                           # CS8761: Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type
dotnet_diagnostic.cs8762.severity = warning                                                         # CS8762: Parameter '{0}' must have a non-null value when exiting with '{1}'.
dotnet_diagnostic.cs8763.severity = warning                                                         # CS8763: A method marked [DoesNotReturn] should not return.
dotnet_diagnostic.cs8764.severity = warning                                                         # CS8764: Nullability of return type doesn't match overridden member (possibly because of nullability attributes).
dotnet_diagnostic.cs8765.severity = warning                                                         # CS8765: Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).
dotnet_diagnostic.cs8766.severity = warning                                                         # CS8766: Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8767.severity = warning                                                         # CS8767: Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8768.severity = warning                                                         # CS8768: Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8769.severity = warning                                                         # CS8769: Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).
dotnet_diagnostic.cs8770.severity = warning                                                         # CS8770: Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.
dotnet_diagnostic.cs8771.severity = error                                                           # CS8771: Output directory could not be determined
dotnet_diagnostic.cs8772.severity = error                                                           # CS8772: stdin argument '-' is specified, but input has not been redirected from the standard input stream.
dotnet_diagnostic.cs8773.severity = error                                                           # CS8773: Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.
dotnet_diagnostic.cs8774.severity = warning                                                         # CS8774: Member '{0}' must have a non-null value when exiting.
dotnet_diagnostic.cs8775.severity = warning                                                         # CS8775: Member '{0}' must have a non-null value when exiting with '{1}'.
dotnet_diagnostic.cs8776.severity = warning                                                         # CS8776: Member '{0}' cannot be used in this attribute.
dotnet_diagnostic.cs8777.severity = warning                                                         # CS8777: Parameter '{0}' must have a non-null value when exiting.
dotnet_diagnostic.cs8778.severity = warning                                                         # CS8778: Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)
dotnet_diagnostic.cs8779.severity = error                                                           # CS8779: '{0}' is already listed in the interface list on type '{2}' as '{1}'.
dotnet_diagnostic.cs8780.severity = error                                                           # CS8780: A variable may not be declared within a 'not' or 'or' pattern.
dotnet_diagnostic.cs8781.severity = error                                                           # CS8781: Relational patterns may not be used for a value of type '{0}'.
dotnet_diagnostic.cs8782.severity = error                                                           # CS8782: Relational patterns may not be used for a floating-point NaN.
dotnet_diagnostic.cs8783.severity = error                                                           # CS8783: Local function '{0}' must be 'static' in order to use the Conditional attribute
dotnet_diagnostic.cs8784.severity = warning                                                         # CS8784: Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'
dotnet_diagnostic.cs8785.severity = warning                                                         # CS8785: Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'
dotnet_diagnostic.cs8786.severity = error                                                           # CS8786: Calling convention of '{0}' is not compatible with '{1}'.
dotnet_diagnostic.cs8787.severity = error                                                           # CS8787: Cannot convert method group to function pointer (Are you missing a '&'?)
dotnet_diagnostic.cs8788.severity = error                                                           # CS8788: Cannot use an extension method with a receiver as the target of a '&' operator.
dotnet_diagnostic.cs8789.severity = error                                                           # CS8789: The type of a local declared in a fixed statement cannot be a function pointer type.
dotnet_diagnostic.cs8790.severity = error                                                           # CS8790: An expression tree may not contain a pattern System.Index or System.Range indexer access
dotnet_diagnostic.cs8791.severity = error                                                           # CS8791: An expression tree may not contain a from-end index ('^') expression.
dotnet_diagnostic.cs8792.severity = error                                                           # CS8792: An expression tree may not contain a range ('..') expression.
dotnet_diagnostic.cs8793.severity = warning                                                         # CS8793: The given expression always matches the provided pattern.
dotnet_diagnostic.cs8794.severity = warning                                                         # CS8794: An expression of type '{0}' always matches the provided pattern.
dotnet_diagnostic.cs8795.severity = error                                                           # CS8795: Partial method '{0}' must have an implementation part because it has accessibility modifiers.
dotnet_diagnostic.cs8796.severity = error                                                           # CS8796: Partial method '{0}' must have accessibility modifiers because it has a non-void return type.
dotnet_diagnostic.cs8797.severity = error                                                           # CS8797: Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.
dotnet_diagnostic.cs8798.severity = error                                                           # CS8798: Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.
dotnet_diagnostic.cs8799.severity = error                                                           # CS8799: Both partial member declarations must have identical accessibility modifiers.
dotnet_diagnostic.cs8800.severity = error                                                           # CS8800: Both partial member declarations must have identical combinations of 'virtual', 'override', 'sealed', and 'new' modifiers.
dotnet_diagnostic.cs8801.severity = error                                                           # CS8801: Cannot use local variable or local function '{0}' declared in a top-level statement in this context.
dotnet_diagnostic.cs8802.severity = error                                                           # CS8802: Only one compilation unit can have top-level statements.
dotnet_diagnostic.cs8803.severity = error                                                           # CS8803: Top-level statements must precede namespace and type declarations.
dotnet_diagnostic.cs8805.severity = error                                                           # CS8805: Program using top-level statements must be an executable.
dotnet_diagnostic.cs8806.severity = error                                                           # CS8806: The calling convention of '{0}' is not supported by the language.
dotnet_diagnostic.cs8807.severity = error                                                           # CS8807: '{0}' is not a valid calling convention specifier for a function pointer.
dotnet_diagnostic.cs8808.severity = error                                                           # CS8808: '{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.
dotnet_diagnostic.cs8809.severity = error                                                           # CS8809: A return type can only have one '{0}' modifier.
dotnet_diagnostic.cs8810.severity = error                                                           # CS8810: '&' on method groups cannot be used in expression trees
dotnet_diagnostic.cs8811.severity = error                                                           # CS8811: Cannot convert &method group '{0}' to delegate type '{1}'.
dotnet_diagnostic.cs8812.severity = error                                                           # CS8812: Cannot convert &method group '{0}' to non-function pointer type '{1}'.
dotnet_diagnostic.cs8813.severity = error                                                           # CS8813: A module initializer must be an ordinary member method
dotnet_diagnostic.cs8814.severity = error                                                           # CS8814: Module initializer method '{0}' must be accessible at the module level
dotnet_diagnostic.cs8815.severity = error                                                           # CS8815: Module initializer method '{0}' must be static, and non-virtual, must have no parameters, and must return 'void'
dotnet_diagnostic.cs8816.severity = error                                                           # CS8816: Module initializer method '{0}' must not be generic and must not be contained in a generic type
dotnet_diagnostic.cs8817.severity = error                                                           # CS8817: Both partial method declarations must have the same return type.
dotnet_diagnostic.cs8818.severity = error                                                           # CS8818: Partial member declarations must have matching ref return values.
dotnet_diagnostic.cs8819.severity = warning                                                         # CS8819: Nullability of reference types in return type doesn't match partial method declaration.
dotnet_diagnostic.cs8820.severity = error                                                           # CS8820: A static anonymous function cannot contain a reference to '{0}'.
dotnet_diagnostic.cs8821.severity = error                                                           # CS8821: A static anonymous function cannot contain a reference to 'this' or 'base'.
dotnet_diagnostic.cs8822.severity = error                                                           # CS8822: Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.
dotnet_diagnostic.cs8823.severity = error                                                           # CS8823: The 'default' constraint is valid on override and explicit interface implementation methods only.
dotnet_diagnostic.cs8824.severity = warning                                                         # CS8824: Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.
dotnet_diagnostic.cs8825.severity = warning                                                         # CS8825: Return value must be non-null because parameter '{0}' is non-null.
dotnet_diagnostic.cs8826.severity = warning                                                         # CS8826: Partial method declarations '{0}' and '{1}' have signature differences.
dotnet_diagnostic.cs8830.severity = error                                                           # CS8830: '{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'
dotnet_diagnostic.cs8831.severity = error                                                           # CS8831: '{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'
dotnet_diagnostic.cs8846.severity = warning                                                         # CS8846: The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.
dotnet_diagnostic.cs8847.severity = warning                                                         # CS8847: The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.
dotnet_diagnostic.cs8848.severity = warning                                                         # CS8848: Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.
dotnet_diagnostic.cs8849.severity = error                                                           # CS8849: An expression tree may not contain a with-expression.
dotnet_diagnostic.cs8850.severity = warning                                                         # CS8850: The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.
dotnet_diagnostic.cs8851.severity = warning                                                         # CS8851: '{0}' defines 'Equals' but not 'GetHashCode'
dotnet_diagnostic.cs8852.severity = error                                                           # CS8852: Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
dotnet_diagnostic.cs8853.severity = error                                                           # CS8853: '{0}' must match by init-only of overridden member '{1}'
dotnet_diagnostic.cs8854.severity = error                                                           # CS8854: '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.
dotnet_diagnostic.cs8855.severity = error                                                           # CS8855: Accessors '{0}' and '{1}' should both be init-only or neither
dotnet_diagnostic.cs8856.severity = error                                                           # CS8856: The 'init' accessor is not valid on static members
dotnet_diagnostic.cs8857.severity = error                                                           # CS8857: The receiver of a `with` expression must have a non-void type.
dotnet_diagnostic.cs8858.severity = error                                                           # CS8858: The receiver type '{0}' is not a valid record type and is not a struct type.
dotnet_diagnostic.cs8859.severity = error                                                           # CS8859: Members named 'Clone' are disallowed in records.
dotnet_diagnostic.cs8860.severity = warning                                                         # CS8860: Types and aliases should not be named 'record'.
dotnet_diagnostic.cs8861.severity = error                                                           # CS8861: Unexpected argument list.
dotnet_diagnostic.cs8862.severity = error                                                           # CS8862: A constructor declared in a type with parameter list must have 'this' constructor initializer.
dotnet_diagnostic.cs8863.severity = error                                                           # CS8863: Only a single partial type declaration may have a parameter list
dotnet_diagnostic.cs8864.severity = error                                                           # CS8864: Records may only inherit from object or another record
dotnet_diagnostic.cs8865.severity = error                                                           # CS8865: Only records may inherit from records.
dotnet_diagnostic.cs8866.severity = error                                                           # CS8866: Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.
dotnet_diagnostic.cs8867.severity = error                                                           # CS8867: No accessible copy constructor found in base type '{0}'.
dotnet_diagnostic.cs8868.severity = error                                                           # CS8868: A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.
dotnet_diagnostic.cs8869.severity = error                                                           # CS8869: '{0}' does not override expected method from 'object'.
dotnet_diagnostic.cs8870.severity = error                                                           # CS8870: '{0}' cannot be sealed because containing record is not sealed.
dotnet_diagnostic.cs8871.severity = error                                                           # CS8871: '{0}' does not override expected method from '{1}'.
dotnet_diagnostic.cs8872.severity = error                                                           # CS8872: '{0}' must allow overriding because the containing record is not sealed.
dotnet_diagnostic.cs8873.severity = error                                                           # CS8873: Record member '{0}' must be public.
dotnet_diagnostic.cs8874.severity = error                                                           # CS8874: Record member '{0}' must return '{1}'.
dotnet_diagnostic.cs8875.severity = error                                                           # CS8875: Record member '{0}' must be protected.
dotnet_diagnostic.cs8876.severity = error                                                           # CS8876: '{0}' does not override expected property from '{1}'.
dotnet_diagnostic.cs8877.severity = error                                                           # CS8877: Record member '{0}' may not be static.
dotnet_diagnostic.cs8878.severity = error                                                           # CS8878: A copy constructor '{0}' must be public or protected because the record is not sealed.
dotnet_diagnostic.cs8879.severity = error                                                           # CS8879: Record member '{0}' must be private.
dotnet_diagnostic.cs8880.severity = warning                                                         # CS8880: Auto-implemented property '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the property.
dotnet_diagnostic.cs8881.severity = warning                                                         # CS8881: Field '{0}' must be fully assigned before control is returned to the caller. Consider updating to language version '{1}' to auto-default the field.
dotnet_diagnostic.cs8882.severity = warning                                                         # CS8882: The out parameter '{0}' must be assigned to before control leaves the current method
dotnet_diagnostic.cs8883.severity = warning                                                         # CS8883: Use of possibly unassigned auto-implemented property '{0}'
dotnet_diagnostic.cs8884.severity = warning                                                         # CS8884: Use of possibly unassigned field '{0}'
dotnet_diagnostic.cs8885.severity = warning                                                         # CS8885: The 'this' object cannot be used before all of its fields have been assigned. Consider updating to language version '{0}' to auto-default the unassigned fields.
dotnet_diagnostic.cs8886.severity = warning                                                         # CS8886: Use of unassigned out parameter '{0}'
dotnet_diagnostic.cs8887.severity = warning                                                         # CS8887: Use of unassigned local variable '{0}'
dotnet_diagnostic.cs8888.severity = error                                                           # CS8888: 'managed' calling convention cannot be combined with unmanaged calling convention specifiers.
dotnet_diagnostic.cs8889.severity = error                                                           # CS8889: The target runtime doesn't support extensible or runtime-environment default calling conventions.
dotnet_diagnostic.cs8890.severity = error                                                           # CS8890: Type '{0}' is not defined.
dotnet_diagnostic.cs8891.severity = error                                                           # CS8891: Type '{0}' must be public to be used as a calling convention.
dotnet_diagnostic.cs8892.severity = warning                                                         # CS8892: Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.
dotnet_diagnostic.cs8893.severity = error                                                           # CS8893: '{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.
dotnet_diagnostic.cs8894.severity = error                                                           # CS8894: Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.
dotnet_diagnostic.cs8895.severity = error                                                           # CS8895: Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.
dotnet_diagnostic.cs8896.severity = error                                                           # CS8896: 'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract, non-virtual methods or static local functions.
dotnet_diagnostic.cs8897.severity = warning                                                         # CS8897: '{0}': static types cannot be used as parameters
dotnet_diagnostic.cs8898.severity = warning                                                         # CS8898: '{0}': static types cannot be used as return types
dotnet_diagnostic.cs8899.severity = error                                                           # CS8899: Application entry points cannot be attributed with 'UnmanagedCallersOnly'.
dotnet_diagnostic.cs8900.severity = error                                                           # CS8900: Module initializer cannot be attributed with 'UnmanagedCallersOnly'.
dotnet_diagnostic.cs8901.severity = error                                                           # CS8901: '{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.
dotnet_diagnostic.cs8902.severity = error                                                           # CS8902: '{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.
dotnet_diagnostic.cs8903.severity = error                                                           # CS8903: 'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.
dotnet_diagnostic.cs8904.severity = error                                                           # CS8904: Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.
dotnet_diagnostic.cs8905.severity = error                                                           # CS8905: A function pointer cannot be called with named arguments.
dotnet_diagnostic.cs8906.severity = error                                                           # CS8906: Record equality contract property '{0}' must have a get accessor.
dotnet_diagnostic.cs8907.severity = warning                                                         # CS8907: Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?
dotnet_diagnostic.cs8908.severity = error                                                           # CS8908: The type '{0}' may not be used for a field of a record.
dotnet_diagnostic.cs8909.severity = warning                                                         # CS8909: Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.
dotnet_diagnostic.cs8910.severity = error                                                           # CS8910: The primary constructor conflicts with the synthesized copy constructor.
dotnet_diagnostic.cs8911.severity = error                                                           # CS8911: Using a function pointer type in this context is not supported.
dotnet_diagnostic.cs8912.severity = error                                                           # CS8912: Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.
dotnet_diagnostic.cs8913.severity = error                                                           # CS8913: The positional member '{0}' found corresponding to this parameter is hidden.
dotnet_diagnostic.cs8914.severity = error                                                           # CS8914: A global using directive cannot be used in a namespace declaration.
dotnet_diagnostic.cs8915.severity = error                                                           # CS8915: A global using directive must precede all non-global using directives.
dotnet_diagnostic.cs8916.severity = error                                                           # CS8916: Attributes on lambda expressions require a parenthesized parameter list.
dotnet_diagnostic.cs8917.severity = error                                                           # CS8917: The delegate type could not be inferred.
dotnet_diagnostic.cs8918.severity = error                                                           # CS8918: Identifier or a simple member access expected.
dotnet_diagnostic.cs8919.severity = error                                                           # CS8919: Target runtime doesn't support static abstract members in interfaces.
dotnet_diagnostic.cs8920.severity = error                                                           # CS8920: The interface '{0}' cannot be used as type argument. Static member '{1}' does not have a most specific implementation in the interface.
dotnet_diagnostic.cs8921.severity = error                                                           # CS8921: The parameter of a unary operator must be the containing type, or its type parameter constrained to it.
dotnet_diagnostic.cs8922.severity = error                                                           # CS8922: The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it.
dotnet_diagnostic.cs8923.severity = error                                                           # CS8923: The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.
dotnet_diagnostic.cs8924.severity = error                                                           # CS8924: One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.
dotnet_diagnostic.cs8925.severity = error                                                           # CS8925: The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it
dotnet_diagnostic.cs8926.severity = error                                                           # CS8926: A static virtual or abstract interface member can be accessed only on a type parameter.
dotnet_diagnostic.cs8927.severity = error                                                           # CS8927: An expression tree may not contain an access of static virtual or abstract interface member
dotnet_diagnostic.cs8928.severity = error                                                           # CS8928: '{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.
dotnet_diagnostic.cs8929.severity = error                                                           # CS8929: '{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.
dotnet_diagnostic.cs8930.severity = error                                                           # CS8930: Explicit implementation of a user-defined operator '{0}' must be declared static
dotnet_diagnostic.cs8931.severity = error                                                           # CS8931: User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type
dotnet_diagnostic.cs8932.severity = error                                                           # CS8932: 'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'
dotnet_diagnostic.cs8933.severity = warning                                                         # CS8933: The using directive for '{0}' appeared previously as global using
dotnet_diagnostic.cs8934.severity = error                                                           # CS8934: Cannot convert {0} to type '{1}' because the return type does not match the delegate return type
dotnet_diagnostic.cs8935.severity = error                                                           # CS8935: The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.
dotnet_diagnostic.cs8936.severity = error                                                           # CS8936: Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.
dotnet_diagnostic.cs8937.severity = error                                                           # CS8937: At least one top-level statement must be non-empty.
dotnet_diagnostic.cs8938.severity = error                                                           # CS8938: The #line directive value is missing or out of range
dotnet_diagnostic.cs8939.severity = error                                                           # CS8939: The #line directive end position must be greater than or equal to the start position
dotnet_diagnostic.cs8940.severity = error                                                           # CS8940: A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.
dotnet_diagnostic.cs8941.severity = error                                                           # CS8941: Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.
dotnet_diagnostic.cs8942.severity = error                                                           # CS8942: Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.
dotnet_diagnostic.cs8943.severity = error                                                           # CS8943: null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.
dotnet_diagnostic.cs8944.severity = error                                                           # CS8944: '{0}' is not an instance method, the receiver or extension receiver parameter cannot be an interpolated string handler argument.
dotnet_diagnostic.cs8945.severity = error                                                           # CS8945: '{0}' is not a valid parameter name from '{1}'.
dotnet_diagnostic.cs8946.severity = error                                                           # CS8946: '{0}' is not an interpolated string handler type.
dotnet_diagnostic.cs8947.severity = warning                                                         # CS8947: Parameter '{0}' occurs after '{1}' in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string handler parameter after all arguments involved.
dotnet_diagnostic.cs8848.severity = error                                                           # CS8948: InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.
dotnet_diagnostic.cs8849.severity = error                                                           # CS8949: The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.
dotnet_diagnostic.cs8850.severity = error                                                           # CS8950: Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.
dotnet_diagnostic.cs8851.severity = error                                                           # CS8951: Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.
dotnet_diagnostic.cs8852.severity = error                                                           # CS8952: An expression tree may not contain an interpolated string handler conversion.
dotnet_diagnostic.cs8853.severity = error                                                           # CS8953: An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.
dotnet_diagnostic.cs8854.severity = error                                                           # CS8954: Source file can only contain one file-scoped namespace declaration.
dotnet_diagnostic.cs8855.severity = error                                                           # CS8955: Source file can not contain both file-scoped and normal namespace declarations.
dotnet_diagnostic.cs8856.severity = error                                                           # CS8956: File-scoped namespace must precede all other members in a file.
dotnet_diagnostic.cs8857.severity = error                                                           # CS8957: Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.
dotnet_diagnostic.cs8858.severity = error                                                           # CS8958: The parameterless struct constructor must be 'public'.
dotnet_diagnostic.cs8859.severity = error                                                           # CS8959: CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'
dotnet_diagnostic.cs8960.severity = warning                                                         # CS8960: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.
dotnet_diagnostic.cs8961.severity = warning                                                         # CS8961: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.
dotnet_diagnostic.cs8962.severity = warning                                                         # CS8962: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.
dotnet_diagnostic.cs8963.severity = warning                                                         # CS8963: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.
dotnet_diagnostic.cs8964.severity = error                                                           # CS8964: The CallerArgumentExpressionAttribute may only be applied to parameters with default values
dotnet_diagnostic.cs8965.severity = warning                                                         # CS8965: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.
dotnet_diagnostic.cs8966.severity = warning                                                         # CS8966: The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
dotnet_diagnostic.cs8967.severity = error                                                           # CS8967: Newlines inside a non-verbatim interpolated string are not supported in C# {0}. Please use language version {1} or greater.
dotnet_diagnostic.cs8968.severity = error                                                           # CS8968: '{0}': an attribute type argument cannot use type parameters
dotnet_diagnostic.cs8970.severity = error                                                           # CS8970: Type '{0}' cannot be used in this context because it cannot be represented in metadata.
dotnet_diagnostic.cs8971.severity = warning                                                         # CS8971: InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.
dotnet_diagnostic.cs8972.severity = error                                                           # CS8972: A lambda expression with attributes cannot be converted to an expression tree
dotnet_diagnostic.cs8973.severity = warning                                                         # CS8973: The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)
dotnet_diagnostic.cs8974.severity = warning                                                         # CS8974: Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?
dotnet_diagnostic.cs8975.severity = error                                                           # CS8975: The contextual keyword 'var' cannot be used as an explicit lambda return type
dotnet_diagnostic.cs8976.severity = error                                                           # CS8976: Interpolated string handler conversions that reference the instance being indexed cannot be used in indexer member initializers.
dotnet_diagnostic.cs8977.severity = error                                                           # CS8977: Cannot use 'ref', 'in', or 'out' in the signature of a method attributed with 'UnmanagedCallersOnly'.
dotnet_diagnostic.cs8978.severity = error                                                           # CS8978: '{0}' cannot be made nullable.
dotnet_diagnostic.cs8979.severity = error                                                           # CS8979: List patterns may not be used for a value of type '{0}'.
dotnet_diagnostic.cs8980.severity = error                                                           # CS8980: Slice patterns may only be used once and directly inside a list pattern.
dotnet_diagnostic.cs8981.severity = warning                                                         # CS8981: The type name '{0}' only contains lower-cased ascii characters. Such names may become reserved for the language.
dotnet_diagnostic.cs8982.severity = error                                                           # CS8982: A constructor declared in a 'struct' with parameter list must have a 'this' initializer that calls the primary constructor or an explicitly declared constructor.
dotnet_diagnostic.cs8983.severity = error                                                           # CS8983: A 'struct' with field initializers must include an explicitly declared constructor.
dotnet_diagnostic.cs8985.severity = error                                                           # CS8985: List patterns may not be used for a value of type '{0}'. No suitable 'Length' or 'Count' property was found.
dotnet_diagnostic.cs8986.severity = error                                                           # CS8986: The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.
dotnet_diagnostic.cs8987.severity = error                                                           # CS8987: The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.
dotnet_diagnostic.cs8988.severity = error                                                           # CS8988: The 'scoped' modifier of parameter '{0}' doesn't match partial definition.
dotnet_diagnostic.cs8996.severity = error                                                           # CS8996: Raw string literals are not allowed in preprocessor directives.
dotnet_diagnostic.cs8997.severity = error                                                           # CS8997: Unterminated raw string literal.
dotnet_diagnostic.cs8998.severity = error                                                           # CS8998: The raw string literal does not start with enough quote characters to allow this many consecutive quote characters as content.
dotnet_diagnostic.cs8999.severity = error                                                           # CS8999: Line does not start with the same whitespace as the closing line of the raw string literal.
dotnet_diagnostic.cs9000.severity = error                                                           # CS9000: Raw string literal delimiter must be on its own line.
dotnet_diagnostic.cs9001.severity = error                                                           # CS9001: Multi-line raw string literals are only allowed in verbatim interpolated strings.
dotnet_diagnostic.cs9002.severity = error                                                           # CS9002: Multi-line raw string literals must contain at least one line of content.
dotnet_diagnostic.cs9003.severity = error                                                           # CS9003: Line contains different whitespace than the closing line of the raw string literal: '{0}' versus '{1}'
dotnet_diagnostic.cs9004.severity = error                                                           # CS9004: Not enough quotes for raw string literal.
dotnet_diagnostic.cs9005.severity = error                                                           # CS9005: The interpolation must end with the same number of closing braces as the number of '$' characters that the raw string literal started with.
dotnet_diagnostic.cs9006.severity = error                                                           # CS9006: The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive opening braces as content.
dotnet_diagnostic.cs9007.severity = error                                                           # CS9007: The interpolated raw string literal does not start with enough '$' characters to allow this many consecutive closing braces as content.
dotnet_diagnostic.cs9008.severity = error                                                           # CS9008: Sequence of '@' characters is not allowed. A verbatim string or identifier can only have one '@' character and a raw string cannot have any.
dotnet_diagnostic.cs9009.severity = error                                                           # CS9009: String must start with quote character: "
dotnet_diagnostic.cs9010.severity = error                                                           # CS9010: Keyword 'enum' cannot be used as a constraint. Did you mean 'struct, System.Enum'?
dotnet_diagnostic.cs9011.severity = error                                                           # CS9011: Keyword 'delegate' cannot be used as a constraint. Did you mean 'System.Delegate'?
dotnet_diagnostic.cs9012.severity = error                                                           # CS9012: Unexpected keyword 'record'. Did you mean 'record struct' or 'record class'?
dotnet_diagnostic.cs9013.severity = error                                                           # CS9013: A string 'null' constant is not supported as a pattern for '{0}'. Use an empty string instead.
dotnet_diagnostic.cs9014.severity = error                                                           # CS9014: Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.
dotnet_diagnostic.cs9015.severity = error                                                           # CS9015: Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.
dotnet_diagnostic.cs9016.severity = warning                                                         # CS9016: Use of possibly unassigned auto-implemented property '{0}'. Consider updating to language version '{1}' to auto-default the property.
dotnet_diagnostic.cs9017.severity = warning                                                         # CS9017: Use of possibly unassigned field '{0}'. Consider updating to language version '{1}' to auto-default the field.
dotnet_diagnostic.cs9018.severity = warning                                                         # CS9018: Auto-implemented property '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.
dotnet_diagnostic.cs9019.severity = warning                                                         # CS9019: Field '{0}' is read before being explicitly assigned, causing a preceding implicit assignment of 'default'.
dotnet_diagnostic.cs9020.severity = warning                                                         # CS9020: The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.
dotnet_diagnostic.cs9021.severity = warning                                                         # CS9021: Control is returned to caller before auto-implemented property '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.
dotnet_diagnostic.cs9022.severity = warning                                                         # CS9022: Control is returned to caller before field '{0}' is explicitly assigned, causing a preceding implicit assignment of 'default'.
dotnet_diagnostic.cs9023.severity = error                                                           # CS9023: User-defined operator '{0}' cannot be declared checked
dotnet_diagnostic.cs9024.severity = error                                                           # CS9024: An 'implicit' user-defined conversion operator cannot be declared checked
dotnet_diagnostic.cs9025.severity = error                                                           # CS9025: The operator '{0}' requires a matching non-checked version of the operator to also be defined
dotnet_diagnostic.cs9026.severity = error                                                           # CS9026: The input string cannot be converted into the equivalent UTF-8 byte representation. {0}
dotnet_diagnostic.cs9027.severity = error                                                           # CS9027: Unexpected keyword 'unchecked'
dotnet_diagnostic.cs9028.severity = error                                                           # CS9028: The #line span directive requires space before the first parenthesis, before the character offset, and before the file name
dotnet_diagnostic.cs9029.severity = error                                                           # CS9029: Types and aliases cannot be named 'required'.
dotnet_diagnostic.cs9030.severity = error                                                           # CS9030: '{0}' must be required because it overrides required member '{1}'
dotnet_diagnostic.cs9031.severity = error                                                           # CS9031: Required member '{0}' cannot be hidden by '{1}'.
dotnet_diagnostic.cs9032.severity = error                                                           # CS9032: Required member '{0}' cannot be less visible or have a setter less visible than the containing type '{1}'.
dotnet_diagnostic.cs9033.severity = error                                                           # CS9033: Do not use 'System.Runtime.CompilerServices.RequiredMemberAttribute'. Use the 'required' keyword on required fields and properties instead.
dotnet_diagnostic.cs9034.severity = error                                                           # CS9034: Required member '{0}' must be settable.
dotnet_diagnostic.cs9035.severity = error                                                           # CS9035: Required member '{0}' must be set in the object initializer or attribute constructor.
dotnet_diagnostic.cs9036.severity = error                                                           # CS9036: Required member '{0}' must be assigned a value, it cannot use a nested member or collection initializer.
dotnet_diagnostic.cs9037.severity = error                                                           # CS9037: The required members list for '{0}' is malformed and cannot be interpreted.
dotnet_diagnostic.cs9038.severity = error                                                           # CS9038: The required members list for the base type '{0}' is malformed and cannot be interpreted. To use this constructor, apply the 'SetsRequiredMembers' attribute.
dotnet_diagnostic.cs9039.severity = error                                                           # CS9039: This constructor must add 'SetsRequiredMembers' because it chains to a constructor that has that attribute.
dotnet_diagnostic.cs9040.severity = error                                                           # CS9040: '{2}' cannot satisfy the 'new()' constraint on parameter '{1}' in the generic type or or method '{0}' because '{2}' has required members.
dotnet_diagnostic.cs9041.severity = error                                                           # CS9041: '{0}' requires compiler feature '{1}', which is not supported by this version of the C# compiler.
dotnet_diagnostic.cs9042.severity = warning                                                         # CS9042: Required member '{0}' should not be attributed with 'ObsoleteAttribute' unless the containing type is obsolete or all constructors are obsolete.
dotnet_diagnostic.cs9043.severity = error                                                           # CS9043: Ref returning properties cannot be required.
dotnet_diagnostic.cs9044.severity = error                                                           # CS9044: '{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement an inaccessible member.
dotnet_diagnostic.cs9045.severity = error                                                           # CS9045: Required members are not allowed on the top level of a script or submission.
dotnet_diagnostic.cs9046.severity = error                                                           # CS9046: One of the parameters of an equality, or inequality operator declared in interface '{0}' must be a type parameter on '{0}' constrained to '{0}'
dotnet_diagnostic.cs9047.severity = error                                                           # CS9047: Operator '{0}' cannot be applied to operands of type '{1}' and '{2}' that are not UTF-8 byte representations
dotnet_diagnostic.cs9048.severity = error                                                           # CS9048: The 'scoped' modifier can be used for refs and ref struct values only.
dotnet_diagnostic.cs9049.severity = error                                                           # CS9049: A fixed field must not be a ref field.
dotnet_diagnostic.cs9050.severity = error                                                           # CS9050: A ref field cannot refer to a ref struct.
dotnet_diagnostic.cs9051.severity = error                                                           # CS9051: File-local type '{0}' cannot be used in a member signature in non-file-local type '{1}'.
dotnet_diagnostic.cs9052.severity = error                                                           # CS9052: File-local type '{0}' cannot use accessibility modifiers.
dotnet_diagnostic.cs9053.severity = error                                                           # CS9053: File-local type '{0}' cannot be used as a base type of non-file-local type '{1}'.
dotnet_diagnostic.cs9054.severity = error                                                           # CS9054: File-local type '{0}' must be defined in a top level type; '{0}' is a nested type.
dotnet_diagnostic.cs9055.severity = error                                                           # CS9055: File-local type '{0}' cannot be used in a 'global using static' directive.
dotnet_diagnostic.cs9056.severity = error                                                           # CS9056: Types and aliases cannot be named 'file'.
dotnet_diagnostic.cs9057.severity = warning                                                         # CS9057: Analyzer assembly '{0}' cannot be used because it references version '{1}' of the compiler, which is newer than the currently running version '{2}'.
dotnet_diagnostic.cs9058.severity = error                                                           # CS9058: Feature '{0}' is not available in C# 11.0. Please use language version {1} or greater.
dotnet_diagnostic.cs9059.severity = error                                                           # CS9059: A ref field can only be declared in a ref struct.
dotnet_diagnostic.cs9060.severity = error                                                           # CS9060: Cannot use a numeric constant or relational pattern on '{0}' because it inherits from or extends 'INumberBase<T>'. Consider using a type pattern to narrow to a specific numeric type.
dotnet_diagnostic.cs9061.severity = error                                                           # CS9061: The 'scoped' modifier cannot be used with discard.
dotnet_diagnostic.cs9062.severity = error                                                           # CS9062: Types and aliases cannot be named 'scoped'.
dotnet_diagnostic.cs9063.severity = error                                                           # CS9063: UnscopedRefAttribute cannot be applied to this parameter because it is unscoped by default.
dotnet_diagnostic.cs9064.severity = error                                                           # CS9064: Target runtime doesn't support ref fields.
dotnet_diagnostic.cs9065.severity = error                                                           # CS9065: Do not use 'System.Runtime.CompilerServices.ScopedRefAttribute'. Use the 'scoped' keyword instead.
dotnet_diagnostic.cs9066.severity = error                                                           # CS9066: UnscopedRefAttribute cannot be applied to parameters that have a 'scoped' modifier.
dotnet_diagnostic.cs9067.severity = warning                                                         # CS9067: Analyzer reference '{0}' specified multiple times
dotnet_diagnostic.cs9068.severity = error                                                           # CS9068: File-local type '{0}' must be declared in a file with a unique path. Path '{1}' is used in multiple files.
dotnet_diagnostic.cs9069.severity = error                                                           # CS9069: File-local type '{0}' cannot be used because the containing file path cannot be converted into the equivalent UTF-8 byte representation. {1}
dotnet_diagnostic.cs9071.severity = error                                                           # CS9071: The namespace '{1}' already contains a definition for '{0}' in this file.
dotnet_diagnostic.cs9072.severity = error                                                           # CS9072: A deconstruction variable cannot be declared as a ref local
dotnet_diagnostic.cs9073.severity = warning                                                         # CS9073: The 'scoped' modifier of parameter '{0}' doesn't match target '{1}'.
dotnet_diagnostic.cs9074.severity = warning                                                         # CS9074: The 'scoped' modifier of parameter '{0}' doesn't match overridden or implemented member.
dotnet_diagnostic.cs9075.severity = error                                                           # CS9075: Cannot return a parameter by reference '{0}' because it is scoped to the current method
dotnet_diagnostic.cs9076.severity = error                                                           # CS9076: Cannot return by reference a member of parameter '{0}' because it is scoped to the current method
dotnet_diagnostic.cs9077.severity = error                                                           # CS9077: Cannot return a parameter by reference '{0}' through a ref parameter; it can only be returned in a return statement
dotnet_diagnostic.cs9078.severity = error                                                           # CS9078: Cannot return by reference a member of parameter '{0}' through a ref parameter; it can only be returned in a return statement
dotnet_diagnostic.cs9079.severity = error                                                           # CS9079: Cannot ref-assign '{1}' to '{0}' because '{1}' can only escape the current method through a return statement.
dotnet_diagnostic.cs9080.severity = warning                                                         # CS9080: Use of variable '{0}' in this context may expose referenced variables outside of their declaration scope
dotnet_diagnostic.cs9081.severity = warning                                                         # CS9081: A result of a stackalloc expression of type '{0}' in this context may be exposed outside of the containing method
dotnet_diagnostic.cs9082.severity = warning                                                         # CS9082: Local '{0}' is returned by reference but was initialized to a value that cannot be returned by reference
dotnet_diagnostic.cs9083.severity = warning                                                         # CS9083: A member of '{0}' is returned by reference but was initialized to a value that cannot be returned by reference
dotnet_diagnostic.cs9084.severity = warning                                                         # CS9084: Struct member returns 'this' or other instance members by reference
dotnet_diagnostic.cs9085.severity = warning                                                         # CS9085: This ref-assigns '{1}' to '{0}' but '{1}' has a narrower escape scope than '{0}'.
dotnet_diagnostic.cs9086.severity = warning                                                         # CS9086: The branches of the ref conditional operator refer to variables with incompatible declaration scopes
dotnet_diagnostic.cs9087.severity = warning                                                         # CS9087: This returns a parameter by reference '{0}' but it is not a ref parameter
dotnet_diagnostic.cs9088.severity = warning                                                         # CS9088: This returns a parameter by reference '{0}' but it is scoped to the current method
dotnet_diagnostic.cs9089.severity = warning                                                         # CS9089: This returns by reference a member of parameter '{0}' that is not a ref or out parameter
dotnet_diagnostic.cs9090.severity = warning                                                         # CS9090: This returns by reference a member of parameter '{0}' that is scoped to the current method
dotnet_diagnostic.cs9091.severity = warning                                                         # CS9091: This returns local '{0}' by reference but it is not a ref local
dotnet_diagnostic.cs9092.severity = warning                                                         # CS9092: This returns a member of local '{0}' by reference but it is not a ref local
dotnet_diagnostic.cs9093.severity = warning                                                         # CS9093: This ref-assigns '{1}' to '{0}' but '{1}' can only escape the current method through a return statement.
dotnet_diagnostic.cs9094.severity = warning                                                         # CS9094: This returns a parameter by reference '{0}' through a ref parameter; but it can only safely be returned in a return statement
dotnet_diagnostic.cs9095.severity = warning                                                         # CS9095: This returns by reference a member of parameter '{0}' through a ref parameter; but it can only safely be returned in a return statement
dotnet_diagnostic.cs9096.severity = error                                                           # CS9096: Cannot ref-assign '{1}' to '{0}' because '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.
dotnet_diagnostic.cs9097.severity = warning                                                         # CS9097: This ref-assigns '{1}' to '{0}' but '{1}' has a wider value escape scope than '{0}' allowing assignment through '{0}' of values with narrower escape scopes than '{1}'.
dotnet_diagnostic.cs9098.severity = error                                                           # CS9098: Implicitly typed lambda parameter '{0}' cannot have a default value.
dotnet_diagnostic.cs9099.severity = warning                                                         # CS9099: Parameter {0} has default value '{1:10}' in lambda but '{2:10}' in the target delegate type.
dotnet_diagnostic.cs9100.severity = warning                                                         # CS9100: Parameter {0} has params modifier in lambda but not in target delegate type.
dotnet_diagnostic.cs9101.severity = error                                                           # CS9101: UnscopedRefAttribute can only be applied to struct or virtual interface instance methods and properties, and cannot be applied to constructors or init-only members.
dotnet_diagnostic.cs9102.severity = error                                                           # CS9102: UnscopedRefAttribute cannot be applied to an interface implementation because implemented member '{0}' doesn't have this attribute.
dotnet_diagnostic.cs9103.severity = error                                                           # CS9103: '{0}' is defined in a module with an unrecognized RefSafetyRulesAttribute version, expecting '11'.
dotnet_diagnostic.cs9105.severity = error                                                           # CS9105: Cannot use primary constructor parameter '{0}' in this context.
dotnet_diagnostic.cs9106.severity = error                                                           # CS9106: Identifier '{0}' is ambiguous between type '{1}' and parameter '{2}' in this context.
dotnet_diagnostic.cs9107.severity = warning                                                         # CS9107: Parameter '{0}' is captured into the state of the enclosing type and its value is also passed to the base constructor. The value might be captured by the base class as well.
dotnet_diagnostic.cs9108.severity = error                                                           # CS9108: Cannot use parameter '{0}' that has ref-like type inside an anonymous method, lambda expression, query expression, or local function
dotnet_diagnostic.cs9109.severity = error                                                           # CS9109: Cannot use ref, out, or in primary constructor parameter '{0}' inside an instance member
dotnet_diagnostic.cs9110.severity = error                                                           # CS9110: Cannot use primary constructor parameter '{0}' that has ref-like type inside an instance member
dotnet_diagnostic.cs9111.severity = error                                                           # CS9111: Anonymous methods, lambda expressions, query expressions, and local functions inside an instance member of a struct cannot access primary constructor parameter
dotnet_diagnostic.cs9112.severity = error                                                           # CS9112: Anonymous methods, lambda expressions, query expressions, and local functions inside a struct cannot access primary constructor parameter also used inside an instance member
dotnet_diagnostic.cs9113.severity = warning                                                         # CS9113: Parameter '{0}' is unread.
dotnet_diagnostic.cs9114.severity = error                                                           # CS9114: A primary constructor parameter of a readonly type cannot be assigned to (except in init-only setter of the type or a variable initializer)
dotnet_diagnostic.cs9115.severity = error                                                           # CS9115: A primary constructor parameter of a readonly type cannot be returned by writable reference
dotnet_diagnostic.cs9116.severity = error                                                           # CS9116: A primary constructor parameter of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)
dotnet_diagnostic.cs9117.severity = error                                                           # CS9117: Members of primary constructor parameter '{0}' of a readonly type cannot be modified (except in init-only setter of the type or a variable initializer)
dotnet_diagnostic.cs9118.severity = error                                                           # CS9118: Members of primary constructor parameter '{0}' of a readonly type cannot be returned by writable reference
dotnet_diagnostic.cs9119.severity = error                                                           # CS9119: Members of primary constructor parameter '{0}' of a readonly type cannot be used as a ref or out value (except in init-only setter of the type or a variable initializer)
dotnet_diagnostic.cs9120.severity = error                                                           # CS9120: Cannot return primary constructor parameter '{0}' by reference.
dotnet_diagnostic.cs9121.severity = error                                                           # CS9121: Struct primary constructor parameter '{0}' of type '{1}' causes a cycle in the struct layout
dotnet_diagnostic.cs9122.severity = error                                                           # CS9122: Unexpected parameter list.
dotnet_diagnostic.cs9123.severity = warning                                                         # CS9123: The '&' operator should not be used on parameters or local variables in async methods.
dotnet_diagnostic.cs9124.severity = warning                                                         # CS9124: Parameter '{0}' is captured into the state of the enclosing type and its value is also used to initialize a field, property, or event.
dotnet_diagnostic.cs9125.severity = warning                                                         # CS9125: Attribute parameter 'SizeConst' must be specified.
dotnet_diagnostic.cs9130.severity = error                                                           # CS9130: Using alias cannot be a 'ref' type.
dotnet_diagnostic.cs9131.severity = error                                                           # CS9131: Only a 'using static' or 'using alias' can be 'unsafe'.
dotnet_diagnostic.cs9132.severity = error                                                           # CS9132: Using alias cannot be a nullable reference type.
dotnet_diagnostic.cs9133.severity = error                                                           # CS9133: 'static' modifier must precede 'unsafe' modifier.
dotnet_diagnostic.cs9134.severity = error                                                           # CS9134: A switch expression arm does not begin with a 'case' keyword.
dotnet_diagnostic.cs9135.severity = error                                                           # CS9135: A constant value of type '{0}' is expected
dotnet_diagnostic.cs9136.severity = error                                                           # CS9136: Cannot use primary constructor parameter of type '{0}' inside an instance member
dotnet_diagnostic.cs9137.severity = error                                                           # CS9137: The 'interceptors' feature is not enabled in this namespace. Add '{0}' to your project.
dotnet_diagnostic.cs9138.severity = error                                                           # CS9138: Method '{0}' cannot be used as an interceptor because its containing type has type parameters.
dotnet_diagnostic.cs9139.severity = error                                                           # CS9139: Cannot intercept: compilation does not contain a file with path '{0}'.
dotnet_diagnostic.cs9140.severity = error                                                           # CS9140: Cannot intercept: compilation does not contain a file with path '{0}'. Did you mean to use path '{1}'?
dotnet_diagnostic.cs9141.severity = error                                                           # CS9141: The provided line and character number does not refer to an interceptable method name, but rather to token '{0}'.
dotnet_diagnostic.cs9142.severity = error                                                           # CS9142: The given file has '{0}' lines, which is fewer than the provided line number '{1}'.
dotnet_diagnostic.cs9143.severity = error                                                           # CS9143: The given line is '{0}' characters long, which is fewer than the provided character number '{1}'.
dotnet_diagnostic.cs9144.severity = error                                                           # CS9144: Cannot intercept method '{0}' with interceptor '{1}' because the signatures do not match.
dotnet_diagnostic.cs9146.severity = error                                                           # CS9146: An interceptor method must be an ordinary member method.
dotnet_diagnostic.cs9147.severity = error                                                           # CS9147: The provided line and character number does not refer to the start of token '{0}'. Did you mean to use line '{1}' and character '{2}'?
dotnet_diagnostic.cs9148.severity = error                                                           # CS9148: Interceptor must have a 'this' parameter matching parameter '{0}' on '{1}'.
dotnet_diagnostic.cs9149.severity = error                                                           # CS9149: Interceptor must not have a 'this' parameter because '{0}' does not have a 'this' parameter.
dotnet_diagnostic.cs9150.severity = error                                                           # CS9150: Interceptor cannot have a 'null' file path.
dotnet_diagnostic.cs9151.severity = error                                                           # CS9151: Possible method name '{0}' cannot be intercepted because it is not being invoked.
dotnet_diagnostic.cs9152.severity = error                                                           # CS9152: Cannot intercept a call in file with path '{0}' because multiple files in the compilation have this path.
dotnet_diagnostic.cs9153.severity = error                                                           # CS9153: The indicated call is intercepted multiple times.
dotnet_diagnostic.cs9154.severity = warning                                                         # CS9154: Intercepting a call to '{0}' with interceptor '{1}', but the signatures do not match.
dotnet_diagnostic.cs9155.severity = error                                                           # CS9155: Cannot intercept call with '{0}' because it is not accessible within '{1}'.
dotnet_diagnostic.cs9156.severity = error                                                           # CS9156: Cannot intercept call to '{0}' with '{1}' because of a difference in 'scoped' modifiers or '[UnscopedRef]' attributes.
dotnet_diagnostic.cs9157.severity = error                                                           # CS9157: Line and character numbers provided to InterceptsLocationAttribute must be positive.
dotnet_diagnostic.cs9158.severity = warning                                                         # CS9158: Nullability of reference types in return type doesn't match interceptable method '{0}'.
dotnet_diagnostic.cs9159.severity = warning                                                         # CS9159: Nullability of reference types in type of parameter '{0}' doesn't match interceptable method '{1}'.
dotnet_diagnostic.cs9160.severity = error                                                           # CS9160: A nameof operator cannot be intercepted.
dotnet_diagnostic.cs9161.severity = error                                                           # CS9161: An interceptor cannot be marked with 'UnmanagedCallersOnlyAttribute'.
dotnet_diagnostic.cs9162.severity = error                                                           # CS9162: '{0}' type is not valid for 'using static'. Only a class, struct, interface, enum, delegate, or namespace can be used.
dotnet_diagnostic.cs9163.severity = error                                                           # CS9163: '{0}' is defined in assembly '{1}'.
dotnet_diagnostic.cs9164.severity = error                                                           # CS9164: Cannot convert expression to '{0}' because it is not an assignable variable
dotnet_diagnostic.cs9165.severity = error                                                           # CS9165: Cannot convert expression to '{0}' because it may not be passed or returned by reference
dotnet_diagnostic.cs9166.severity = error                                                           # CS9166: Index is outside the bounds of the inline array
dotnet_diagnostic.cs9167.severity = error                                                           # CS9167: Inline array length must be greater than 0.
dotnet_diagnostic.cs9168.severity = error                                                           # CS9168: Inline array struct must not have explicit layout.
dotnet_diagnostic.cs9169.severity = error                                                           # CS9169: Inline array struct must declare one and only one instance field.
dotnet_diagnostic.cs9170.severity = error                                                           # CS9170: An expression tree may not contain an inline array access or conversion
dotnet_diagnostic.cs9171.severity = error                                                           # CS9171: Target runtime doesn't support inline array types.
dotnet_diagnostic.cs9172.severity = error                                                           # CS9172: Elements of an inline array type can be accessed only with a single argument implicitly convertible to 'int', 'System.Index', or 'System.Range'.
dotnet_diagnostic.cs9173.severity = error                                                           # CS9173: An inline array access may not have a named argument specifier
dotnet_diagnostic.cs9174.severity = error                                                           # CS9174: Cannot initialize type '{0}' with a collection expression because the type is not constructible.
dotnet_diagnostic.cs9175.severity = error                                                           # CS9175: An expression tree may not contain a collection expression.
dotnet_diagnostic.cs9176.severity = error                                                           # CS9176: There is no target type for the collection expression.
dotnet_diagnostic.cs9177.severity = error                                                           # CS9177: Method '{0}' must be non-generic or have arity {1} to match '{2}'.
dotnet_diagnostic.cs9178.severity = error                                                           # CS9178: Method '{0}' must be non-generic to match '{1}'.
dotnet_diagnostic.cs9179.severity = warning                                                         # CS9179: Primary constructor parameter '{0}' is shadowed by a member from base.
dotnet_diagnostic.cs9180.severity = error                                                           # CS9180: Inline array element field cannot be declared as required, readonly, volatile, or as a fixed size buffer.
dotnet_diagnostic.cs9181.severity = warning                                                         # CS9181: Inline array indexer will not be used for element access expression.
dotnet_diagnostic.cs9182.severity = warning                                                         # CS9182: Inline array 'Slice' method will not be used for element access expression.
dotnet_diagnostic.cs9183.severity = warning                                                         # CS9183: Inline array conversion operator will not be used for conversion from expression of the declaring type.
dotnet_diagnostic.cs9184.severity = warning                                                         # CS9184: 'Inline arrays' language feature is not supported for an inline array type that is not valid as a type argument, or has element type that is not valid as a type argument.
dotnet_diagnostic.cs9185.severity = error                                                           # CS9185: The CollectionBuilderAttribute builder type must be a non-generic class or struct.
dotnet_diagnostic.cs9186.severity = error                                                           # CS9186: The CollectionBuilderAttribute method name is invalid.
dotnet_diagnostic.cs9187.severity = error                                                           # CS9187: Could not find an accessible '{0}' method with the expected signature: a static method with a single parameter of type 'ReadOnlySpan<{1}>' and return type '{2}'.
dotnet_diagnostic.cs9188.severity = error                                                           # CS9188: '{0}' has a CollectionBuilderAttribute but no element type.
dotnet_diagnostic.cs9189.severity = error                                                           # CS9189: foreach statement on an inline array of type '{0}' is not supported
dotnet_diagnostic.cs9190.severity = error                                                           # CS9190: 'readonly' modifier must be specified after 'ref'.
dotnet_diagnostic.cs9191.severity = warning                                                         # CS9191: The 'ref' modifier for argument {0} corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.
dotnet_diagnostic.cs9192.severity = warning                                                         # CS9192: Argument {0} should be passed with 'ref' or 'in' keyword
dotnet_diagnostic.cs9193.severity = warning                                                         # CS9193: Argument {0} should be a variable because it is passed to a 'ref readonly' parameter
dotnet_diagnostic.cs9194.severity = error                                                           # CS9194: Argument {0} may not be passed with the 'ref' keyword in language version {1}. To pass 'ref' arguments to 'in' parameters, upgrade to language version {2} or greater.
dotnet_diagnostic.cs9195.severity = warning                                                         # CS9195: Argument {0} should be passed with the 'in' keyword
dotnet_diagnostic.cs9196.severity = warning                                                         # CS9196: Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in overridden or implemented member.
dotnet_diagnostic.cs9197.severity = warning                                                         # CS9197: Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in hidden member.
dotnet_diagnostic.cs9198.severity = warning                                                         # CS9198: Reference kind modifier of parameter '{0}' doesn't match the corresponding parameter '{1}' in target.
dotnet_diagnostic.cs9199.severity = error                                                           # CS9199: A ref readonly parameter cannot have the Out attribute.
dotnet_diagnostic.cs9200.severity = warning                                                         # CS9200: A default value is specified for 'ref readonly' parameter '{0}', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.
dotnet_diagnostic.cs9201.severity = warning                                                         # CS9201: Ref field '{0}' should be ref-assigned before use.
dotnet_diagnostic.cs9202.severity = error                                                           # CS9202: Feature '{0}' is not available in C# 12.0. Please use language version {1} or greater.
dotnet_diagnostic.cs9203.severity = error                                                           # CS9203: A collection expression of type '{0}' cannot be used in this context because it may be exposed outside of the current scope.
dotnet_diagnostic.cs9204.severity = warning                                                         # CS9204: '{0}' is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
dotnet_diagnostic.cs9205.severity = error                                                           # CS9205: Expected interpolated string
dotnet_diagnostic.cs9206.severity = error                                                           # CS9206: An interceptor cannot be declared in the global namespace.
dotnet_diagnostic.cs9207.severity = error                                                           # CS9207: Cannot intercept '{0}' because it is not an invocation of an ordinary member method.
dotnet_diagnostic.cs9208.severity = warning                                                         # CS9208: Collection expression of type '{0}' may incur unexpected heap allocations. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.
dotnet_diagnostic.cs9209.severity = warning                                                         # CS9209: Collection expression of type '{0}' may incur unexpected heap allocations due to the use of '..' spreads. Consider explicitly creating an array, then converting to '{0}' to make the allocation explicit.
dotnet_diagnostic.cs9210.severity = error                                                           # CS9210: This version of '{0}' cannot be used with collection expressions.
dotnet_diagnostic.cs9211.severity = error                                                           # CS9211: The diagnosticId argument to the 'Experimental' attribute must be a valid identifier
dotnet_diagnostic.cs9212.severity = error                                                           # CS9212: Spread operator '..' cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'
dotnet_diagnostic.cs9213.severity = error                                                           # CS9213: Collection expression target '{0}' has no element type.
dotnet_diagnostic.cs9214.severity = error                                                           # CS9214: Collection expression type must have an applicable constructor that can be called with no arguments.
dotnet_diagnostic.cs9215.severity = error                                                           # CS9215: Collection expression type '{0}' must have an instance or extension method 'Add' that can be called with a single argument.
dotnet_diagnostic.cs9216.severity = warning                                                         # CS9216: A value of type 'System.Threading.Lock' converted to a different type will use likely unintended monitor-based locking in 'lock' statement.
dotnet_diagnostic.cs9217.severity = error                                                           # CS9217: A 'ref' local cannot be preserved across 'await' or 'yield' boundary.
dotnet_diagnostic.cs9218.severity = error                                                           # CS9218: '{0}' is applicable only with expanded form of non-array params collection which is not supported during dynamic dispatch.
dotnet_diagnostic.cs9222.severity = error                                                           # CS9222: Collection initializer results in an infinite chain of instantiations of collection '{0}'.
dotnet_diagnostic.cs9223.severity = error                                                           # CS9223: Creation of params collection '{0}' results in an infinite chain of invocation of constructor '{1}'.
dotnet_diagnostic.cs9224.severity = error                                                           # CS9224: Method '{0}' cannot be less visible than the member with params collection '{1}'.
dotnet_diagnostic.cs9225.severity = error                                                           # CS9225: Constructor '{0}' leaves required member '{1}' uninitialized.
dotnet_diagnostic.cs9226.severity = error                                                           # CS9226: An expression tree may not contain an expanded form of non-array params collection parameter.
dotnet_diagnostic.cs9227.severity = error                                                           # CS9227: '{0}' does not contain a definition for a suitable instance 'Add' method
dotnet_diagnostic.cs9228.severity = error                                                           # CS9228: Non-array params collection type must have an applicable constructor that can be called with no arguments.
dotnet_diagnostic.cs9229.severity = error                                                           # CS9229: Modifiers cannot be placed on using declarations
dotnet_diagnostic.cs9230.severity = error                                                           # CS9230: Cannot perform a dynamic invocation on an expression with type '{0}'.
dotnet_diagnostic.cs9231.severity = error                                                           # CS9231: The data argument to InterceptsLocationAttribute is not in the correct format.
dotnet_diagnostic.cs9232.severity = error                                                           # CS9232: Version '{0}' of the interceptors format is not supported. The latest supported version is '1'.
dotnet_diagnostic.cs9233.severity = error                                                           # CS9233: Cannot intercept a call in file '{0}' because it is duplicated elsewhere in the compilation.
dotnet_diagnostic.cs9234.severity = error                                                           # CS9234: Cannot intercept a call in file '{0}' because a matching file was not found in the compilation.
dotnet_diagnostic.cs9235.severity = error                                                           # CS9235: The data argument to InterceptsLocationAttribute refers to an invalid position in file '{0}'.
dotnet_diagnostic.cs9236.severity = suggestion                                                      # CS9236: Compiling requires binding the lambda expression at least {0} times. Consider declaring the lambda expression with explicit parameter types, or if the containing method call is generic, consider using explicit type arguments.
dotnet_diagnostic.cs9238.severity = error                                                           # CS9238: Cannot use 'yield return' in an 'unsafe' block
dotnet_diagnostic.cs9239.severity = error                                                           # CS9239: The '&' operator cannot be used on parameters or local variables in iterator methods.
dotnet_diagnostic.cs9240.severity = error                                                           # CS9240: Target runtime doesn't support by-ref-like generics.
dotnet_diagnostic.cs9241.severity = error                                                           # CS9241: 'ref struct' is already specified.
dotnet_diagnostic.cs9242.severity = error                                                           # CS9242: The 'allows' constraint clause must be the last constraint specified
dotnet_diagnostic.cs9243.severity = error                                                           # CS9243: Cannot allow ref structs for a type parameter known from other constraints to be a class
dotnet_diagnostic.cs9244.severity = error                                                           # CS9244: The type '{2}' may not be a ref struct or a type parameter allowing ref structs in order to use it as parameter '{1}' in the generic type or method '{0}'
dotnet_diagnostic.cs9245.severity = error                                                           # CS9245: '{0}' cannot implement interface member '{1}' for ref struct '{2}'.
dotnet_diagnostic.cs9246.severity = error                                                           # CS9246: A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.
dotnet_diagnostic.cs9247.severity = error                                                           # CS9247: foreach statement cannot operate on enumerators of type '{0}' because it is a type parameter that allows ref struct and it is not known at compile time to implement IDisposable.
dotnet_diagnostic.cs9248.severity = error                                                           # CS9248: Partial property '{0}' must have an implementation part.
dotnet_diagnostic.cs9249.severity = error                                                           # CS9249: Partial property '{0}' must have a definition part.
dotnet_diagnostic.cs9250.severity = error                                                           # CS9250: A partial property may not have multiple defining declarations, and cannot be an auto-property.
dotnet_diagnostic.cs9251.severity = error                                                           # CS9251: A partial property may not have multiple implementing declarations
dotnet_diagnostic.cs9252.severity = error                                                           # CS9252: Property accessor '{0}' must be implemented because it is declared on the definition part
dotnet_diagnostic.cs9253.severity = error                                                           # CS9253: Property accessor '{0}' does not implement any accessor declared on the definition part
dotnet_diagnostic.cs9254.severity = error                                                           # CS9254: Property accessor '{0}' must be '{1}' to match the definition part
dotnet_diagnostic.cs9255.severity = error                                                           # CS9255: Both partial member declarations must have the same type.
dotnet_diagnostic.cs9256.severity = warning                                                         # CS9256: Partial member declarations '{0}' and '{1}' have signature differences.
dotnet_diagnostic.cs9257.severity = error                                                           # CS9257: Both partial property declarations must be required or neither may be required
dotnet_diagnostic.cs9258.severity = warning                                                         # CS9258: In language version {0}, the 'field' keyword binds to a synthesized backing field for the property. To avoid generating a synthesized backing field, and to refer to the existing member, use 'this.field' or '@field' instead.
dotnet_diagnostic.cs9259.severity = error                                                           # CS9259: Attribute 'System.Runtime.CompilerServices.InlineArray' cannot be applied to a record struct.
dotnet_diagnostic.cs9260.severity = error                                                           # CS9260: Feature '{0}' is not available in C# 13.0. Please use language version {1} or greater.
dotnet_diagnostic.cs9261.severity = error                                                           # CS9261: Cannot use 'OverloadResolutionPriorityAttribute' on an overriding member.
dotnet_diagnostic.cs9262.severity = error                                                           # CS9262: Cannot use 'OverloadResolutionPriorityAttribute' on this member.
dotnet_diagnostic.cs9263.severity = error                                                           # CS9263: A partial property cannot have an initializer on both the definition and implementation.
dotnet_diagnostic.cs9264.severity = warning                                                         # CS9264: Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider adding the 'required' modifier, or declaring the {0} as nullable, or safely handling the case where 'field' is null in the 'get' accessor.
dotnet_diagnostic.cs9265.severity = warning                                                         # CS9265: Field '{0}' is never ref-assigned to, and will always have its default value (null reference)
dotnet_diagnostic.cs9266.severity = warning                                                         # CS9266: The '{0}' accessor of property '{1}' should use 'field' because the other accessor is using it.
dotnet_diagnostic.cs9267.severity = error                                                           # CS9267: Element type of an iterator may not be a ref struct or a type parameter allowing ref structs
dotnet_diagnostic.cs9268.severity = warning                                                         # CS9268: '{0}' is for evaluation purposes only and is subject to change or removal in future updates: '{1}'. Suppress this diagnostic to proceed.
dotnet_diagnostic.cs9269.severity = warning                                                         # CS9269: UnscopedRefAttribute is only valid in C# 11 or later or when targeting net7.0 or later.
dotnet_diagnostic.cs9270.severity = warning                                                         # CS9270: 'InterceptsLocationAttribute(string, int, int)' is not supported. Move to 'InterceptableLocation'-based generation of these attributes instead. (https://github.com/dotnet/roslyn/issues/72133)
dotnet_diagnostic.cs9271.severity = error                                                           # CS9271: The type 'Microsoft.CodeAnalysis.EmbeddedAttribute' must be non-generic, internal, sealed, non-static, have a parameterless constructor, inherit from System.Attribute, and be able to be applied to any type.
dotnet_diagnostic.cs9272.severity = error                                                           # CS9272: Implicitly typed lambda parameter '{0}' cannot have the 'params' modifier.
dotnet_diagnostic.cs9273.severity = error                                                           # CS9273: In language version {0}, 'field' is a keyword within a property accessor. Rename the variable or use the identifier '@field' instead.
dotnet_diagnostic.cs9274.severity = error                                                           # CS9274: Cannot emit this string literal into the data section because it has XXHash128 collision with another string literal: {0}
dotnet_diagnostic.cs9275.severity = error                                                           # CS9275: Partial member '{0}' must have an implementation part.
dotnet_diagnostic.cs9276.severity = error                                                           # CS9276: Partial member '{0}' must have a definition part.
dotnet_diagnostic.cs9277.severity = error                                                           # CS9277: Partial member '{0}' may not have multiple defining declarations.
dotnet_diagnostic.cs9278.severity = error                                                           # CS9278: Partial member '{0}' may not have multiple implementing declarations.
dotnet_diagnostic.cs9279.severity = error                                                           # CS9279: '{0}': partial event cannot have initializer
dotnet_diagnostic.cs9280.severity = error                                                           # CS9280: '{0}': only the implementing declaration of a partial constructor can have an initializer
dotnet_diagnostic.cs9281.severity = error                                                           # CS9281: Extension declarations may not have a name.
dotnet_diagnostic.cs9282.severity = error                                                           # CS9282: This member is not allowed in an extension block
dotnet_diagnostic.cs9283.severity = error                                                           # CS9283: Extensions must be declared in a top-level, non-generic, static class
dotnet_diagnostic.cs9284.severity = error                                                           # CS9284: The receiver parameter of an extension cannot have a default value
dotnet_diagnostic.cs9285.severity = error                                                           # CS9285: An extension container can have only one receiver parameter
dotnet_diagnostic.cs9286.severity = error                                                           # CS9286: '{0}' does not contain a definition for '{1}' and no accessible extension member '{1}' for receiver of type '{0}' could be found (are you missing a using directive or an assembly reference?)
dotnet_diagnostic.cs9287.severity = error                                                           # CS9287: '{0}': a receiver parameter cannot have the same name as an extension container type parameter
dotnet_diagnostic.cs9288.severity = error                                                           # CS9288: '{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
dotnet_diagnostic.cs9289.severity = error                                                           # CS9289: Type parameter '{0}' has the same name as an extension container type parameter
dotnet_diagnostic.cs9290.severity = error                                                           # CS9290: '{0}': a parameter, local variable, or local function cannot have the same name as an extension parameter
dotnet_diagnostic.cs9291.severity = error                                                           # CS9291: 'value': an automatically-generated parameter name conflicts with an extension parameter name
dotnet_diagnostic.cs9292.severity = error                                                           # CS9292: Type parameter '{0}' has the same name as an extension parameter
dotnet_diagnostic.cs9293.severity = error                                                           # CS9293: Cannot use extension parameter '{0}' in this context.
dotnet_diagnostic.cs9294.severity = error                                                           # CS9294: 'value': an automatically-generated parameter name conflicts with an extension type parameter name
dotnet_diagnostic.cs9295.severity = error                                                           # CS9295: The type parameter `{0}` is not referenced by either the extension parameter or a parameter of this member
dotnet_diagnostic.cs9296.severity = error                                                           # CS9296: An expression tree may not contain an extension property access
dotnet_diagnostic.cs9297.severity = error                                                           # CS9297: '#:' directives cannot be after first token in file
dotnet_diagnostic.cs9298.severity = error                                                           # CS9298: '#:' directives can be only used in file-based programs ('-features:FileBasedProgram')
dotnet_diagnostic.cs9299.severity = error                                                           # CS9299: '#:' directives cannot be after '#if' directive
dotnet_diagnostic.cs9300.severity = error                                                           # CS9300: The 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.
dotnet_diagnostic.cs9301.severity = error                                                           # CS9301: The 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.
dotnet_diagnostic.cs9302.severity = error                                                           # CS9302: '{0}': new protected member declared in an extension block
dotnet_diagnostic.cs9303.severity = error                                                           # CS9303: '{0}': cannot declare instance members in an extension block with an unnamed receiver parameter
dotnet_diagnostic.cs9304.severity = error                                                           # CS9304: '{0}': cannot declare init-only accessors in an extension block
dotnet_diagnostic.cs9305.severity = error                                                           # CS9305: Cannot use modifiers on the unnamed receiver parameter of extension block
dotnet_diagnostic.cs9306.severity = error                                                           # CS9306: Types and aliases cannot be named 'extension'.
dotnet_diagnostic.cs9307.severity = error                                                           # CS9307: An expression tree may not contain a named argument specification out of position
dotnet_diagnostic.cs9308.severity = error                                                           # CS9308: User-defined operator '{0}' must be declared public
dotnet_diagnostic.cs9309.severity = error                                                           # CS9309: An extension member syntax is disallowed in nested position within an extension member syntax
dotnet_diagnostic.cs9310.severity = error                                                           # CS9310: The return type for this operator must be void
dotnet_diagnostic.cs9311.severity = error                                                           # CS9311: '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because one of them is not an operator.
dotnet_diagnostic.cs9312.severity = error                                                           # CS9312: '{0}': cannot override inherited member '{1}' because one of them is not an operator.
dotnet_diagnostic.cs9313.severity = error                                                           # CS9313: Overloaded compound assignment operator '{0}' takes one parameter
dotnet_diagnostic.cs9314.severity = error                                                           # CS9314: '#!' directives can be only used in scripts or file-based programs
dotnet_diagnostic.cs9315.severity = error                                                           # CS9315: Combined length of user strings used by the program exceeds allowed limit. Adding a string literal requires restarting the application.
dotnet_diagnostic.cs9316.severity = error                                                           # CS9316: Extension members are not allowed as an argument to 'nameof'.
dotnet_diagnostic.cs9317.severity = error                                                           # CS9317: The parameter of a unary operator must be the extended type.
dotnet_diagnostic.cs9318.severity = error                                                           # CS9318: The parameter type for ++ or -- operator must be the extended type.
dotnet_diagnostic.cs9319.severity = error                                                           # CS9319: One of the parameters of a binary operator must be the extended type.
dotnet_diagnostic.cs9320.severity = error                                                           # CS9320: The first operand of an overloaded shift operator must have the same type as the extended type
dotnet_diagnostic.cs9321.severity = error                                                           # CS9321: An extension block extending a static class cannot contain user-defined operators
dotnet_diagnostic.cs9322.severity = error                                                           # CS9322: Cannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter
dotnet_diagnostic.cs9323.severity = error                                                           # CS9323: Cannot declare instance extension operator for a type that is not known to be a struct and is not known to be a class
dotnet_diagnostic.cs9324.severity = error                                                           # CS9324: An expression tree may not contain '&&' or '||' operators that use extension user defined operators.
dotnet_diagnostic.cs9325.severity = error                                                           # CS9325: Interpolated string handler arguments are not allowed in this context.
dotnet_diagnostic.cs9326.severity = error                                                           # CS9326: '{0}': extension member names cannot be the same as their extended type
dotnet_diagnostic.cs9327.severity = error                                                           # CS9327: Feature '{0}' is not available in C# 14.0. Please use language version {1} or greater.
dotnet_diagnostic.cs9328.severity = error                                                           # CS9328: Method '{0}' uses a feature that is not supported by runtime async currently. Opt the method out of runtime async by attributing it with 'System.Runtime.CompilerServices.RuntimeAsyncMethodGenerationAttribute(false)'.
dotnet_diagnostic.cs9329.severity = error                                                           # CS9329: This extension block collides with another extension block. They result in conflicting content-based type names in metadata, so must be in separate enclosing static classes.
dotnet_diagnostic.cs9330.severity = error                                                           # CS9330: 'MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.
dotnet_diagnostic.cs9331.severity = error                                                           # CS9331: '{0}' cannot be applied manually.
dotnet_diagnostic.cs9332.severity = error                                                           # CS9332: Cannot use '..' spread operator in the filter expression of a catch clause
dotnet_diagnostic.cs9333.severity = error                                                           # CS9333: '{0}': type must be '{1}' to match implemented member '{2}'
dotnet_diagnostic.cs9334.severity = error                                                           # CS9334: '{0}': return type must be '{1}' to match implemented member '{2}'
dotnet_diagnostic.syslib1014.severity = warning                                                     # SYSLIB1014: A template in the logging message doesn't have a matching parameter in the logging method definition
dotnet_diagnostic.wme006.severity = warning                                                         # WME006: Namespace should be default namespace of this project

#### ReSharper/Rider code style options ####

# Syntax Style -> Braces (csharp_prefer_braces)
resharper_braces_for_dowhile = required                                                             # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_fixed = required                                                               # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_for = required                                                                 # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_foreach = required                                                             # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_ifelse = required                                                              # not_required, not_required_for_both, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_lock = required                                                                # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_using = required                                                               # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_for_while = required                                                               # not_required, required, required_for_multiline, required_for_multiline_statement
resharper_braces_redundant = true                                                                   # Remove redundant braces
resharper_enforce_do_while_statement_braces_highlighting = suggestion
resharper_enforce_fixed_statement_braces_highlighting = suggestion
resharper_enforce_foreach_statement_braces_highlighting = suggestion
resharper_enforce_for_statement_braces_highlighting = suggestion
resharper_enforce_if_statement_braces_highlighting = suggestion
resharper_enforce_lock_statement_braces_highlighting = suggestion
resharper_enforce_using_statement_braces_highlighting = suggestion
resharper_enforce_while_statement_braces_highlighting = suggestion
resharper_remove_redundant_braces_highlighting = suggestion

# Syntax Style -> Default value (csharp_prefer_simple_default_expression)
resharper_default_value_when_type_evident = default_literal                                         # default_literal, default_expression
resharper_default_value_when_type_not_evident = default_literal                                     # default_literal, default_expression
resharper_arrange_default_value_when_type_evident_highlighting = suggestion
resharper_arrange_default_value_when_type_not_evident_highlighting = suggestion

# Inspections -> Common Practices and Code Improvements
resharper_change_field_type_to_system_threading_lock_highlighting = suggestion                      # csharp_prefer_system_threading_lock

# Inspections -> Language Usage Opportunities
resharper_convert_closure_to_method_group_highlighting = suggestion                                 # csharp_style_prefer_method_group_conversion
resharper_convert_if_statement_to_conditional_ternary_expression_highlighting = suggestion          # dotnet_style_prefer_conditional_expression_over_assignment
resharper_convert_to_auto_property_highlighting = suggestion                                        # dotnet_style_prefer_auto_properties
resharper_convert_to_auto_property_when_possible_highlighting = suggestion                          # dotnet_style_prefer_auto_properties
resharper_convert_to_auto_property_with_private_setter_highlighting = suggestion                    # dotnet_style_prefer_auto_properties
resharper_convert_to_local_function_highlighting = suggestion                                       # csharp_style_prefer_local_over_anonymous_function
resharper_convert_to_primary_constructor_highlighting = none                                        # csharp_style_prefer_primary_constructors
resharper_convert_to_using_declaration_highlighting = suggestion                                    # csharp_prefer_simple_using_statement
resharper_inline_out_variable_declaration_highlighting = suggestion                                 # csharp_style_inlined_variable_declaration
resharper_join_null_check_with_usage_highlighting = suggestion                                      # csharp_style_throw_expression
resharper_merge_conditional_expression_highlighting = suggestion                                    # dotnet_style_coalesce_expression, dotnet_style_null_propagation
# resharper_use_collection_expression_highlighting = suggestion                                     # dotnet_style_prefer_collection_expression
resharper_use_deconstruction_highlighting = suggestion                                              # csharp_style_deconstructed_variable_declaration
resharper_use_object_or_collection_initializer_highlighting = suggestion                            # dotnet_style_object_initializer, dotnet_style_collection_initializer

# Inspections -> Potential Code Quality Issues
resharper_prefer_explicitly_provided_tuple_component_name_highlighting = suggestion                 # dotnet_style_explicit_tuple_names

# Inspections -> Redundancies in Code
resharper_redundant_anonymous_type_property_name_highlighting = suggestion                          # dotnet_style_prefer_inferred_anonymous_type_member_names
resharper_redundant_explicit_tuple_component_name_highlighting = suggestion                         # dotnet_style_prefer_inferred_tuple_names

#### ReSharper/Rider generalized options ####

# resharper_csharp_brace_style = next_line                                    # Braces layout style
# resharper_csharp_int_align = false                                          # Align similar code in columns
# resharper_csharp_keep_existing_arrangement = true                           # Keep existing code arrangements (single line/multi line)
# resharper_csharp_place_simple_blocks_on_single_line = false                 # Place simple blocks on single line
# resharper_csharp_place_simple_declaration_blocks_on_single_line = false     # Place blocks from simple type members on single line
# resharper_csharp_place_attribute_on_same_line = never                       # Place simple attribute on the same line with the owner (never, if_owner_is_single_line, always)
# resharper_csharp_space_after_unary_operator = false                         # Space after unary operators (!, -, ~,...)
# resharper_csharp_space_around_ternary_operator = true                       # Space around ternary operators (?, :)
# resharper_csharp_space_around_binary_operator = true                        # Space around binary operators (+, ||, =, ...)
# resharper_csharp_space_around_member_access_operator = false                # Space around member access operators (., ->, ...)
#
# #### ReSharper/Rider formatting options ####
#
# # Align multiline constructs
# resharper_csharp_align_first_arg_by_paren = false                           # Call arguments by '('
# resharper_csharp_align_linq_query = false
#
# #### ReSharper/Rider code style options ####
#
# # Braces (end_of_line = K&R, end_of_line_no_space = K&R without space, next_line = Allman, next_line_shifted = Whitesmiths, next_line_shifted_2 = GNU, pico)
# resharper_csharp_accessor_declaration_braces = next_line                    # Accessor declaration
# resharper_csharp_accessor_owner_declaration_braces = next_line              # Property declaration
#
# # Code body
# resharper_csharp_accessor_owner_body = expression_body                      # Properties, indexers, and events (expression_body, accessors_with_expression_body, accessors_with_block_body)
#
# # Reference qualification and 'using' directives
# resharper_csharp_add_imports_to_deepest_scope = false                       # Add 'using' directive to deepest scope
#
# # ReSharper properties
#
# resharper_alignment_tab_fill_style = use_spaces
#
# resharper_align_multiline_array_and_object_initializer = false
# resharper_align_multiline_array_initializer = true
# resharper_align_multiline_binary_patterns = false
# resharper_align_multiline_comments = true
# resharper_align_multiline_ctor_init = true
# resharper_align_multiline_expression_braces = false
# resharper_align_multiline_implements_list = true
# resharper_align_multiline_list_pattern = false
# resharper_align_multiline_property_pattern = false
# resharper_align_multiline_statement_conditions = true
# resharper_align_multiline_switch_expression = false
# resharper_align_multiline_type_argument = true
# resharper_align_multiline_type_parameter = true
# resharper_align_multiline_type_parameter_constraints = false
# resharper_align_multiline_type_parameter_list = false
# resharper_align_ternary = align_not_nested
# resharper_align_tuple_components = false
# resharper_allow_alias = true
# resharper_allow_comment_after_lbrace = false
# resharper_allow_high_precedence_app_parens = true
# resharper_always_use_end_of_line_brace_style = false
# resharper_apply_auto_detected_rules = true
# resharper_apply_on_completion = false
# resharper_arguments_anonymous_function = positional
# resharper_arguments_literal = positional
# resharper_arguments_named = positional
# resharper_arguments_other = positional
# resharper_arguments_skip_single = false
# resharper_arguments_string_literal = positional
# resharper_attribute_style = do_not_touch
# resharper_autodetect_indent_settings = false
# resharper_blank_lines_after_access_specifier = 0
# resharper_blank_lines_after_block_statements = 1
# resharper_blank_lines_after_case = 0
# resharper_blank_lines_after_control_transfer_statements = 0
# resharper_blank_lines_after_file_scoped_namespace_directive = 1
# resharper_blank_lines_after_imports = 1
# resharper_blank_lines_after_multiline_statements = 0
# resharper_blank_lines_after_options = 1
# resharper_blank_lines_after_start_comment = 1
# resharper_blank_lines_after_using_list = 1
# resharper_blank_lines_around_accessor = 0
# resharper_blank_lines_around_auto_property = 1
# resharper_blank_lines_around_block_case_section = 0
# resharper_blank_lines_around_class_definition = 1
# resharper_blank_lines_around_different_module_member_kinds = 1
# resharper_blank_lines_around_field = 1
# resharper_blank_lines_around_function_declaration = 0
# resharper_blank_lines_around_function_definition = 1
# resharper_blank_lines_around_global_attribute = 0
# resharper_blank_lines_around_invocable = 1
# resharper_blank_lines_around_local_method = 1
# resharper_blank_lines_around_multiline_case_section = 0
# resharper_blank_lines_around_multiline_module_members = 1
# resharper_blank_lines_around_namespace = 1
# resharper_blank_lines_around_other_declaration = 0
# resharper_blank_lines_around_property = 1
# resharper_blank_lines_around_razor_functions = 1
# resharper_blank_lines_around_razor_helpers = 1
# resharper_blank_lines_around_razor_sections = 1
# resharper_blank_lines_around_region = 1
# resharper_blank_lines_around_single_line_accessor = 0
# resharper_blank_lines_around_single_line_auto_property = 0
# resharper_blank_lines_around_single_line_field = 0
# resharper_blank_lines_around_single_line_function_definition = 0
# resharper_blank_lines_around_single_line_invocable = 0
# resharper_blank_lines_around_single_line_local_method = 0
# resharper_blank_lines_around_single_line_module_member = 0
# resharper_blank_lines_around_single_line_property = 0
# resharper_blank_lines_around_single_line_type = 1
# resharper_blank_lines_around_type = 1
# resharper_blank_lines_before_access_specifier = 1
# resharper_blank_lines_before_block_statements = 0
# resharper_blank_lines_before_case = 0
# resharper_blank_lines_before_control_transfer_statements = 0
# resharper_blank_lines_before_first_module_member_in_nested_module = 0
# resharper_blank_lines_before_first_module_member_in_top_level_module = 1
# resharper_blank_lines_before_multiline_statements = 0
# resharper_blank_lines_before_single_line_comment = 0
# resharper_blank_lines_inside_namespace = 0
# resharper_blank_lines_inside_region = 1
# resharper_blank_lines_inside_type = 0
# resharper_blank_line_after_pi = true
# resharper_blank_line_around_top_level_modules = 2
# resharper_break_template_declaration = line_break
# resharper_builtin_type_apply_to_native_integer = false
# resharper_can_use_global_alias = true
# resharper_configure_await_analysis_mode = disabled
# resharper_constructor_or_destructor_body = block_body
# resharper_continuous_indent_multiplier = 1
# resharper_continuous_line_indent = single
# resharper_csharp_align_multiline_argument = false
# resharper_csharp_align_multiline_binary_expressions_chain = true
# resharper_csharp_align_multiline_calls_chain = false
# resharper_csharp_align_multiline_expression = false
# resharper_csharp_align_multiline_extends_list = false
# resharper_csharp_align_multiline_for_stmt = false
# resharper_csharp_align_multiline_parameter = false
# resharper_csharp_align_multiple_declaration = false
# resharper_csharp_allow_far_alignment = false
# resharper_csharp_empty_block_style = multiline
# resharper_csharp_insert_final_newline = false
# resharper_csharp_keep_existing_enum_arrangement = false
# resharper_csharp_keep_nontrivial_alias = false
# resharper_csharp_max_line_length = 120
# resharper_csharp_new_line_before_while = false
# resharper_csharp_prefer_qualified_reference = false
# resharper_csharp_wrap_lines = true
# resharper_cxxcli_property_declaration_braces = next_line
# resharper_declaration_body_on_the_same_line = if_owner_is_single_line
# resharper_default_exception_variable_name = e
# resharper_delete_quotes_from_solid_values = false
# resharper_disable_blank_line_changes = false
# resharper_disable_formatter = false
# resharper_disable_indenter = false
# resharper_disable_int_align = false
# resharper_disable_line_break_changes = false
# resharper_disable_line_break_removal = false
# resharper_disable_space_changes = false
# resharper_disable_space_changes_before_trailing_comment = false
# resharper_dont_remove_extra_blank_lines = false
# resharper_enable_slate_format = true
# resharper_enable_wrapping = false
# resharper_enforce_line_ending_style = false
# resharper_event_handler_pattern_long = $object$On$event$
# resharper_event_handler_pattern_short = On$event$
# resharper_export_declaration_braces = next_line
# resharper_expression_braces = inside
# resharper_expression_pars = inside
# resharper_extra_spaces = remove_all
# resharper_force_attribute_style = separate
# resharper_force_chop_compound_do_expression = false
# resharper_force_chop_compound_if_expression = false
# resharper_force_chop_compound_while_expression = false
# resharper_formatter_off_tag = @formatter:off
# resharper_formatter_on_tag = @formatter:on
# resharper_formatter_tags_accept_regexp = false
# resharper_formatter_tags_enabled = true
# resharper_format_leading_spaces_decl = false
# resharper_free_block_braces = next_line
# resharper_function_declaration_return_type_style = do_not_change
# resharper_function_definition_return_type_style = do_not_change
# resharper_generator_mode = false
# resharper_ignore_space_preservation = false
# resharper_include_prefix_comment_in_indent = false
# resharper_indent_access_specifiers_from_class = false
# resharper_indent_aligned_ternary = true
# resharper_indent_anonymous_method_block = false
# resharper_indent_braces_inside_statement_conditions = true
# resharper_indent_break_from_case = true
# resharper_indent_case_from_select = true
# resharper_indent_child_elements = OneIndent
# resharper_indent_class_members_from_access_specifiers = false
# resharper_indent_comment = true
# resharper_indent_export_declaration_members = true
# resharper_indent_goto_labels = true
# resharper_indent_inside_namespace = true
# resharper_indent_invocation_pars = inside
# resharper_indent_member_initializer_list = true
# resharper_indent_method_decl_pars = inside
# resharper_indent_nested_fixed_stmt = false
# resharper_indent_nested_foreach_stmt = false
# resharper_indent_nested_for_stmt = false
# resharper_indent_nested_lock_stmt = false
# resharper_indent_nested_usings_stmt = false
# resharper_indent_nested_while_stmt = false
# resharper_indent_pars = inside
# resharper_indent_preprocessor_directives = none
# resharper_indent_preprocessor_if = no_indent
# resharper_indent_preprocessor_other = no_indent
# resharper_indent_preprocessor_region = usual_indent
# resharper_indent_primary_constructor_decl_pars = inside
# resharper_indent_raw_literal_string = align
# resharper_indent_statement_pars = inside
# resharper_indent_text = OneIndent
# resharper_indent_typearg_angles = inside
# resharper_indent_typeparam_angles = inside
# resharper_indent_type_constraints = true
# resharper_indent_wrapped_function_names = false
# resharper_instance_members_qualify_declared_in = this_class, base_class
# resharper_int_align_bitfield_sizes = false
# resharper_int_align_comments = false
# resharper_int_align_declaration_names = false
# resharper_int_align_enum_initializers = false
# resharper_int_align_eq = false
# resharper_int_align_fix_in_adjacent = true
# resharper_keep_blank_lines_in_code = 2
# resharper_keep_blank_lines_in_declarations = 2
# resharper_keep_existing_attribute_arrangement = false
# resharper_keep_existing_declaration_block_arrangement = false
# resharper_keep_existing_declaration_parens_arrangement = true
# resharper_keep_existing_embedded_arrangement = true
# resharper_keep_existing_embedded_block_arrangement = false
# resharper_keep_existing_expr_member_arrangement = true
# resharper_keep_existing_invocation_parens_arrangement = true
# resharper_keep_existing_line_break_before_declaration_body = true
# resharper_keep_existing_list_patterns_arrangement = true
# resharper_keep_existing_primary_constructor_declaration_parens_arrangement = true
# resharper_keep_existing_property_patterns_arrangement = true
# resharper_keep_existing_switch_expression_arrangement = true
# resharper_keep_max_blank_line_around_module_members = 2
# resharper_keep_user_linebreaks = true
# resharper_keep_user_wrapping = true
# resharper_labeled_statement_style = line_break
# resharper_linebreaks_around_razor_statements = true
# resharper_linebreaks_inside_tags_for_elements_longer_than = 2147483647
# resharper_linebreaks_inside_tags_for_elements_with_child_elements = true
# resharper_linebreaks_inside_tags_for_multiline_elements = true
# resharper_linebreak_before_all_elements = false
# resharper_linebreak_before_multiline_elements = true
# resharper_linebreak_before_singleline_elements = false
# resharper_line_break_after_colon_in_member_initializer_lists = do_not_change
# resharper_line_break_after_comma_in_member_initializer_lists = false
# resharper_line_break_after_deref_in_trailing_return_types = do_not_change
# resharper_line_break_after_init_statement = do_not_change
# resharper_line_break_after_type_repr_access_modifier = true
# resharper_line_break_before_comma_in_member_initializer_lists = false
# resharper_line_break_before_deref_in_trailing_return_types = do_not_change
# resharper_line_break_before_function_try_block = do_not_change
# resharper_line_break_before_requires_clause = do_not_change
# resharper_linkage_specification_braces = end_of_line
# resharper_linkage_specification_indentation = none
# resharper_local_function_body = block_body
# resharper_macro_block_begin =
# resharper_macro_block_end =
# resharper_max_array_initializer_elements_on_line = 10000
# resharper_max_attribute_length_for_same_line = 38
# resharper_max_enum_members_on_line = 3
# resharper_max_formal_parameters_on_line = 10000
# resharper_max_initializer_elements_on_line = 4
# resharper_max_invocation_arguments_on_line = 10000
# resharper_max_primary_constructor_parameters_on_line = 10000
# resharper_member_initializer_list_style = do_not_change
# resharper_method_or_operator_body = block_body
# resharper_namespace_declaration_braces = next_line
# resharper_namespace_indentation = all
# resharper_nested_ternary_style = autodetect
# resharper_never_outdent_pipe_operators = true
# resharper_new_line_before_catch = true
# resharper_new_line_before_else = true
# resharper_new_line_before_enumerators = true
# resharper_normalize_tag_names = false
# resharper_no_indent_inside_elements = html,body,thead,tbody,tfoot
# resharper_no_indent_inside_if_element_longer_than = 200
# resharper_null_checking_pattern_style = not_null_pattern
# resharper_object_creation_when_type_evident = target_typed
# resharper_object_creation_when_type_not_evident = explicitly_typed
# resharper_old_engine = false
# resharper_outdent_binary_operators = true
# resharper_outdent_binary_ops = false
# resharper_outdent_binary_pattern_ops = false
# resharper_outdent_commas = false
# resharper_outdent_dots = false
# resharper_outdent_namespace_member = false
# resharper_outdent_statement_labels = false
# resharper_outdent_ternary_ops = false
# resharper_parentheses_non_obvious_operations = none, shift, bitwise_and, bitwise_exclusive_or, bitwise_inclusive_or, bitwise
# resharper_parentheses_redundancy_style = remove_if_not_clarifies_precedence
# resharper_parentheses_same_type_operations = false
# resharper_pi_attributes_indent = align_by_first_attribute
# resharper_place_accessorholder_attribute_on_same_line = if_owner_is_single_line
# resharper_place_accessor_attribute_on_same_line = if_owner_is_single_line
# resharper_place_comments_at_first_column = false
# resharper_place_constructor_initializer_on_same_line = true
# resharper_place_event_attribute_on_same_line = false
# resharper_place_expr_accessor_on_single_line = if_owner_is_single_line
# resharper_place_expr_method_on_single_line = if_owner_is_single_line
# resharper_place_expr_property_on_single_line = if_owner_is_single_line
# resharper_place_field_attribute_on_same_line = true
# resharper_place_linq_into_on_new_line = true
# resharper_place_method_attribute_on_same_line = false
# resharper_place_namespace_definitions_on_same_line = false
# resharper_place_primary_constructor_initializer_on_same_line = true
# resharper_place_property_attribute_on_same_line = false
# resharper_place_record_field_attribute_on_same_line = if_owner_is_single_line
# resharper_place_simple_case_statement_on_same_line = false
# resharper_place_simple_embedded_statement_on_same_line = if_owner_is_single_line
# resharper_place_simple_initializer_on_single_line = true
# resharper_place_simple_list_pattern_on_single_line = true
# resharper_place_simple_property_pattern_on_single_line = true
# resharper_place_simple_switch_expression_on_single_line = false
# resharper_place_single_method_argument_lambda_on_same_line = true
# resharper_place_type_attribute_on_same_line = false
# resharper_place_type_constraints_on_same_line = true
# resharper_prefer_explicit_discard_declaration = false
# resharper_prefer_line_break_after_multiline_lparen = true
# resharper_prefer_roslyn_rules_for_parentheses_clarity = false
# resharper_prefer_separate_deconstructed_variables_declaration = false
# resharper_prefer_wrap_around_eq = default
# resharper_preserve_spaces_inside_tags = pre,textarea
# resharper_qualified_using_at_nested_scope = false
# resharper_quote_style = doublequoted
# resharper_remove_blank_lines_near_braces = false
# resharper_remove_blank_lines_near_braces_in_code = true
# resharper_remove_blank_lines_near_braces_in_declarations = true
# resharper_remove_only_unused_aliases = true
# resharper_remove_spaces_on_blank_lines = true
# resharper_remove_this_qualifier = true
# resharper_remove_unused_only_aliases = false
# resharper_requires_expression_braces = next_line
# resharper_resx_allow_far_alignment = false
# resharper_resx_attribute_indent = single_indent
# resharper_resx_insert_final_newline = false
# resharper_resx_linebreak_before_elements =
# resharper_resx_max_blank_lines_between_tags = 0
# resharper_resx_max_line_length = 2147483647
# resharper_resx_pi_attribute_style = do_not_touch
# resharper_resx_space_before_self_closing = false
# resharper_resx_wrap_lines = false
# resharper_resx_wrap_tags_and_pi = false
# resharper_resx_wrap_text = false
# resharper_show_autodetect_configure_formatting_tip = true
# resharper_simple_block_style = do_not_change
# resharper_simple_case_statement_style = do_not_change
# resharper_simple_embedded_statement_style = do_not_change
# resharper_slate_brackets_indent = inside
# resharper_slate_brackets_wrap = chop_always
# resharper_slate_wrap_before_bracket = true
# resharper_slate_wrap_chained_binary_expression = chop_if_long
# resharper_slate_wrap_chained_member_access = chop_if_long
# resharper_sort_attributes = false
# resharper_sort_class_selectors = false
# resharper_sort_usings = true
# resharper_spaces_around_eq_in_attribute = false
# resharper_spaces_around_eq_in_pi_attribute = false
# resharper_spaces_inside_tags = false
# resharper_space_after_attributes = true
# resharper_space_after_attribute_target_colon = true
# resharper_space_after_cast = false
# resharper_space_after_colon = true
# resharper_space_after_colon_in_bitfield_declarator = true
# resharper_space_after_colon_in_case = true
# resharper_space_after_colon_in_inheritance_clause = true
# resharper_space_after_comma = true
# resharper_space_after_ellipsis_in_parameter_pack = true
# resharper_space_after_for_colon = true
# resharper_space_after_keywords_in_control_flow_statements = true
# resharper_space_after_last_attribute = false
# resharper_space_after_last_pi_attribute = false
# resharper_space_after_operator_keyword = true
# resharper_space_after_operator_not = false
# resharper_space_after_ptr_in_data_member = true
# resharper_space_after_ptr_in_data_members = false
# resharper_space_after_ptr_in_method = true
# resharper_space_after_ptr_in_nested_declarator = false
# resharper_space_after_ref_in_data_member = true
# resharper_space_after_ref_in_data_members = false
# resharper_space_after_ref_in_method = true
# resharper_space_after_semicolon_in_for_statement = true
# resharper_space_after_slate_operator = true
# resharper_space_after_ternary_colon = true
# resharper_space_after_ternary_quest = true
# resharper_space_after_triple_slash = true
# resharper_space_after_type_parameter_constraint_colon = true
# resharper_space_around_additive_op = true
# resharper_space_around_alias_eq = true
# resharper_space_around_assignment_op = true
# resharper_space_around_assignment_operator = true
# resharper_space_around_deref_in_trailing_return_type = true
# resharper_space_around_lambda_arrow = true
# resharper_space_around_member_access_operator = false
# resharper_space_around_relational_op = true
# resharper_space_around_shift_op = true
# resharper_space_around_stmt_colon = true
# resharper_space_around_ternary_operator = true
# resharper_space_before_array_rank_parentheses = false
# resharper_space_before_attribute_target_colon = false
# resharper_space_before_checked_parentheses = false
# resharper_space_before_colon = false
# resharper_space_before_colon_in_bitfield_declarator = true
# resharper_space_before_colon_in_case = false
# resharper_space_before_colon_in_ctor_initializer = true
# resharper_space_before_colon_in_inheritance_clause = true
# resharper_space_before_comma = false
# resharper_space_before_default_parentheses = false
# resharper_space_before_ellipsis_in_parameter_pack = false
# resharper_space_before_empty_invocation_parentheses = false
# resharper_space_before_empty_method_parentheses = false
# resharper_space_before_for_colon = true
# resharper_space_before_initializer_braces = false
# resharper_space_before_invocation_parentheses = false
# resharper_space_before_label_colon = false
# resharper_space_before_lambda_parentheses = false
# resharper_space_before_method_parentheses = false
# resharper_space_before_nameof_parentheses = false
# resharper_space_before_new_parentheses = false
# resharper_space_before_nullable_mark = false
# resharper_space_before_open_square_brackets = false
# resharper_space_before_pointer_asterik_declaration = false
# resharper_space_before_postfix_operator = false
# resharper_space_before_ptr_in_abstract_decl = false
# resharper_space_before_ptr_in_data_member = false
# resharper_space_before_ptr_in_data_members = true
# resharper_space_before_ptr_in_method = false
# resharper_space_before_ref_in_abstract_decl = false
# resharper_space_before_ref_in_data_member = false
# resharper_space_before_ref_in_data_members = true
# resharper_space_before_ref_in_method = false
# resharper_space_before_semicolon = false
# resharper_space_before_semicolon_in_for_statement = false
# resharper_space_before_singleline_accessorholder = true
# resharper_space_before_sizeof_parentheses = false
# resharper_space_before_template_args = false
# resharper_space_before_template_params = true
# resharper_space_before_ternary_colon = true
# resharper_space_before_ternary_quest = true
# resharper_space_before_trailing_comment = true
# resharper_space_before_trailing_comment_text = false
# resharper_space_before_typeof_parentheses = false
# resharper_space_before_type_argument_angle = false
# resharper_space_before_type_parameter_angle = false
# resharper_space_before_type_parameter_constraint_colon = true
# resharper_space_before_type_parameter_parentheses = true
# resharper_space_between_accessors_in_singleline_property = true
# resharper_space_between_attribute_sections = true
# resharper_space_between_closing_angle_brackets_in_template_args = false
# resharper_space_between_keyword_and_expression = true
# resharper_space_between_keyword_and_type = true
# resharper_space_between_method_call_empty_parameter_list_parentheses = false
# resharper_space_between_method_call_name_and_opening_parenthesis = false
# resharper_space_between_method_call_parameter_list_parentheses = false
# resharper_space_between_method_declaration_empty_parameter_list_parentheses = false
# resharper_space_between_method_declaration_name_and_open_parenthesis = false
# resharper_space_between_method_declaration_parameter_list_parentheses = false
# resharper_space_between_parentheses_of_control_flow_statements = false
# resharper_space_between_square_brackets = false
# resharper_space_between_typecast_parentheses = false
# resharper_space_in_singleline_accessorholder = true
# resharper_space_in_singleline_anonymous_method = true
# resharper_space_in_singleline_method = true
# resharper_space_near_postfix_and_prefix_op = false
# resharper_space_within_array_initialization_braces = false
# resharper_space_within_array_rank_empty_parentheses = false
# resharper_space_within_array_rank_parentheses = false
# resharper_space_within_attribute_angles = false
# resharper_space_within_checked_parentheses = false
# resharper_space_within_declaration_parentheses = false
# resharper_space_within_default_parentheses = false
# resharper_space_within_empty_blocks = false
# resharper_space_within_empty_braces = true
# resharper_space_within_empty_initializer_braces = false
# resharper_space_within_empty_invocation_parentheses = false
# resharper_space_within_empty_method_parentheses = false
# resharper_space_within_empty_template_params = false
# resharper_space_within_expression_parentheses = false
# resharper_space_within_initializer_braces = false
# resharper_space_within_invocation_parentheses = false
# resharper_space_within_method_parentheses = false
# resharper_space_within_nameof_parentheses = false
# resharper_space_within_new_parentheses = false
# resharper_space_within_parentheses = false
# resharper_space_within_single_line_array_initializer_braces = true
# resharper_space_within_sizeof_parentheses = false
# resharper_space_within_slice_pattern = true
# resharper_space_within_template_args = false
# resharper_space_within_template_params = false
# resharper_space_within_tuple_parentheses = false
# resharper_space_within_typeof_parentheses = false
# resharper_space_within_type_argument_angles = false
# resharper_space_within_type_parameter_angles = false
# resharper_space_within_type_parameter_parentheses = false
# resharper_special_else_if_treatment = true
# resharper_static_members_qualify_members = none
# resharper_static_members_qualify_with = declared_type
# resharper_stick_comment = true
# resharper_support_vs_event_naming_pattern = true
# resharper_toplevel_function_declaration_return_type_style = do_not_change
# resharper_toplevel_function_definition_return_type_style = do_not_change
# resharper_trailing_comma_in_multiline_lists = false
# resharper_trailing_comma_in_singleline_lists = false
# resharper_treat_case_statement_with_break_as_simple = true
# resharper_use_continuous_indent_inside_initializer_braces = true
# resharper_use_continuous_indent_inside_parens = true
# resharper_use_continuous_line_indent_in_expression_braces = false
# resharper_use_continuous_line_indent_in_method_pars = false
# resharper_use_heuristics_for_body_style = true
# resharper_use_indents_from_main_language_in_file = true
# resharper_use_indent_from_previous_element = true
# resharper_use_indent_from_vs = false
# resharper_use_old_engine = false
# resharper_use_roslyn_logic_for_evident_types = false
# resharper_wrap_after_binary_opsign = true
# resharper_wrap_after_declaration_lpar = false
# resharper_wrap_after_dot = false
# resharper_wrap_after_dot_in_method_calls = false
# resharper_wrap_after_expression_lbrace = true
# resharper_wrap_after_invocation_lpar = false
# resharper_wrap_after_primary_constructor_declaration_lpar = true
# resharper_wrap_after_property_in_chained_method_calls = false
# resharper_wrap_arguments = wrap_if_long
# resharper_wrap_arguments_style = wrap_if_long
# resharper_wrap_around_elements = true
# resharper_wrap_array_initializer_style = wrap_if_long
# resharper_wrap_base_clause_style = wrap_if_long
# resharper_wrap_before_arrow_with_expressions = false
# resharper_wrap_before_binary_opsign = false
# resharper_wrap_before_binary_pattern_op = true
# resharper_wrap_before_colon = false
# resharper_wrap_before_comma = false
# resharper_wrap_before_comma_in_base_clause = false
# resharper_wrap_before_declaration_lpar = false
# resharper_wrap_before_declaration_rpar = false
# resharper_wrap_before_eq = false
# resharper_wrap_before_expression_rbrace = true
# resharper_wrap_before_extends_colon = false
# resharper_wrap_before_first_method_call = false
# resharper_wrap_before_first_type_parameter_constraint = false
# resharper_wrap_before_invocation_lpar = false
# resharper_wrap_before_invocation_rpar = false
# resharper_wrap_before_linq_expression = false
# resharper_wrap_before_primary_constructor_declaration_lpar = false
# resharper_wrap_before_primary_constructor_declaration_rpar = false
# resharper_wrap_before_ternary_opsigns = true
# resharper_wrap_before_type_parameter_langle = false
# resharper_wrap_braced_init_list_style = wrap_if_long
# resharper_wrap_chained_binary_expressions = wrap_if_long
# resharper_wrap_chained_binary_patterns = wrap_if_long
# resharper_wrap_chained_method_calls = wrap_if_long
# resharper_wrap_comments = false
# resharper_wrap_ctor_initializer_style = wrap_if_long
# resharper_wrap_enumeration_style = chop_if_long
# resharper_wrap_enum_declaration = chop_always
# resharper_wrap_extends_list_style = wrap_if_long
# resharper_wrap_for_stmt_header_style = chop_if_long
# resharper_wrap_list_pattern = wrap_if_long
# resharper_wrap_multiple_declaration_style = chop_if_long
# resharper_wrap_multiple_type_parameter_constraints_style = chop_if_long
# resharper_wrap_object_and_collection_initializer_style = chop_if_long
# resharper_wrap_parameters_style = wrap_if_long
# resharper_wrap_primary_constructor_parameters_style = chop_if_long
# resharper_wrap_property_pattern = chop_if_long
# resharper_wrap_switch_expression = chop_always
# resharper_wrap_ternary_expr_style = chop_if_long
# resharper_wrap_verbatim_interpolated_strings = no_wrap
# resharper_xmldoc_allow_far_alignment = false
# resharper_xmldoc_attribute_indent = single_indent
# resharper_xmldoc_insert_final_newline = false
# resharper_xmldoc_linebreak_before_elements = summary,remarks,example,returns,param,typeparam,value,para
# resharper_xmldoc_max_blank_lines_between_tags = 0
# resharper_xmldoc_max_line_length = 120
# resharper_xmldoc_pi_attribute_style = do_not_touch
# resharper_xmldoc_space_before_self_closing = true
# resharper_xmldoc_wrap_lines = true
# resharper_xmldoc_wrap_tags_and_pi = true
# resharper_xmldoc_wrap_text = true
# resharper_xml_allow_far_alignment = false
# resharper_xml_attribute_indent = align_by_first_attribute
# resharper_xml_insert_final_newline = false
# resharper_xml_linebreak_before_elements =
# resharper_xml_max_blank_lines_between_tags = 2
# resharper_xml_max_line_length = 120
# resharper_xml_pi_attribute_style = do_not_touch
# resharper_xml_space_before_self_closing = true
# resharper_xml_wrap_lines = true
# resharper_xml_wrap_tags_and_pi = true
# resharper_xml_wrap_text = false
#
# # ReSharper inspection severities
# resharper_access_rights_in_text_highlighting = warning
# resharper_access_to_disposed_closure_highlighting = warning
# resharper_access_to_for_each_variable_in_closure_highlighting = warning
# resharper_access_to_modified_closure_highlighting = warning
# resharper_access_to_static_member_via_derived_type_highlighting = warning
# resharper_address_of_marshal_by_ref_object_highlighting = warning
# resharper_all_underscore_local_parameter_name_highlighting = warning
# resharper_angular_html_banana_highlighting = warning
# resharper_annotate_can_be_null_parameter_highlighting = none
# resharper_annotate_can_be_null_type_member_highlighting = none
# resharper_annotate_not_null_parameter_highlighting = none
# resharper_annotate_not_null_type_member_highlighting = none
# resharper_annotation_conflict_in_hierarchy_highlighting = warning
# resharper_annotation_redundancy_at_value_type_highlighting = warning
# resharper_annotation_redundancy_in_hierarchy_highlighting = warning
# resharper_anonymous_object_destructuring_problem_highlighting = warning
# resharper_append_to_collection_expression_highlighting = suggestion
# resharper_arguments_style_anonymous_function_highlighting = none
# resharper_arguments_style_literal_highlighting = none
# resharper_arguments_style_named_expression_highlighting = none
# resharper_arguments_style_other_highlighting = none
# resharper_arguments_style_string_literal_highlighting = none
# resharper_arrange_accessor_owner_body_highlighting = suggestion
# resharper_arrange_attributes_highlighting = none
# resharper_arrange_constructor_or_destructor_body_highlighting = none
# resharper_arrange_local_function_body_highlighting = none
# resharper_arrange_method_or_operator_body_highlighting = none
# resharper_arrange_namespace_body_highlighting = hint
# resharper_arrange_null_checking_pattern_highlighting = hint
# resharper_arrange_object_creation_when_type_evident_highlighting = suggestion
# resharper_arrange_object_creation_when_type_not_evident_highlighting = hint
# resharper_arrange_redundant_parentheses_highlighting = hint
# resharper_arrange_static_member_qualifier_highlighting = hint
# resharper_arrange_this_qualifier_highlighting = hint
# resharper_arrange_trailing_comma_in_multiline_lists_highlighting = hint
# resharper_arrange_trailing_comma_in_singleline_lists_highlighting = hint
# resharper_arrange_type_member_modifiers_highlighting = hint
# resharper_arrange_type_modifiers_highlighting = hint
# resharper_arrange_var_keywords_in_deconstructing_declaration_highlighting = suggestion
# resharper_asp_content_placeholder_not_resolved_highlighting = error
# resharper_asp_custom_page_parser_filter_type_highlighting = warning
# resharper_asp_dead_code_highlighting = warning
# resharper_asp_entity_highlighting = warning
# resharper_asp_image_highlighting = warning
# resharper_asp_invalid_control_type_highlighting = error
# resharper_asp_not_resolved_highlighting = error
# resharper_asp_ods_method_reference_resolve_error_highlighting = error
# resharper_asp_resolve_warning_highlighting = warning
# resharper_asp_skin_not_resolved_highlighting = error
# resharper_asp_tag_attribute_with_optional_value_highlighting = warning
# resharper_asp_theme_not_resolved_highlighting = error
# resharper_asp_unused_register_directive_highlighting_highlighting = warning
# resharper_asp_warning_highlighting = warning
# resharper_assignment_instead_of_discard_highlighting = warning
# resharper_assignment_in_conditional_expression_highlighting = warning
# resharper_assignment_is_fully_discarded_highlighting = warning
# resharper_assign_null_to_not_null_attribute_highlighting = warning
# resharper_asxx_path_error_highlighting = warning
# resharper_async_iterator_invocation_without_await_foreach_highlighting = warning
# resharper_async_void_event_handler_method_highlighting = suggestion
# resharper_async_void_lambda_highlighting = warning
# resharper_async_void_method_highlighting = suggestion
# resharper_async_void_throw_exception_highlighting = suggestion
# resharper_auto_property_can_be_made_get_only_global_highlighting = suggestion
# resharper_auto_property_can_be_made_get_only_local_highlighting = suggestion
# resharper_bad_attribute_brackets_spaces_highlighting = none
# resharper_bad_braces_spaces_highlighting = none
# resharper_bad_child_statement_indent_highlighting = warning
# resharper_bad_colon_spaces_highlighting = none
# resharper_bad_comma_spaces_highlighting = none
# resharper_bad_control_braces_indent_highlighting = suggestion
# resharper_bad_control_braces_line_breaks_highlighting = none
# resharper_bad_declaration_braces_indent_highlighting = none
# resharper_bad_declaration_braces_line_breaks_highlighting = none
# resharper_bad_empty_braces_line_breaks_highlighting = none
# resharper_bad_expression_braces_indent_highlighting = none
# resharper_bad_expression_braces_line_breaks_highlighting = none
# resharper_bad_generic_brackets_spaces_highlighting = none
# resharper_bad_indent_highlighting = none
# resharper_bad_linq_line_breaks_highlighting = none
# resharper_bad_list_line_breaks_highlighting = none
# resharper_bad_member_access_spaces_highlighting = none
# resharper_bad_namespace_braces_indent_highlighting = none
# resharper_bad_parens_line_breaks_highlighting = none
# resharper_bad_parens_spaces_highlighting = none
# resharper_bad_preprocessor_indent_highlighting = none
# resharper_bad_semicolon_spaces_highlighting = none
# resharper_bad_spaces_after_keyword_highlighting = none
# resharper_bad_square_brackets_spaces_highlighting = none
# resharper_bad_switch_braces_indent_highlighting = none
# resharper_bad_symbol_spaces_highlighting = none
# resharper_base_member_has_params_highlighting = warning
# resharper_base_method_call_with_default_parameter_highlighting = warning
# resharper_base_object_equals_is_object_equals_highlighting = warning
# resharper_base_object_get_hash_code_call_in_get_hash_code_highlighting = warning
# resharper_bitwise_operator_on_enum_without_flags_highlighting = warning
# resharper_blazor_editor_required_highlighting = warning
# resharper_both_context_call_declaration_global_highlighting = warning
# resharper_both_context_call_usage_global_highlighting = warning
# resharper_built_in_type_reference_style_for_member_access_highlighting = hint
# resharper_built_in_type_reference_style_highlighting = hint
# resharper_by_ref_argument_is_volatile_field_highlighting = warning
# resharper_cannot_apply_equality_operator_to_type_highlighting = warning
# resharper_can_replace_cast_with_lambda_return_type_highlighting = hint
# resharper_can_replace_cast_with_shorter_type_argument_highlighting = suggestion
# resharper_can_replace_cast_with_type_argument_highlighting = hint
# resharper_can_replace_cast_with_variable_type_highlighting = hint
# resharper_can_simplify_dictionary_lookup_with_try_add_highlighting = suggestion
# resharper_can_simplify_dictionary_lookup_with_try_get_value_highlighting = suggestion
# resharper_can_simplify_dictionary_removing_with_single_call_highlighting = suggestion
# resharper_can_simplify_dictionary_try_get_value_with_get_value_or_default_highlighting = suggestion
# resharper_can_simplify_is_assignable_from_highlighting = suggestion
# resharper_can_simplify_is_instance_of_type_highlighting = suggestion
# resharper_can_simplify_set_adding_with_single_call_highlighting = suggestion
# resharper_can_simplify_string_escape_sequence_highlighting = hint
# resharper_captured_primary_constructor_parameter_is_mutable_highlighting = warning
# resharper_center_tag_is_obsolete_highlighting = warning
# resharper_check_for_reference_equality_instead_1_highlighting = suggestion
# resharper_check_for_reference_equality_instead_2_highlighting = suggestion
# resharper_check_for_reference_equality_instead_3_highlighting = suggestion
# resharper_check_for_reference_equality_instead_4_highlighting = suggestion
# resharper_check_namespace_highlighting = warning
# resharper_class_cannot_be_instantiated_highlighting = warning
# resharper_class_can_be_sealed_global_highlighting = none
# resharper_class_can_be_sealed_local_highlighting = none
# resharper_class_never_instantiated_global_highlighting = suggestion
# resharper_class_never_instantiated_local_highlighting = suggestion
# resharper_class_with_virtual_members_never_inherited_global_highlighting = suggestion
# resharper_class_with_virtual_members_never_inherited_local_highlighting = suggestion
# resharper_clear_attribute_is_obsolete_all_highlighting = warning
# resharper_clear_attribute_is_obsolete_highlighting = warning
# resharper_collection_never_queried_global_highlighting = warning
# resharper_collection_never_queried_local_highlighting = warning
# resharper_collection_never_updated_global_highlighting = warning
# resharper_collection_never_updated_local_highlighting = warning
# resharper_command_invasion_declaration_global_highlighting = warning
# resharper_command_invasion_usage_global_highlighting = warning
# resharper_compare_non_constrained_generic_with_null_highlighting = none
# resharper_compare_of_floats_by_equality_operator_highlighting = warning
# resharper_complex_object_destructuring_problem_highlighting = warning
# resharper_complex_object_in_context_destructuring_problem_highlighting = warning
# resharper_conditional_access_qualifier_is_non_nullable_according_to_api_contract_highlighting = warning
# resharper_conditional_ternary_equal_branch_highlighting = warning
# resharper_condition_is_always_true_or_false_according_to_nullable_api_contract_highlighting = warning
# resharper_condition_is_always_true_or_false_highlighting = warning
# resharper_conflict_cqrs_attribute_highlighting = warning
# resharper_confusing_char_as_integer_in_constructor_highlighting = warning
# resharper_constant_conditional_access_qualifier_highlighting = warning
# resharper_constant_expected_highlighting = suggestion
# resharper_constant_null_coalescing_condition_highlighting = warning
# resharper_consteval_if_is_always_constant_highlighting = warning
# resharper_constructor_initializer_loop_highlighting = warning
# resharper_constructor_with_must_dispose_resource_attribute_base_is_not_annotated_highlighting = warning
# resharper_container_annotation_redundancy_highlighting = warning
# resharper_contextual_logger_problem_highlighting = warning
# resharper_context_value_is_provided_highlighting = none
# resharper_contract_annotation_not_parsed_highlighting = warning

# resharper_convert_conditional_ternary_expression_to_switch_expression_highlighting = hint
# resharper_convert_constructor_to_member_initializers_highlighting = suggestion
# resharper_convert_if_do_to_while_highlighting = suggestion
# resharper_convert_if_statement_to_null_coalescing_assignment_highlighting = suggestion
# resharper_convert_if_statement_to_null_coalescing_expression_highlighting = suggestion
# resharper_convert_if_statement_to_return_statement_highlighting = hint
# resharper_convert_if_statement_to_switch_statement_highlighting = hint
# resharper_convert_if_to_or_expression_highlighting = suggestion
# resharper_convert_nullable_to_short_form_highlighting = suggestion
# resharper_convert_switch_statement_to_switch_expression_highlighting = hint
# resharper_convert_to_compound_assignment_highlighting = hint
# resharper_convert_to_constant_global_highlighting = hint
# resharper_convert_to_constant_local_highlighting = hint
# resharper_convert_to_lambda_expression_highlighting = suggestion
# resharper_convert_to_null_coalescing_compound_assignment_highlighting = suggestion
# resharper_convert_to_static_class_highlighting = suggestion
# resharper_convert_to_vb_auto_property_highlighting = suggestion
# resharper_convert_to_vb_auto_property_when_possible_highlighting = hint
# resharper_convert_to_vb_auto_property_with_private_setter_highlighting = hint
# resharper_convert_type_check_pattern_to_null_check_highlighting = warning
# resharper_convert_type_check_to_null_check_highlighting = warning
# resharper_co_variant_array_conversion_highlighting = warning
# resharper_cqrs_debug_highlighting = warning
# resharper_cqrs_naming_recommendation_highlighting = warning
# resharper_c_sharp_build_cs_invalid_module_name_highlighting = warning
# resharper_c_sharp_missing_plugin_dependency_highlighting = warning
# resharper_default_struct_equality_is_used_global_highlighting = warning
# resharper_default_struct_equality_is_used_local_highlighting = warning
# resharper_default_value_attribute_for_optional_parameter_highlighting = warning
# resharper_dispose_on_using_variable_highlighting = warning
# resharper_double_negation_in_pattern_highlighting = suggestion
# resharper_double_negation_operator_highlighting = suggestion
# resharper_duplicated_chained_if_bodies_highlighting = hint
# resharper_duplicated_sequential_if_bodies_highlighting = hint
# resharper_duplicated_statements_highlighting = warning
# resharper_duplicated_switch_expression_arms_highlighting = hint
# resharper_duplicated_switch_section_bodies_highlighting = hint
# resharper_duplicate_item_in_logger_template_highlighting = warning
# resharper_duplicate_key_collection_initialization_highlighting = warning
# resharper_duplicate_resource_highlighting = warning
# resharper_empty_constructor_highlighting = warning
# resharper_empty_destructor_highlighting = warning
# resharper_empty_for_statement_highlighting = warning
# resharper_empty_general_catch_clause_highlighting = warning
# resharper_empty_namespace_highlighting = warning
# resharper_empty_region_highlighting = suggestion
# resharper_empty_statement_highlighting = warning
# resharper_empty_title_tag_highlighting = hint
# resharper_entity_framework_client_side_db_function_call_highlighting = warning
# resharper_entity_framework_model_validation_circular_dependency_highlighting = hint
# resharper_entity_framework_model_validation_unlimited_string_length_highlighting = warning
# resharper_entity_framework_n_plus_one_incomplete_data_query_highlighting = suggestion
# resharper_entity_framework_n_plus_one_incomplete_data_usage_highlighting = warning
# resharper_entity_framework_n_plus_one_query_highlighting = suggestion
# resharper_entity_framework_n_plus_one_usage_highlighting = warning
# resharper_entity_framework_unsupported_server_side_function_call_highlighting = warning
# resharper_entity_name_captured_only_global_highlighting = warning
# resharper_entity_name_captured_only_local_highlighting = warning
# resharper_enumerable_sum_in_explicit_unchecked_context_highlighting = warning
# resharper_enum_underlying_type_is_int_highlighting = warning
# resharper_equal_expression_comparison_highlighting = warning
# resharper_escaped_keyword_highlighting = warning
# resharper_event_never_invoked_global_highlighting = suggestion
# resharper_event_never_subscribed_to_global_highlighting = suggestion
# resharper_event_never_subscribed_to_local_highlighting = suggestion
# resharper_event_unsubscription_via_anonymous_delegate_highlighting = warning
# resharper_exception_passed_as_template_argument_problem_highlighting = warning
# resharper_explicit_caller_info_argument_highlighting = warning
# resharper_expression_is_always_null_highlighting = warning
# resharper_extract_common_branching_code_highlighting = hint
# resharper_extract_common_property_pattern_highlighting = hint
# resharper_field_can_be_made_read_only_global_highlighting = suggestion
# resharper_field_can_be_made_read_only_local_highlighting = suggestion
# resharper_field_hides_interface_property_with_default_implementation_highlighting = warning
# resharper_foreach_can_be_converted_to_query_using_another_get_enumerator_highlighting = hint
# resharper_foreach_can_be_partly_converted_to_query_using_another_get_enumerator_highlighting = hint
# resharper_format_specifier_captures_right_braces_highlighting = warning
# resharper_format_string_placeholders_mismatch_highlighting = warning
# resharper_format_string_problem_highlighting = warning
# resharper_for_can_be_converted_to_foreach_highlighting = suggestion
# resharper_for_statement_condition_is_true_highlighting = warning
# resharper_function_complexity_overflow_highlighting = none
# resharper_function_never_returns_highlighting = warning
# resharper_function_recursive_on_all_paths_highlighting = warning
# resharper_gc_suppress_finalize_for_type_without_destructor_highlighting = warning
# resharper_generic_enumerator_not_disposed_highlighting = warning
# resharper_heap_view_boxing_allocation_highlighting = hint
# resharper_heap_view_can_avoid_closure_highlighting = suggestion
# resharper_heap_view_closure_allocation_highlighting = hint
# resharper_heap_view_delegate_allocation_highlighting = hint
# resharper_heap_view_implicit_capture_highlighting = none
# resharper_heap_view_object_allocation_evident_highlighting = hint
# resharper_heap_view_object_allocation_highlighting = hint
# resharper_heap_view_object_allocation_possible_highlighting = hint
# resharper_heap_view_possible_boxing_allocation_highlighting = hint
# resharper_heuristic_unreachable_code_highlighting = warning
# resharper_html_attributes_quotes_highlighting = hint
# resharper_html_attribute_not_resolved_highlighting = warning
# resharper_html_attribute_value_not_resolved_highlighting = warning
# resharper_html_dead_code_highlighting = warning
# resharper_html_event_not_resolved_highlighting = warning
# resharper_html_id_duplication_highlighting = warning
# resharper_html_id_not_resolved_highlighting = warning
# resharper_html_obsolete_highlighting = warning
# resharper_html_path_error_highlighting = warning
# resharper_html_tag_not_closed_highlighting = error
# resharper_html_tag_not_resolved_highlighting = warning
# resharper_html_tag_should_be_self_closed_highlighting = warning
# resharper_html_tag_should_not_be_self_closed_highlighting = warning
# resharper_html_warning_highlighting = warning
# resharper_if_std_is_constant_evaluated_can_be_replaced_highlighting = suggestion
# resharper_ignored_directive_highlighting = warning
# resharper_inactive_preprocessor_branch_highlighting = warning
# resharper_inconsistently_synchronized_field_highlighting = warning
# resharper_inconsistent_context_log_property_naming_highlighting = warning
# resharper_inconsistent_log_property_naming_highlighting = warning
# resharper_inconsistent_naming_highlighting = warning
# resharper_inconsistent_order_of_locks_highlighting = warning
# resharper_incorrect_blank_lines_near_braces_highlighting = none
# resharper_incorrect_constant_expected_annotation_highlighting = error
# resharper_indexing_by_invalid_range_highlighting = warning
# resharper_inheritdoc_consider_usage_highlighting = none
# resharper_inheritdoc_invalid_usage_highlighting = warning
# resharper_inline_temporary_variable_highlighting = hint
# resharper_internal_or_private_member_not_documented_highlighting = none
# resharper_interpolated_string_expression_is_not_i_formattable_highlighting = warning
# resharper_introduce_optional_parameters_global_highlighting = suggestion
# resharper_introduce_optional_parameters_local_highlighting = suggestion
# resharper_int_division_by_zero_highlighting = warning
# resharper_int_variable_overflow_highlighting = warning
# resharper_int_variable_overflow_in_checked_context_highlighting = warning
# resharper_int_variable_overflow_in_unchecked_context_highlighting = warning
# resharper_invalid_value_type_highlighting = warning
# resharper_invalid_xml_doc_comment_highlighting = warning
# resharper_invert_condition_1_highlighting = hint
# resharper_invert_if_highlighting = hint
# resharper_invocation_is_skipped_highlighting = hint
# resharper_invoke_as_extension_method_highlighting = suggestion
# resharper_in_parameter_with_must_dispose_resource_attribute_highlighting = warning
# resharper_is_expression_always_false_highlighting = warning
# resharper_is_expression_always_true_highlighting = warning
# resharper_iterator_method_result_is_ignored_highlighting = warning
# resharper_iterator_never_returns_highlighting = warning
# resharper_join_declaration_and_initializer_highlighting = suggestion
# resharper_lambda_expression_can_be_made_static_highlighting = none
# resharper_lambda_expression_must_be_static_highlighting = suggestion
# resharper_lambda_should_not_capture_context_highlighting = warning
# resharper_localizable_element_highlighting = warning
# resharper_local_function_can_be_made_static_highlighting = none
# resharper_local_function_hides_method_highlighting = warning
# resharper_local_variable_hides_member_highlighting = warning
# resharper_local_variable_hides_primary_constructor_parameter_highlighting = warning
# resharper_log_message_is_sentence_problem_highlighting = warning
# resharper_long_literal_ending_lower_l_highlighting = warning
# resharper_loop_can_be_converted_to_query_highlighting = hint
# resharper_loop_can_be_partly_converted_to_query_highlighting = none
# resharper_loop_variable_is_never_changed_inside_loop_highlighting = warning
# resharper_math_abs_method_is_redundant_highlighting = warning
# resharper_math_clamp_min_greater_than_max_highlighting = warning
# resharper_meaningless_default_parameter_value_highlighting = warning
# resharper_member_can_be_file_local_highlighting = none
# resharper_member_can_be_internal_highlighting = none
# resharper_member_can_be_made_static_global_highlighting = hint
# resharper_member_can_be_made_static_local_highlighting = hint
# resharper_member_can_be_private_global_highlighting = suggestion
# resharper_member_can_be_private_local_highlighting = suggestion
# resharper_member_can_be_protected_global_highlighting = suggestion
# resharper_member_can_be_protected_local_highlighting = suggestion
# resharper_member_hides_interface_member_with_default_implementation_highlighting = warning
# resharper_member_hides_static_from_outer_class_highlighting = warning
# resharper_member_initializer_value_ignored_highlighting = warning
# resharper_merge_and_pattern_highlighting = suggestion
# resharper_merge_cast_with_type_check_highlighting = suggestion
# resharper_merge_into_logical_pattern_highlighting = hint
# resharper_merge_into_negated_pattern_highlighting = hint
# resharper_merge_into_pattern_highlighting = suggestion
# resharper_merge_nested_property_patterns_highlighting = suggestion
# resharper_merge_sequential_checks_highlighting = hint
# resharper_method_has_async_overload_highlighting = suggestion
# resharper_method_has_async_overload_with_cancellation_highlighting = suggestion
# resharper_method_overload_with_optional_parameter_highlighting = warning
# resharper_method_supports_cancellation_highlighting = suggestion
# resharper_misleading_body_like_statement_highlighting = warning
# resharper_mismatched_asmdef_filename_highlighting = suggestion
# resharper_missing_alt_attribute_in_img_tag_highlighting = hint
# resharper_missing_blank_lines_highlighting = none
# resharper_missing_body_tag_highlighting = warning
# resharper_missing_head_and_body_tags_highlighting = warning
# resharper_missing_head_tag_highlighting = warning
# resharper_missing_indent_highlighting = none
# resharper_missing_linebreak_highlighting = none
# resharper_missing_space_highlighting = none
# resharper_more_specific_foreach_variable_type_available_highlighting = suggestion
# resharper_move_local_function_after_jump_statement_highlighting = hint
# resharper_move_to_existing_positional_deconstruction_pattern_highlighting = hint
# resharper_move_variable_declaration_inside_loop_condition_highlighting = suggestion
# resharper_multiple_cqrs_entity_highlighting = warning
# resharper_multiple_nullable_attributes_usage_highlighting = warning
# resharper_multiple_order_by_highlighting = warning
# resharper_multiple_resolve_candidates_in_text_highlighting = warning
# resharper_multiple_spaces_highlighting = none
# resharper_multiple_statements_on_one_line_highlighting = none
# resharper_multiple_type_members_on_one_line_highlighting = none
# resharper_must_use_return_value_highlighting = warning
# resharper_mvc_action_not_resolved_highlighting = warning
# resharper_mvc_area_not_resolved_highlighting = warning
# resharper_mvc_controller_not_resolved_highlighting = warning
# resharper_mvc_invalid_model_type_highlighting = error
# resharper_mvc_masterpage_not_resolved_highlighting = warning
# resharper_mvc_partial_view_not_resolved_highlighting = warning
# resharper_mvc_template_not_resolved_highlighting = warning
# resharper_mvc_view_component_not_resolved_highlighting = warning
# resharper_mvc_view_component_view_not_resolved_highlighting = warning
# resharper_mvc_view_not_resolved_highlighting = warning
# resharper_negation_of_relational_pattern_highlighting = suggestion
# resharper_negative_equality_expression_highlighting = suggestion
# resharper_negative_index_highlighting = warning
# resharper_nested_record_update_can_be_simplified_highlighting = suggestion
# resharper_nested_string_interpolation_highlighting = suggestion
# resharper_non_atomic_compound_operator_highlighting = warning
# resharper_non_constant_equality_expression_has_constant_result_highlighting = warning
# resharper_non_parsable_element_highlighting = warning
# resharper_non_readonly_member_in_get_hash_code_highlighting = warning
# resharper_non_volatile_field_in_double_check_locking_highlighting = warning
# resharper_not_accessed_field_global_highlighting = suggestion
# resharper_not_accessed_field_local_highlighting = warning
# resharper_not_accessed_out_parameter_variable_highlighting = warning
# resharper_not_accessed_positional_property_global_highlighting = warning
# resharper_not_accessed_positional_property_local_highlighting = warning
# resharper_not_accessed_variable_highlighting = warning
# resharper_not_assigned_out_parameter_highlighting = warning
# resharper_not_declared_in_parent_culture_highlighting = warning
# resharper_not_disposed_resource_highlighting = warning
# resharper_not_disposed_resource_is_returned_by_property_highlighting = warning
# resharper_not_disposed_resource_is_returned_highlighting = suggestion
# resharper_not_null_or_required_member_is_not_initialized_highlighting = warning
# resharper_not_observable_annotation_redundancy_highlighting = warning
# resharper_not_overridden_in_specific_culture_highlighting = warning
# resharper_not_resolved_in_text_highlighting = warning
# resharper_no_support_for_vb_highlighting = warning
# resharper_nullable_warning_suppression_is_used_highlighting = none
# resharper_nullness_annotation_conflict_with_jet_brains_annotations_highlighting = warning
# resharper_null_coalescing_condition_is_always_not_null_according_to_api_contract_highlighting = warning
# resharper_n_unit_async_method_must_be_task_highlighting = warning
# resharper_n_unit_attribute_produces_too_many_tests_highlighting = none
# resharper_n_unit_auto_fixture_incorrect_argument_type_highlighting = warning
# resharper_n_unit_auto_fixture_missed_test_attribute_highlighting = warning
# resharper_n_unit_auto_fixture_missed_test_or_test_fixture_attribute_highlighting = warning
# resharper_n_unit_auto_fixture_redundant_argument_in_inline_auto_data_attribute_highlighting = warning
# resharper_n_unit_duplicate_values_highlighting = warning
# resharper_n_unit_ignored_parameter_attribute_highlighting = warning
# resharper_n_unit_implicit_unspecified_null_values_highlighting = warning
# resharper_n_unit_incorrect_argument_type_highlighting = warning
# resharper_n_unit_incorrect_expected_result_type_highlighting = warning
# resharper_n_unit_incorrect_range_bounds_highlighting = warning
# resharper_n_unit_method_with_parameters_and_test_attribute_highlighting = warning
# resharper_n_unit_missing_arguments_in_test_case_attribute_highlighting = warning
# resharper_n_unit_missing_cancel_after_attribute_highlighting = warning
# resharper_n_unit_non_public_method_with_test_attribute_highlighting = warning
# resharper_n_unit_no_values_provided_highlighting = warning
# resharper_n_unit_parameter_type_is_not_compatible_with_attribute_highlighting = warning
# resharper_n_unit_range_attribute_bounds_are_out_of_range_highlighting = warning
# resharper_n_unit_range_step_sign_mismatch_highlighting = warning
# resharper_n_unit_range_step_value_must_not_be_zero_highlighting = warning
# resharper_n_unit_range_to_value_is_not_reachable_highlighting = warning
# resharper_n_unit_redundant_argument_instead_of_expected_result_highlighting = warning
# resharper_n_unit_redundant_argument_in_test_case_attribute_highlighting = warning
# resharper_n_unit_redundant_expected_result_in_test_case_attribute_highlighting = warning
# resharper_n_unit_test_case_attribute_requires_expected_result_highlighting = warning
# resharper_n_unit_test_case_result_property_duplicates_expected_result_highlighting = warning
# resharper_n_unit_test_case_result_property_is_obsolete_highlighting = warning
# resharper_n_unit_test_case_source_must_be_field_property_method_highlighting = warning
# resharper_n_unit_test_case_source_must_be_static_highlighting = warning
# resharper_n_unit_test_case_source_should_implement_i_enumerable_highlighting = warning
# resharper_object_creation_as_statement_highlighting = warning
# resharper_obsolete_element_error_highlighting = error
# resharper_obsolete_element_highlighting = warning
# resharper_one_way_operation_contract_with_return_type_highlighting = warning
# resharper_operation_contract_without_service_contract_highlighting = warning
# resharper_operator_is_can_be_used_highlighting = warning
# resharper_operator_without_matched_checked_operator_highlighting = warning
# resharper_optional_parameter_hierarchy_mismatch_highlighting = warning
# resharper_optional_parameter_ref_out_highlighting = warning
# resharper_other_tags_inside_script1_highlighting = error
# resharper_other_tags_inside_script2_highlighting = error
# resharper_other_tags_inside_unclosed_script_highlighting = error
# resharper_outdent_is_off_prev_level_highlighting = none
# resharper_out_parameter_value_is_always_discarded_global_highlighting = suggestion
# resharper_out_parameter_value_is_always_discarded_local_highlighting = warning
# resharper_out_parameter_with_handles_resource_disposal_attribute_highlighting = warning
# resharper_overridden_with_empty_value_highlighting = warning
# resharper_overridden_with_same_value_highlighting = suggestion
# resharper_parameter_hides_member_highlighting = warning
# resharper_parameter_hides_primary_constructor_parameter_highlighting = warning
# resharper_parameter_only_used_for_precondition_check_global_highlighting = suggestion
# resharper_parameter_only_used_for_precondition_check_local_highlighting = warning
# resharper_parameter_type_can_be_enumerable_global_highlighting = none
# resharper_parameter_type_can_be_enumerable_local_highlighting = none
# resharper_partial_method_parameter_name_mismatch_highlighting = warning
# resharper_partial_method_with_single_part_highlighting = warning
# resharper_partial_type_with_single_part_highlighting = warning
# resharper_pass_string_interpolation_highlighting = hint
# resharper_pattern_always_matches_highlighting = warning
# resharper_pattern_is_always_true_or_false_highlighting = warning
# resharper_pattern_is_redundant_highlighting = warning
# resharper_pattern_never_matches_highlighting = warning
# resharper_place_assignment_expression_into_block_highlighting = none
# resharper_polymorphic_field_like_event_invocation_highlighting = warning
# resharper_positional_property_used_problem_highlighting = warning
# resharper_possible_infinite_inheritance_highlighting = warning
# resharper_possible_intended_rethrow_highlighting = warning
# resharper_possible_interface_member_ambiguity_highlighting = warning
# resharper_possible_invalid_cast_exception_highlighting = warning
# resharper_possible_invalid_cast_exception_in_foreach_loop_highlighting = warning
# resharper_possible_invalid_operation_exception_collection_was_modified_highlighting = warning
# resharper_possible_invalid_operation_exception_highlighting = warning
# resharper_possible_loss_of_fraction_highlighting = warning
# resharper_possible_mistaken_call_to_get_type_highlighting = warning
# resharper_possible_mistaken_system_type_argument_highlighting = warning
# resharper_possible_multiple_enumeration_highlighting = warning
# resharper_possible_multiple_write_access_in_double_check_locking_highlighting = warning
# resharper_possible_null_reference_exception_highlighting = warning
# resharper_possible_struct_member_modification_of_non_variable_struct_highlighting = warning
# resharper_possible_unintended_linear_search_in_set_highlighting = warning
# resharper_possible_unintended_queryable_as_enumerable_highlighting = suggestion
# resharper_possible_unintended_reference_comparison_highlighting = warning
# resharper_possible_write_to_me_highlighting = warning
# resharper_possibly_impure_method_call_on_readonly_variable_highlighting = warning
# resharper_possibly_missing_indexer_initializer_comma_highlighting = warning
# resharper_possibly_mistaken_use_of_cancellation_token_highlighting = warning
# resharper_possibly_mistaken_use_of_interpolated_string_insert_highlighting = warning
# resharper_possibly_unintended_side_effects_inside_conditional_invocation_highlighting = warning
# resharper_possibly_unintended_usage_parameterless_get_expression_type_highlighting = error
# resharper_prefer_concrete_value_over_default_highlighting = suggestion
# resharper_primary_constructor_parameter_capture_disallowed_highlighting = none
# resharper_private_field_can_be_converted_to_local_variable_highlighting = warning
# resharper_property_can_be_made_init_only_global_highlighting = suggestion
# resharper_property_can_be_made_init_only_local_highlighting = suggestion
# resharper_property_field_keyword_is_never_assigned_highlighting = warning
# resharper_property_field_keyword_is_never_used_highlighting = warning
# resharper_property_not_resolved_highlighting = error
# resharper_public_constructor_in_abstract_class_highlighting = suggestion
# resharper_pure_attribute_on_void_method_highlighting = warning
# resharper_query_invasion_declaration_global_highlighting = warning
# resharper_query_invasion_usage_global_highlighting = warning
# resharper_raw_string_can_be_simplified_highlighting = hint
# resharper_razor_assembly_not_resolved_highlighting = warning
# resharper_razor_layout_not_resolved_highlighting = error
# resharper_razor_null_conditional_operator_highlighting_highlighting = warning
# resharper_razor_section_not_resolved_highlighting = error
# resharper_razor_unresolved_component_highlighting = warning
# resharper_read_access_in_double_check_locking_highlighting = warning
# resharper_redundant_abstract_modifier_highlighting = warning
# resharper_redundant_accessor_body_highlighting = suggestion
# resharper_redundant_always_match_subpattern_highlighting = suggestion
# resharper_redundant_argument_default_value_highlighting = warning
# resharper_redundant_array_creation_expression_highlighting = hint
# resharper_redundant_array_lower_bound_specification_highlighting = warning
# resharper_redundant_assignment_highlighting = warning
# resharper_redundant_attribute_parentheses_highlighting = hint
# resharper_redundant_attribute_suffix_highlighting = warning
# resharper_redundant_attribute_usage_property_highlighting = suggestion
# resharper_redundant_base_constructor_call_highlighting = warning
# resharper_redundant_base_qualifier_highlighting = warning
# resharper_redundant_blank_lines_highlighting = none
# resharper_redundant_bool_compare_highlighting = warning
# resharper_redundant_caller_argument_expression_default_value_highlighting = warning
# resharper_redundant_case_label_highlighting = warning
# resharper_redundant_cast_highlighting = warning
# resharper_redundant_catch_clause_highlighting = warning
# resharper_redundant_check_before_assignment_highlighting = warning
# resharper_redundant_collection_copy_call_highlighting = warning
# resharper_redundant_collection_initializer_element_braces_highlighting = hint
# resharper_redundant_configure_await_highlighting = suggestion
# resharper_redundant_cqrs_attribute_highlighting = warning
# resharper_redundant_declaration_semicolon_highlighting = hint
# resharper_redundant_default_member_initializer_highlighting = warning
# resharper_redundant_delegate_creation_highlighting = warning
# resharper_redundant_dictionary_contains_key_before_adding_highlighting = warning
# resharper_redundant_disable_warning_comment_highlighting = warning
# resharper_redundant_discard_designation_highlighting = suggestion
# resharper_redundant_empty_case_else_highlighting = warning
# resharper_redundant_empty_finally_block_highlighting = warning
# resharper_redundant_empty_object_creation_argument_list_highlighting = hint
# resharper_redundant_empty_object_or_collection_initializer_highlighting = warning
# resharper_redundant_empty_switch_section_highlighting = warning
# resharper_redundant_enumerable_cast_call_highlighting = warning
# resharper_redundant_enum_case_label_for_default_section_highlighting = none
# resharper_redundant_explicit_array_creation_highlighting = warning
# resharper_redundant_explicit_array_size_highlighting = warning
# resharper_redundant_explicit_nullable_creation_highlighting = warning
# resharper_redundant_explicit_params_array_creation_highlighting = suggestion
# resharper_redundant_explicit_positional_property_declaration_highlighting = warning
# resharper_redundant_extends_list_entry_highlighting = warning
# resharper_redundant_fixed_pointer_declaration_highlighting = suggestion
# resharper_redundant_if_else_block_highlighting = hint
# resharper_redundant_if_statement_then_keyword_highlighting = none
# resharper_redundant_immediate_delegate_invocation_highlighting = suggestion
# resharper_redundant_include_highlighting = warning
# resharper_redundant_is_before_relational_pattern_highlighting = suggestion
# resharper_redundant_iterator_keyword_highlighting = warning
# resharper_redundant_jump_statement_highlighting = warning
# resharper_redundant_lambda_parameter_type_highlighting = warning
# resharper_redundant_lambda_signature_parentheses_highlighting = hint
# resharper_redundant_linebreak_highlighting = none
# resharper_redundant_logical_conditional_expression_operand_highlighting = warning
# resharper_redundant_me_qualifier_highlighting = warning
# resharper_redundant_my_base_qualifier_highlighting = warning
# resharper_redundant_my_class_qualifier_highlighting = warning
# resharper_redundant_name_qualifier_highlighting = warning
# resharper_redundant_not_null_constraint_highlighting = warning
# resharper_redundant_nullable_annotation_on_reference_type_constraint_highlighting = warning
# resharper_redundant_nullable_annotation_on_type_constraint_has_non_nullable_base_type_highlighting = warning
# resharper_redundant_nullable_annotation_on_type_constraint_has_non_nullable_type_kind_highlighting = warning
# resharper_redundant_nullable_directive_highlighting = warning
# resharper_redundant_nullable_flow_attribute_highlighting = warning
# resharper_redundant_nullable_type_mark_highlighting = warning
# resharper_redundant_nullness_attribute_with_nullable_reference_types_highlighting = warning
# resharper_redundant_overflow_checking_context_highlighting = warning
# resharper_redundant_overload_global_highlighting = suggestion
# resharper_redundant_overload_local_highlighting = suggestion
# resharper_redundant_overridden_member_highlighting = warning
# resharper_redundant_params_highlighting = warning
# resharper_redundant_parentheses_highlighting = none
# resharper_redundant_partial_method_empty_implementation_highlighting = warning
# resharper_redundant_pattern_parentheses_highlighting = hint
# resharper_redundant_property_parentheses_highlighting = hint
# resharper_redundant_property_pattern_clause_highlighting = suggestion
# resharper_redundant_qualifier_highlighting = warning
# resharper_redundant_query_order_by_ascending_keyword_highlighting = hint
# resharper_redundant_range_bound_highlighting = suggestion
# resharper_redundant_readonly_modifier_highlighting = suggestion
# resharper_redundant_record_class_keyword_highlighting = warning
# resharper_redundant_scoped_parameter_modifier_highlighting = warning
# resharper_redundant_sets_required_members_attribute_highlighting = warning
# resharper_redundant_setter_value_parameter_declaration_highlighting = hint
# resharper_redundant_space_highlighting = none
# resharper_redundant_spread_element_highlighting = suggestion
# resharper_redundant_string_format_call_highlighting = warning
# resharper_redundant_string_interpolation_highlighting = suggestion
# resharper_redundant_string_to_char_array_call_highlighting = warning
# resharper_redundant_string_type_highlighting = suggestion
# resharper_redundant_suppress_nullable_warning_expression_highlighting = warning
# resharper_redundant_switch_expression_arms_highlighting = warning
# resharper_redundant_ternary_expression_highlighting = warning
# resharper_redundant_to_string_call_for_value_type_highlighting = hint
# resharper_redundant_to_string_call_highlighting = warning
# resharper_redundant_type_arguments_inside_nameof_highlighting = suggestion
# resharper_redundant_type_arguments_of_method_highlighting = warning
# resharper_redundant_type_check_in_pattern_highlighting = warning
# resharper_redundant_type_declaration_body_highlighting = suggestion
# resharper_redundant_unsafe_context_highlighting = warning
# resharper_redundant_using_directive_global_highlighting = warning
# resharper_redundant_using_directive_highlighting = warning
# resharper_redundant_verbatim_prefix_highlighting = suggestion
# resharper_redundant_verbatim_string_prefix_highlighting = suggestion
# resharper_redundant_virtual_modifier_highlighting = warning
# resharper_redundant_with_cancellation_highlighting = warning
# resharper_redundant_with_expression_highlighting = suggestion
# resharper_reference_equals_with_value_type_highlighting = warning
# resharper_reg_exp_inspections_highlighting = warning
# resharper_remove_constructor_invocation_highlighting = none
# resharper_remove_redundant_or_statement_false_highlighting = suggestion
# resharper_remove_redundant_or_statement_true_highlighting = suggestion
# resharper_remove_to_list_1_highlighting = suggestion
# resharper_remove_to_list_2_highlighting = suggestion
# resharper_replace_async_with_task_return_highlighting = none
# resharper_replace_auto_property_with_computed_property_highlighting = hint
# resharper_replace_conditional_expression_with_null_coalescing_highlighting = suggestion
# resharper_replace_object_pattern_with_var_pattern_highlighting = suggestion
# resharper_replace_sequence_equal_with_constant_pattern_highlighting = suggestion
# resharper_replace_slice_with_range_indexer_highlighting = hint
# resharper_replace_substring_with_range_indexer_highlighting = hint
# resharper_replace_with_field_keyword_highlighting = suggestion
# resharper_replace_with_first_or_default_1_highlighting = suggestion
# resharper_replace_with_first_or_default_2_highlighting = suggestion
# resharper_replace_with_first_or_default_3_highlighting = suggestion
# resharper_replace_with_first_or_default_4_highlighting = suggestion
# resharper_replace_with_last_or_default_1_highlighting = suggestion
# resharper_replace_with_last_or_default_2_highlighting = suggestion
# resharper_replace_with_last_or_default_3_highlighting = suggestion
# resharper_replace_with_last_or_default_4_highlighting = suggestion
# resharper_replace_with_of_type_1_highlighting = suggestion
# resharper_replace_with_of_type_2_highlighting = suggestion
# resharper_replace_with_of_type_3_highlighting = suggestion
# resharper_replace_with_of_type_any_1_highlighting = suggestion
# resharper_replace_with_of_type_any_2_highlighting = suggestion
# resharper_replace_with_of_type_count_1_highlighting = suggestion
# resharper_replace_with_of_type_count_2_highlighting = suggestion
# resharper_replace_with_of_type_first_1_highlighting = suggestion
# resharper_replace_with_of_type_first_2_highlighting = suggestion
# resharper_replace_with_of_type_first_or_default_1_highlighting = suggestion
# resharper_replace_with_of_type_first_or_default_2_highlighting = suggestion
# resharper_replace_with_of_type_last_1_highlighting = suggestion
# resharper_replace_with_of_type_last_2_highlighting = suggestion
# resharper_replace_with_of_type_last_or_default_1_highlighting = suggestion
# resharper_replace_with_of_type_last_or_default_2_highlighting = suggestion
# resharper_replace_with_of_type_long_count_highlighting = suggestion
# resharper_replace_with_of_type_single_1_highlighting = suggestion
# resharper_replace_with_of_type_single_2_highlighting = suggestion
# resharper_replace_with_of_type_single_or_default_1_highlighting = suggestion
# resharper_replace_with_of_type_single_or_default_2_highlighting = suggestion
# resharper_replace_with_of_type_where_highlighting = suggestion
# resharper_replace_with_primary_constructor_parameter_highlighting = suggestion
# resharper_replace_with_simple_assignment_false_highlighting = suggestion
# resharper_replace_with_simple_assignment_true_highlighting = suggestion
# resharper_replace_with_single_assignment_false_highlighting = suggestion
# resharper_replace_with_single_assignment_true_highlighting = suggestion
# resharper_replace_with_single_call_to_any_highlighting = suggestion
# resharper_replace_with_single_call_to_count_highlighting = suggestion
# resharper_replace_with_single_call_to_first_highlighting = suggestion
# resharper_replace_with_single_call_to_first_or_default_highlighting = suggestion
# resharper_replace_with_single_call_to_last_highlighting = suggestion
# resharper_replace_with_single_call_to_last_or_default_highlighting = suggestion
# resharper_replace_with_single_call_to_single_highlighting = suggestion
# resharper_replace_with_single_call_to_single_or_default_highlighting = suggestion
# resharper_replace_with_single_or_default_1_highlighting = suggestion
# resharper_replace_with_single_or_default_2_highlighting = suggestion
# resharper_replace_with_single_or_default_3_highlighting = suggestion
# resharper_replace_with_single_or_default_4_highlighting = suggestion
# resharper_replace_with_string_is_null_or_empty_highlighting = suggestion
# resharper_required_base_types_conflict_highlighting = warning
# resharper_required_base_types_direct_conflict_highlighting = warning
# resharper_required_base_types_is_not_inherited_highlighting = warning
# resharper_resource_item_not_resolved_highlighting = error
# resharper_resource_not_resolved_highlighting = error
# resharper_resx_not_resolved_highlighting = warning
# resharper_return_of_task_produced_by_using_variable_highlighting = warning
# resharper_return_of_using_variable_highlighting = warning
# resharper_return_type_can_be_enumerable_global_highlighting = none
# resharper_return_type_can_be_enumerable_local_highlighting = none
# resharper_return_type_can_be_not_nullable_highlighting = warning
# resharper_return_value_of_pure_method_is_not_used_highlighting = warning
# resharper_route_templates_action_route_prefix_can_be_extracted_to_controller_route_highlighting = hint
# resharper_route_templates_ambiguous_matching_constraint_constructor_highlighting = warning
# resharper_route_templates_constraint_argument_cannot_be_converted_highlighting = warning
# resharper_route_templates_controller_route_parameter_is_not_passed_to_methods_highlighting = hint
# resharper_route_templates_duplicated_parameter_highlighting = warning
# resharper_route_templates_matching_constraint_constructor_not_resolved_highlighting = warning
# resharper_route_templates_method_missing_route_parameters_highlighting = hint
# resharper_route_templates_optional_parameter_can_be_preceded_only_by_single_period_highlighting = warning
# resharper_route_templates_optional_parameter_must_be_at_the_end_of_segment_highlighting = warning
# resharper_route_templates_parameter_constraint_can_be_specified_highlighting = hint
# resharper_route_templates_parameter_type_and_constraints_mismatch_highlighting = warning
# resharper_route_templates_parameter_type_can_be_made_stricter_highlighting = suggestion
# resharper_route_templates_route_parameter_constraint_not_resolved_highlighting = warning
# resharper_route_templates_route_parameter_is_not_passed_to_method_highlighting = hint
# resharper_route_templates_route_token_not_resolved_highlighting = warning
# resharper_route_templates_symbol_not_resolved_highlighting = warning
# resharper_route_templates_syntax_error_highlighting = warning
# resharper_safe_cast_is_used_as_type_check_highlighting = suggestion
# resharper_script_tag_has_both_src_and_content_attributes_highlighting = error
# resharper_sealed_member_in_sealed_class_highlighting = warning
# resharper_separate_control_transfer_statement_highlighting = none
# resharper_separate_local_functions_with_jump_statement_highlighting = hint
# resharper_service_contract_without_operations_highlighting = warning
# resharper_shader_lab_shader_reference_multiple_candidates_highlighting = warning
# resharper_shader_lab_shader_reference_not_resolved_highlighting = warning
# resharper_shebang_directive_bad_placement_highlighting = warning
# resharper_shift_expression_real_shift_count_is_zero_highlighting = warning
# resharper_shift_expression_result_equals_zero_highlighting = warning
# resharper_shift_expression_right_operand_not_equal_real_count_highlighting = warning
# resharper_shift_expression_zero_left_operand_highlighting = warning
# resharper_similar_anonymous_type_nearby_highlighting = hint
# resharper_simplify_conditional_operator_highlighting = suggestion
# resharper_simplify_conditional_ternary_expression_highlighting = suggestion
# resharper_simplify_i_if_highlighting = suggestion
# resharper_simplify_linq_expression_use_all_highlighting = suggestion
# resharper_simplify_linq_expression_use_any_highlighting = suggestion
# resharper_simplify_string_interpolation_highlighting = suggestion
# resharper_specify_a_culture_in_string_conversion_explicitly_highlighting = warning
# resharper_specify_string_comparison_highlighting = hint
# resharper_spin_lock_in_readonly_field_highlighting = warning
# resharper_stack_alloc_inside_loop_highlighting = warning
# resharper_static_member_initializer_referes_to_member_below_highlighting = warning
# resharper_static_member_in_generic_type_highlighting = warning
# resharper_static_problem_in_text_highlighting = warning
# resharper_std_is_constant_evaluated_will_always_evaluate_to_constant_highlighting = warning
# resharper_stream_read_return_value_ignored_highlighting = warning
# resharper_string_compare_is_culture_specific_1_highlighting = warning
# resharper_string_compare_is_culture_specific_2_highlighting = warning
# resharper_string_compare_is_culture_specific_3_highlighting = warning
# resharper_string_compare_is_culture_specific_4_highlighting = warning
# resharper_string_compare_is_culture_specific_5_highlighting = warning
# resharper_string_compare_is_culture_specific_6_highlighting = warning
# resharper_string_compare_to_is_culture_specific_highlighting = warning
# resharper_string_ends_with_is_culture_specific_highlighting = none
# resharper_string_index_of_is_culture_specific_1_highlighting = warning
# resharper_string_index_of_is_culture_specific_2_highlighting = warning
# resharper_string_index_of_is_culture_specific_3_highlighting = warning
# resharper_string_last_index_of_is_culture_specific_1_highlighting = warning
# resharper_string_last_index_of_is_culture_specific_2_highlighting = warning
# resharper_string_last_index_of_is_culture_specific_3_highlighting = warning
# resharper_string_literal_as_interpolation_argument_highlighting = suggestion
# resharper_string_span_comparison_highlighting = warning
# resharper_string_starts_with_is_culture_specific_highlighting = none
# resharper_structured_message_template_problem_highlighting = warning
# resharper_struct_can_be_made_read_only_highlighting = suggestion
# resharper_struct_lacks_i_equatable_global_highlighting = warning
# resharper_struct_lacks_i_equatable_local_highlighting = warning
# resharper_struct_member_can_be_made_read_only_highlighting = none
# resharper_suggest_base_type_for_parameter_highlighting = none
# resharper_suggest_base_type_for_parameter_in_constructor_highlighting = none
# resharper_suggest_discard_declaration_var_style_highlighting = hint
# resharper_suggest_var_or_type_built_in_types_highlighting = hint
# resharper_suggest_var_or_type_deconstruction_declarations_highlighting = hint
# resharper_suggest_var_or_type_elsewhere_highlighting = hint
# resharper_suggest_var_or_type_simple_types_highlighting = hint
# resharper_suppress_nullable_warning_expression_as_inverted_is_expression_highlighting = warning
# resharper_suspicious_lock_over_synchronization_primitive_highlighting = warning
# resharper_suspicious_math_sign_method_highlighting = warning
# resharper_suspicious_parameter_name_in_argument_null_exception_highlighting = warning
# resharper_suspicious_type_conversion_global_highlighting = warning
# resharper_swap_via_deconstruction_highlighting = suggestion
# resharper_switch_expression_handles_some_known_enum_values_with_exception_in_default_highlighting = hint
# resharper_switch_statement_for_enum_misses_default_section_highlighting = hint
# resharper_switch_statement_handles_some_known_enum_values_with_default_highlighting = hint
# resharper_switch_statement_missing_some_enum_cases_no_default_highlighting = hint
# resharper_symbol_from_not_copied_locally_reference_used_warning_highlighting = warning
# resharper_tabs_and_spaces_mismatch_highlighting = none
# resharper_tabs_are_disallowed_highlighting = none
# resharper_tabs_outside_indent_highlighting = none
# resharper_tail_recursive_call_highlighting = hint
# resharper_template_duplicate_property_problem_highlighting = warning
# resharper_template_format_string_problem_highlighting = warning
# resharper_template_is_not_compile_time_constant_problem_highlighting = warning
# resharper_thread_static_at_instance_field_highlighting = warning
# resharper_thread_static_field_has_initializer_highlighting = warning
# resharper_too_wide_local_variable_scope_highlighting = suggestion
# resharper_try_cast_always_succeeds_highlighting = suggestion
# resharper_try_statements_can_be_merged_highlighting = hint
# resharper_type_parameter_can_be_variant_highlighting = suggestion
# resharper_type_with_suspicious_equality_is_used_in_record_global_highlighting = warning
# resharper_type_with_suspicious_equality_is_used_in_record_local_highlighting = warning
# resharper_unassigned_field_global_highlighting = suggestion
# resharper_unassigned_field_local_highlighting = warning
# resharper_unassigned_get_only_auto_property_highlighting = warning
# resharper_unassigned_readonly_field_highlighting = warning
# resharper_unclosed_script_highlighting = error
# resharper_unexpected_attribute_highlighting = warning
# resharper_unexpected_directive_highlighting = warning
# resharper_unnecessary_whitespace_highlighting = none
# resharper_unreachable_switch_arm_due_to_integer_analysis_highlighting = warning
# resharper_unreachable_switch_case_due_to_integer_analysis_highlighting = warning
# resharper_unsupported_required_base_type_highlighting = warning
# resharper_unused_anonymous_method_signature_highlighting = warning
# resharper_unused_auto_property_accessor_global_highlighting = warning
# resharper_unused_auto_property_accessor_local_highlighting = warning
# resharper_unused_import_clause_highlighting = warning
# resharper_unused_local_function_highlighting = warning
# resharper_unused_local_function_parameter_highlighting = warning
# resharper_unused_local_function_return_value_highlighting = warning
# resharper_unused_member_global_highlighting = suggestion
# resharper_unused_member_hierarchy_global_highlighting = suggestion
# resharper_unused_member_hierarchy_local_highlighting = warning
# resharper_unused_member_in_super_global_highlighting = suggestion
# resharper_unused_member_in_super_local_highlighting = warning
# resharper_unused_member_local_highlighting = warning
# resharper_unused_method_return_value_global_highlighting = suggestion
# resharper_unused_method_return_value_local_highlighting = warning
# resharper_unused_nullable_directive_highlighting = warning
# resharper_unused_parameter_global_highlighting = suggestion
# resharper_unused_parameter_in_partial_method_highlighting = warning
# resharper_unused_parameter_local_highlighting = warning
# resharper_unused_tuple_component_in_return_value_highlighting = warning
# resharper_unused_type_global_highlighting = suggestion
# resharper_unused_type_local_highlighting = warning
# resharper_unused_type_parameter_highlighting = warning
# resharper_unused_variable_highlighting = warning
# resharper_usage_of_default_struct_equality_highlighting = warning
# resharper_useless_binary_operation_highlighting = warning
# resharper_useless_comparison_to_integral_constant_highlighting = warning
# resharper_use_array_creation_expression_1_highlighting = suggestion
# resharper_use_array_creation_expression_2_highlighting = suggestion
# resharper_use_array_empty_method_highlighting = suggestion
# resharper_use_await_using_highlighting = suggestion
# resharper_use_cancellation_token_for_i_async_enumerable_highlighting = suggestion
# resharper_use_collection_count_property_highlighting = suggestion
# resharper_use_configure_await_false_for_async_disposable_highlighting = none
# resharper_use_configure_await_false_highlighting = suggestion
# resharper_use_discard_assignment_highlighting = suggestion
# resharper_use_empty_types_field_highlighting = suggestion
# resharper_use_event_args_empty_field_highlighting = suggestion
# resharper_use_format_specifier_in_format_string_highlighting = suggestion
# resharper_use_implicitly_typed_variable_evident_highlighting = hint
# resharper_use_implicitly_typed_variable_highlighting = none
# resharper_use_implicit_by_val_modifier_highlighting = hint
# resharper_use_indexed_property_highlighting = suggestion
# resharper_use_index_from_end_expression_highlighting = suggestion
# resharper_use_method_any_0_highlighting = suggestion
# resharper_use_method_any_1_highlighting = suggestion
# resharper_use_method_any_2_highlighting = suggestion
# resharper_use_method_any_3_highlighting = suggestion
# resharper_use_method_any_4_highlighting = suggestion
# resharper_use_nameof_expression_for_part_of_the_string_highlighting = none
# resharper_use_nameof_expression_highlighting = suggestion
# resharper_use_nameof_for_dependency_property_highlighting = suggestion
# resharper_use_name_of_instead_of_to_string_highlighting = suggestion
# resharper_use_name_of_instead_of_type_of_highlighting = suggestion
# resharper_use_negated_pattern_in_is_expression_highlighting = hint
# resharper_use_negated_pattern_matching_highlighting = hint
# resharper_use_nullable_annotation_instead_of_attribute_highlighting = suggestion
# resharper_use_nullable_attributes_supported_by_compiler_highlighting = suggestion
# resharper_use_nullable_reference_types_annotation_syntax_highlighting = warning
# resharper_use_null_propagation_highlighting = hint
# resharper_use_pattern_matching_highlighting = suggestion
# resharper_use_positional_deconstruction_pattern_highlighting = none
# resharper_use_raw_string_highlighting = hint
# resharper_use_string_interpolation_highlighting = suggestion
# resharper_use_string_interpolation_when_possible_highlighting = hint
# resharper_use_switch_case_pattern_variable_highlighting = suggestion
# resharper_use_symbol_alias_highlighting = hint
# resharper_use_throw_if_null_method_highlighting = none
# resharper_use_unsigned_right_shift_operator_highlighting = suggestion
# resharper_use_verbatim_string_highlighting = hint
# resharper_use_with_expression_to_copy_anonymous_object_highlighting = suggestion
# resharper_use_with_expression_to_copy_record_highlighting = suggestion
# resharper_use_with_expression_to_copy_struct_highlighting = suggestion
# resharper_use_with_expression_to_copy_tuple_highlighting = suggestion
# resharper_using_statement_resource_initialization_expression_highlighting = hint
# resharper_using_statement_resource_initialization_highlighting = warning
# resharper_value_parameter_not_used_highlighting = warning
# resharper_value_range_attribute_violation_highlighting = warning
# resharper_variable_can_be_not_nullable_highlighting = warning
# resharper_variable_hides_outer_variable_highlighting = warning
# resharper_variable_length_string_hex_escape_sequence_highlighting = warning
# resharper_virtual_member_call_in_constructor_highlighting = warning
# resharper_virtual_member_never_overridden_global_highlighting = suggestion
# resharper_virtual_member_never_overridden_local_highlighting = suggestion
# resharper_void_method_with_must_dispose_resource_attribute_highlighting = warning
# resharper_void_method_with_must_use_return_value_attribute_highlighting = warning
# resharper_vulnerable_api_highlighting = warning
# resharper_web_config_module_not_resolved_highlighting = warning
# resharper_web_config_module_qualification_resolve_highlighting = warning
# resharper_web_config_redundant_add_namespace_tag_highlighting = warning
# resharper_web_config_redundant_location_tag_highlighting = warning
# resharper_web_config_tag_prefix_redundand_highlighting = warning
# resharper_web_config_type_not_resolved_highlighting = warning
# resharper_web_config_unused_add_tag_highlighting = warning
# resharper_web_config_unused_element_due_to_config_source_attribute_highlighting = warning
# resharper_web_config_unused_remove_or_clear_tag_highlighting = warning
# resharper_web_config_web_config_path_warning_highlighting = warning
# resharper_web_config_wrong_module_highlighting = warning
# resharper_web_ignored_path_highlighting = none
# resharper_web_mapped_path_highlighting = hint
# resharper_with_expression_instead_of_initializer_highlighting = suggestion
# resharper_with_expression_modifies_all_members_highlighting = warning
# resharper_wrong_indent_size_highlighting = none
# resharper_xaml_assign_null_to_not_null_attribute_highlighting = warning
# resharper_xaml_avalonia_wrong_binding_mode_for_stream_binding_operator_highlighting = warning
# resharper_xaml_binding_without_context_not_resolved_highlighting = hint
# resharper_xaml_binding_with_context_not_resolved_highlighting = warning
# resharper_xaml_compiled_binding_missing_data_type_error_highlighting_highlighting = error
# resharper_xaml_constructor_warning_highlighting = warning
# resharper_xaml_decimal_parsing_is_culture_dependent_highlighting = warning
# resharper_xaml_dependency_property_resolve_error_highlighting = warning
# resharper_xaml_duplicate_style_setter_highlighting = warning
# resharper_xaml_dynamic_resource_error_highlighting = error
# resharper_xaml_element_name_reference_not_resolved_highlighting = error
# resharper_xaml_empty_grid_length_definition_highlighting = error
# resharper_xaml_field_modifier_requires_name_attribute_highlighting = warning
# resharper_xaml_grid_definitions_can_be_converted_to_attribute_highlighting = hint
# resharper_xaml_ignored_path_highlighting_highlighting = none
# resharper_xaml_index_out_of_grid_definition_highlighting = warning
# resharper_xaml_invalid_dynamic_resource_type_highlighting = suggestion
# resharper_xaml_invalid_member_type_highlighting = error
# resharper_xaml_invalid_resource_target_type_highlighting = error
# resharper_xaml_invalid_resource_type_highlighting = error
# resharper_xaml_invalid_type_highlighting = error
# resharper_xaml_language_level_highlighting = error
# resharper_xaml_mapped_path_highlighting_highlighting = hint
# resharper_xaml_method_arguments_will_be_ignored_highlighting = warning
# resharper_xaml_missing_grid_index_highlighting = warning
# resharper_xaml_overloads_collision_highlighting = warning
# resharper_xaml_parent_is_out_of_current_component_tree_highlighting = warning
# resharper_xaml_path_error_highlighting = warning
# resharper_xaml_possible_null_reference_exception_highlighting = suggestion
# resharper_xaml_redundant_attached_property_highlighting = warning
# resharper_xaml_redundant_binding_mode_attribute_highlighting = warning
# resharper_xaml_redundant_collection_property_highlighting = warning
# resharper_xaml_redundant_freeze_attribute_highlighting = warning
# resharper_xaml_redundant_grid_definitions_highlighting = warning
# resharper_xaml_redundant_grid_span_highlighting = warning
# resharper_xaml_redundant_modifiers_attribute_highlighting = warning
# resharper_xaml_redundant_namespace_alias_highlighting = warning
# resharper_xaml_redundant_name_attribute_highlighting = warning
# resharper_xaml_redundant_property_type_qualifier_highlighting = warning
# resharper_xaml_redundant_resource_highlighting = warning
# resharper_xaml_redundant_styled_value_highlighting = warning
# resharper_xaml_redundant_update_source_trigger_attribute_highlighting = warning
# resharper_xaml_redundant_xamarin_forms_class_declaration_highlighting = warning
# resharper_xaml_resource_file_path_case_mismatch_highlighting = warning
# resharper_xaml_routed_event_resolve_error_highlighting = warning
# resharper_xaml_static_resource_not_resolved_highlighting = warning
# resharper_xaml_style_class_not_found_highlighting = warning
# resharper_xaml_style_invalid_target_type_highlighting = error
# resharper_xaml_unexpected_element_highlighting = error
# resharper_xaml_unexpected_text_token_highlighting = error
# resharper_xaml_xaml_duplicate_device_family_type_view_highlighting_highlighting = error
# resharper_xaml_xaml_mismatched_device_family_view_clr_name_highlighting_highlighting = warning
# resharper_xaml_xaml_relative_source_default_mode_warning_highlighting_highlighting = warning
# resharper_xaml_xaml_unknown_device_family_type_highlighting_highlighting = warning
# resharper_xaml_xaml_xamarin_forms_data_type_and_binding_context_type_mismatched_highlighting_highlighting = warning
# resharper_xaml_x_key_attribute_disallowed_highlighting = error
# resharper_xunit_xunit_test_with_console_output_highlighting = warning
# resharper_zero_index_from_end_highlighting = warning

# [*.{appxmanifest,asax,ascx,aspx,axaml,blockshader,c,c++,c++m,cc,ccm,cginc,compute,cp,cpp,cppm,cs,cshtml,cu,cuh,cxx,cxxm,dtd,fs,fsi,fsscript,fsx,fx,fxh,h,h++,hh,hlsl,hlsli,hlslinc,hp,hpp,hxx,icc,inc,inl,ino,ipp,ixx,master,ml,mli,mpp,mq4,mq5,mqh,mxx,nuspec,paml,razor,resw,resx,shader,shaderFoundry,skin,tcc,tpp,urtshader,usf,ush,uxml,vb,xaml,xamlx,xoml,xsd}]
# indent_style = space
# indent_size = 4
# tab_width = 4
